<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Paranoid Qian's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://paranoidq.github.io/"/>
  <updated>2015-12-17T12:14:52.000Z</updated>
  <id>http://paranoidq.github.io/</id>
  
  <author>
    <name><![CDATA[paranoid qian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Mac中如何查找Java的路径]]></title>
    <link href="http://paranoidq.github.io/2015/12/18/Mac-java/"/>
    <id>http://paranoidq.github.io/2015/12/18/Mac-java/</id>
    <published>2015-12-18T02:28:26.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u65B9_u6CD52_uFF1A"><a href="#u65B9_u6CD52_uFF1A" class="headerlink" title="方法2："></a>方法2：</h3><p>step-wise的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br></pre></td></tr></table></figure>
<p>如果输出的时/usr/bin/java, 证明是链接，需要找到链接的source<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> -<span class="keyword">l</span> `<span class="keyword">which</span> java`</span><br></pre></td></tr></table></figure></p>
<p>输出为实际的java安装路径: <code>rwxr-xr-x  1 root  wheel  74 11 25 13:36 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</code></p>
<p>如果/usr/bin/java指向的仍然是一个symbolic link, 那么继续执行以下命令，直到找到source为止 </p>
<p>[注]</p>
<p>ls -l ` which java`</p>
<p>单引号把Linux命令视为字符集合。反引号会强迫执行Linux命令。和<code>$()</code>一样。在执行一条命令时，会先将其中或者是<code>$()</code> 中的语句当作命令执行一遍，再将结果加入到外层命令中执行</p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac" target="_blank" rel="external">http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="mac" scheme="http://paranoidq.github.io/tags/mac/"/>
    
      <category term="mac" scheme="http://paranoidq.github.io/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Reading List]]></title>
    <link href="http://paranoidq.github.io/2015/12/11/Reading-List/"/>
    <id>http://paranoidq.github.io/2015/12/11/Reading-List/</id>
    <published>2015-12-11T05:21:50.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>汇集一些平时遇到但没有时间立马阅读的技术好书，望平时闲暇细读。同时共享给各位ITers。暂时没写书评，读过的和正在读的以后补充书评~</p>
</blockquote>
<h3 id="u8BA1_u7B97_u673A_u539F_u7406"><a href="#u8BA1_u7B97_u673A_u539F_u7406" class="headerlink" title="计算机原理"></a>计算机原理</h3><ol>
<li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa11/61a-python/content/www/index.html" target="_blank" rel="external">计算机程序的构造和解释</a></li>
</ol>
<h3 id="Linux/Unix"><a href="#Linux/Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h3><ol>
<li><a href="http://www.tldp.org/LDP/abs/html/" target="_blank" rel="external">《Advanced Bash: Scrpiting Guide》</a></li>
<li><a href="https://book.douban.com/subject/5387401/" target="_blank" rel="external">《Unix编程艺术》</a></li>
</ol>
<a id="more"></a>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul>
<li><p>入门<br>  <a href="https://docs.python.org/3/tutorial/" target="_blank" rel="external">Python Manunal - Tutorials</a><br>  <a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">廖雪峰的Python教程</a> （较为全面，也有操作性的代码。但是细节方面解释不多，仅做入门）</p>
</li>
<li><p>进阶<br>  <a href="http://www.effectivepython.com/" target="_blank" rel="external">Effective Python</a><br>  <a href="http://learnpythonthehardway.org/book/" target="_blank" rel="external">Learning Python the hard way</a><br>  <a href="http://python3-cookbook.readthedocs.org/zh_CN/latest/" target="_blank" rel="external">Python Cookbook</a><br>  <a href="http://www.diveintopython3.net/table-of-contents.html" target="_blank" rel="external">Dive into Python</a><br>  [Python核心编程]</p>
</li>
<li><p>源码<br>  [Python源码剖析]<br>  <a href="https://docs.python.org/3/library/index.html" target="_blank" rel="external">Python标准库</a></p>
</li>
<li><p>PPT资料<br>  <a href="http://dongweiming.github.io/Expert-Python/#1" target="_blank" rel="external">Python高级编程-Dongweiming</a></p>
</li>
<li><p>边角料<br>  <a href="https://book.douban.com/subject/6025284/" target="_blank" rel="external">Python灰帽子</a></p>
</li>
</ul>
<h3 id="u7A0B_u5E8F_u4E0E_u751F_u6D3B"><a href="#u7A0B_u5E8F_u4E0E_u751F_u6D3B" class="headerlink" title="程序与生活"></a>程序与生活</h3><ol>
<li><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="external">《黑客与画家》</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>汇集一些平时遇到但没有时间立马阅读的技术好书，望平时闲暇细读。同时共享给各位ITers。暂时没写书评，读过的和正在读的以后补充书评~</p>
</blockquote>
<h3 id="u8BA1_u7B97_u673A_u539F_u7406"><a href="#u8BA1_u7B97_u673A_u539F_u7406" class="headerlink" title="计算机原理"></a>计算机原理</h3><ol>
<li><a href="http://www-inst.eecs.berkeley.edu/~cs61a/fa11/61a-python/content/www/index.html">计算机程序的构造和解释</a></li>
</ol>
<h3 id="Linux/Unix"><a href="#Linux/Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h3><ol>
<li><a href="http://www.tldp.org/LDP/abs/html/">《Advanced Bash: Scrpiting Guide》</a></li>
<li><a href="https://book.douban.com/subject/5387401/">《Unix编程艺术》</a></li>
</ol>]]>
    
    </summary>
    
      <category term="reading" scheme="http://paranoidq.github.io/tags/reading/"/>
    
      <category term="reading" scheme="http://paranoidq.github.io/categories/reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSH Principles（总结和笔记）]]></title>
    <link href="http://paranoidq.github.io/2015/12/11/SSH-Principles/"/>
    <id>http://paranoidq.github.io/2015/12/11/SSH-Principles/</id>
    <published>2015-12-11T03:00:21.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="preprocessor"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="preprocessor"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><ol>
<li>基本流程：<ul>
<li>client请求登陆remote server</li>
<li>server发送公钥给client，并告知client发送自己的密码</li>
<li>client用公钥加密密码，发送给server</li>
<li>server用私钥解密密码，如果成功，就允许用户登陆</li>
</ul>
</li>
<li>为何安全：<ul>
<li>全程不传输私钥，及时截获报文，只要私钥不泄露，就不能获取密码</li>
<li>密码由随机的公钥加密，可换</li>
</ul>
</li>
<li>为何有风险：<ul>
<li>如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的</li>
<li>中间人攻击（Man-in-the-middle attack）：如果攻击者插在用户与远程主机之间（比如在公共的wifi区域）用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了</li>
</ul>
</li>
</ol>
<h3 id="u4E24_u79CD_u767B_u5F55_u65B9_u5F0F"><a href="#u4E24_u79CD_u767B_u5F55_u65B9_u5F0F" class="headerlink" title="两种登录方式"></a>两种登录方式</h3><h4 id="u53E3_u4EE4_u767B_u5F55"><a href="#u53E3_u4EE4_u767B_u5F55" class="headerlink" title="口令登录"></a>口令登录</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'host (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。然后要求用户输入密码<br>    <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Warning</span>: <span class="string">Permanently added 'host,12.18.429.21' (RSA) to the list of known hosts.</span></span><br><span class="line"><span class="attribute">Password</span>: <span class="string">(enter password)</span></span><br></pre></td></tr></table></figure></p>
<p>保存远程主机的公钥在<code>$HOME/.ssh/known_hosts</code>中，以后连接主机时client能识别公钥已经保存在本地，跳过警告部分。（但是仍然需要输入密码）</p>
<p><code>/etc/ssh/ssh_known_hosts</code>保存对所有用户可信的远程主机公钥</p>
<h4 id="u516C_u94A5_u767B_u5F55"><a href="#u516C_u94A5_u767B_u5F55" class="headerlink" title="公钥登录"></a>公钥登录</h4><blockquote>
<p>原理：</p>
</blockquote>
<ol>
<li>用户将自己的公钥储存在远程主机上。</li>
<li>登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。</li>
<li>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码</li>
</ol>
<blockquote>
<p>操作：</p>
</blockquote>
<p>用户生成自己的公钥：在<code>$HOME/.ssh</code>下会生成<code>id_rsa.pub</code>和<code>id_rsa</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>拷贝公钥到server：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-copy-id user<span class="variable">@host</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="variable">$ </span>scp /<span class="constant">Users/</span>paranoidq/.ssh/id_rsa.pub paranoidq<span class="variable">@192</span>.<span class="number">168.235</span>.<span class="number">131</span><span class="symbol">:/home/paranoidq/</span>.ssh/authorized_keys </span><br><span class="line"><span class="comment"># 但是scp不能附加多个authorized_keys，所以貌似只能支持一个用户一个公钥！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于ssh-copy-id的过程：</p>
</blockquote>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh user<span class="variable">@host</span> <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li><code>$ ssh user@host</code>表示登录远程主机；</li>
<li><code>mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>表示登录后在远程shell上执行的命令</li>
<li><code>mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个</li>
<li><code>cat &gt;&gt; .ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件<code>authorized_keys</code>的末尾</li>
</ol>
<p>注：有必要学习一下bash和shell的知识了，推荐Mendel Cooper的<a href="http://www.tldp.org/LDP/abs/html/" target="_blank" rel="external">《Advanced Bash: Scrpiting Guide》</a></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">廖雪峰的官方网站，ssh原理与运用</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="preprocessor"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="preprocessor"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ssh" scheme="http://paranoidq.github.io/tags/ssh/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux System Commands(1）]]></title>
    <link href="http://paranoidq.github.io/2015/12/10/Linux-System-Commands-and-Shell-Practices-Reading-Records/"/>
    <id>http://paranoidq.github.io/2015/12/10/Linux-System-Commands-and-Shell-Practices-Reading-Records/</id>
    <published>2015-12-10T08:58:22.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u7528_u6237_u7BA1_u7406"><a href="#u7528_u6237_u7BA1_u7406" class="headerlink" title="用户管理"></a>用户管理</h3><h3 id="u8FDB_u7A0B_u7BA1_u7406"><a href="#u8FDB_u7A0B_u7BA1_u7406" class="headerlink" title="进程管理"></a>进程管理</h3><p>### </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u7528_u6237_u7BA1_u7406"><a href="#u7528_u6237_u7BA1_u7406" class="headerlink" title="用户管理"></a>用户管理</h3><h3 id="u8FDB_u7A0B_u7BA1_u]]>
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="shell" scheme="http://paranoidq.github.io/tags/shell/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git Fantastic Usages]]></title>
    <link href="http://paranoidq.github.io/2015/12/09/Git-Fantastic-Usages/"/>
    <id>http://paranoidq.github.io/2015/12/09/Git-Fantastic-Usages/</id>
    <published>2015-12-09T07:20:18.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><ol>
<li>如何忽略所有文件除了某些文件</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ignore everything</span></span><br><span class="line"><span class="keyword">*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># But not these files...</span></span><br><span class="line">!.gitignore</span><br><span class="line">!script.pl</span><br><span class="line">!template.latex</span><br><span class="line"><span class="comment"># etc...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...even if they are in subdirectories</span></span><br><span class="line">!<span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><ol>
<li>如何忽略所有文件除了某些文件</li>
</ol>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ignore everything</span></span><br><span class="line"><span class="keyword">*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># But not these files...</span></span><br><span class="line">!.gitignore</span><br><span class="line">!script.pl</span><br><span class="line">!template.latex</span><br><span class="line"><span class="comment"># etc...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...even if they are in subdirectories</span></span><br><span class="line">!<span class="keyword">*</span>/</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="git" scheme="http://paranoidq.github.io/tags/git/"/>
    
      <category term="tools" scheme="http://paranoidq.github.io/categories/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac Terminal Commands]]></title>
    <link href="http://paranoidq.github.io/2015/12/09/mac-terminal-commands/"/>
    <id>http://paranoidq.github.io/2015/12/09/mac-terminal-commands/</id>
    <published>2015-12-09T03:59:04.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<p>   本文所有快捷键基于iterm2. 有些快捷键被系统屏蔽了，到<code>系统偏好设置</code>中删除无用的快捷键即可</p>
<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><ul>
<li>显示光标位置： <code>command + /</code></li>
<li>移动到行首： <code>ctrl + a</code></li>
<li>移动到行尾： <code>ctrl + e</code></li>
<li>向前移动一个字符： <code>ctrl + f</code> = Forward</li>
<li>向后移动一个字符： <code>ctrl + b</code> = Backward</li>
<li>向前移动一个单词： <code>alt + f</code></li>
<li>向后移动一个单词： <code>alt + b</code></li>
</ul>
<h3 id="u5B57_u7B26_u64CD_u4F5C"><a href="#u5B57_u7B26_u64CD_u4F5C" class="headerlink" title="字符操作"></a>字符操作</h3><ul>
<li>删除一个字符： <code>ctrl + d</code> = <code>Delete</code></li>
<li>删除一个字符（前向）： <code>ctrl + h</code> = <code>Backspace</code></li>
<li>删除光标前到行首的字符： <code>ctrl + u</code> = 清除本行</li>
<li>删除光标前到行尾的字符： <code>ctrl + k</code></li>
<li>恢复之前的操作： <code>ctrl + y</code></li>
</ul>
<h3 id="u8F93_u5165_u64CD_u4F5C"><a href="#u8F93_u5165_u64CD_u4F5C" class="headerlink" title="输入操作"></a>输入操作</h3><ul>
<li>自动补全历史记录： <code>command + ;</code></li>
</ul>
<h3 id="u5C4F_u5E55_u64CD_u4F5C"><a href="#u5C4F_u5E55_u64CD_u4F5C" class="headerlink" title="屏幕操作"></a>屏幕操作</h3><ul>
<li>清屏： <code>command + r</code></li>
<li>新建标签： <code>ctrl + t</code></li>
<li>关闭当前标签页： <code>command + w</code></li>
<li>左右分割： <code>command + d</code></li>
<li>垂直分割： <code>command + shift + d</code></li>
<li>切换标签页： <code>command + [number]/[up/down]</code></li>
<li></li>
</ul>
<h3 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>打开文件： <code>command + [Click]</code></li>
</ul>
<h3 id="job_u64CD_u4F5C"><a href="#job_u64CD_u4F5C" class="headerlink" title="job操作"></a>job操作</h3><ul>
<li>挂起job： <code>ctrl + z</code></li>
<li>查看挂起的job： <code>jobs</code></li>
<li>继续执行挂起的job： <code>fg</code></li>
<li></li>
<li></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>   本文所有快捷键基于iterm2. 有些快捷键被系统屏蔽了，到<code>系统偏好设置</code>中删除无用的快捷键即可</p>
<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" c]]>
    </summary>
    
      <category term="mac" scheme="http://paranoidq.github.io/tags/mac/"/>
    
      <category term="shortcat" scheme="http://paranoidq.github.io/tags/shortcat/"/>
    
      <category term="mac" scheme="http://paranoidq.github.io/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux Server Commands]]></title>
    <link href="http://paranoidq.github.io/2015/12/08/linux-server-command/"/>
    <id>http://paranoidq.github.io/2015/12/08/linux-server-command/</id>
    <published>2015-12-08T13:41:24.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ssh_u8FDC_u7A0B_u767B_u5F55"><a href="#ssh_u8FDC_u7A0B_u767B_u5F55" class="headerlink" title="ssh远程登录"></a>ssh远程登录</h3><p>服务器需要开启远程服务</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 针对fedora</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="preprocessor"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="preprocessor"># ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>客户端登陆：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh paranoidq<span class="annotation">@[ip]</span></span><br></pre></td></tr></table></figure>
<p>免密码登陆</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将公钥id_rsa.pub拷贝到目标机器上的对应位置</span></span><br><span class="line"><span class="variable">$ </span>scp /<span class="constant">Users/</span>paranoidq/.ssh/id_rsa.pub paranoidq<span class="variable">@192</span>.<span class="number">168.235</span>.<span class="number">131</span><span class="symbol">:/home/paranoidq/</span>.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h3 id="u67E5_u770BLinux_u670D_u52A1_u5668_u72B6_u51B5"><a href="#u67E5_u770BLinux_u670D_u52A1_u5668_u72B6_u51B5" class="headerlink" title="查看Linux服务器状况"></a>查看Linux服务器状况</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>主要通过/proc文件夹下面的文件来获取</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取CPU个数</span></span><br><span class="line">cat /<span class="keyword">proc</span>/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取CPU core个数</span></span><br><span class="line">cat /<span class="keyword">proc</span>/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取逻辑CPU个数 = CPU个数 * cores</span></span><br><span class="line">cat /<span class="keyword">proc</span>/cupinfo | grep <span class="string">"processor"</span> | wc -l</span><br></pre></td></tr></table></figure>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 查看内存</span></span><br><span class="line"><span class="built_in">free</span> -m <span class="preprocessor"># 以MB的方式显示</span></span><br><span class="line"></span><br><span class="line">total   used    <span class="built_in">free</span>    shared      buffers     cached</span><br><span class="line"><span class="number">3949</span>    <span class="number">1397</span>    <span class="number">2551</span>    <span class="number">0</span>           <span class="number">268</span>         <span class="number">917</span></span><br><span class="line">-/+ buffers/cached      <span class="number">211</span>        <span class="number">3737</span></span><br><span class="line">Swap:   <span class="number">8001</span>       <span class="number">0</span>        <span class="number">8001</span></span><br></pre></td></tr></table></figure>
<ul>
<li>total：总内存</li>
<li>used：已使用</li>
<li>free：空闲</li>
<li>shared: 多个进程共享内存</li>
<li>buffers：buffer cache 和 cached page cache: 磁盘缓存</li>
<li>-buffers/cached：(已用内存) = used - buffers - cached</li>
<li>+buffers/cached：(<code>程序</code>可用内存) = free + buffers + cached</li>
</ul>
<p>注：</p>
<ul>
<li>buffer 和 cached 对操作系统来讲属于被使用的部分，但是程序可以挪用他们，因此程序可用内存需要算上这两个</li>
<li>Linux系统内存是拿来用的，不满时不会使用到swap分区（这点和Windows不同，无论何时都会使用硬盘交换文件来读）。因此<code>如果swap没有被使用，那么就不用担心内存小。如果经常看到swap被使用，就需要考虑增加物理内存了——这是判断linux内存是否够用的标准</code></li>
</ul>
<h4 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 查看硬盘分区</span></span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看fs的硬盘占用情况</span></span><br><span class="line">df -h</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看硬盘IO的性能</span></span><br><span class="line">iostat -d -x -k <span class="number">1</span> <span class="number">10</span> ???</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看目录大小</span></span><br><span class="line">du -sh /data</span><br><span class="line"></span><br><span class="line">找出占用空间最多的文件或目录前十</span><br><span class="line">du -cks * | sort -rn | head -n <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h4 id="Linux_Load"><a href="#Linux_Load" class="headerlink" title="Linux Load"></a>Linux Load</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 动态反应系统负载状况</span></span><br><span class="line">top</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 过去1min、5min、15min内进程队列的平均进程数量</span></span><br><span class="line">uptime</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 可以查看系统当前有哪些用户，占用哪些终端</span></span><br><span class="line">w</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># </span></span><br><span class="line">vmstat</span><br></pre></td></tr></table></figure>
<ul>
<li>uptime输出的三个load average值一般不能大于系统逻辑CPU的个数，如果长期大于，则表明CPU过于繁忙，系统负载较高</li>
</ul>
<h4 id="u6574_u4F53_u6027_u80FD"><a href="#u6574_u4F53_u6027_u80FD" class="headerlink" title="整体性能"></a>整体性能</h4><p>vmstat [采样时间间隔/s] [采样次数]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat <span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>procs<ul>
<li>r: 等待运行的进程数</li>
<li>b: 处于非中断睡眠状态的进程数</li>
</ul>
</li>
<li>memory: <ul>
<li>swpd: 虚拟内存使用情况（KB）</li>
<li>free: 空闲内存</li>
<li>buff: 被用来作为缓存的内存</li>
</ul>
</li>
<li>swap：<ul>
<li>si: 从磁盘交换到内存的页数（KB/s）</li>
<li>so: 从内存交换到磁盘的页数（-）</li>
</ul>
</li>
<li>io:<ul>
<li>bi: 发送到块设备的块数（块/s）</li>
<li>bo: 从块设备接收的块数</li>
</ul>
</li>
<li>system:<ul>
<li>in: 每秒的中断数，包括时钟中断</li>
<li>cs: 每秒的上下文切换次数</li>
</ul>
</li>
<li>cpu: (按CPU使用的百分比时间显示)<ul>
<li>us: cpu用户模式使用时间</li>
<li>sy: cpu系统模式使用时间</li>
<li>id: cpu闲置时间</li>
</ul>
</li>
</ul>
<p>标准状况：r &lt; 5 和 b ·= 0</p>
<p>如果r经常大于4，id经常少于50, | usr%+sy% &gt; 85% ，则表示系统的性能比较糟糕。</p>
<h4 id="u5176_u4ED6_u67E5_u770B_u547D_u4EE4"><a href="#u5176_u4ED6_u67E5_u770B_u547D_u4EE4" class="headerlink" title="其他查看命令"></a>其他查看命令</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 查看内核</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 简化版</span></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看发行版信息</span></span><br><span class="line"></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看载入的模块(用lsmod查看lvs模块是否已经载入)</span></span><br><span class="line">lsmod | grep ip_vs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 查看系统是否64位</span></span><br><span class="line"><span class="preprocessor"># 1. 查找 /lib64目录</span></span><br><span class="line">ls -lF / | grep /$ | grep lib64</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 2. 通过file判断文件是32或64位</span></span><br><span class="line">file /sbin/init</span><br></pre></td></tr></table></figure>
<h3 id="u67E5_u770B_u7F51_u7EDC_u914D_u7F6E"><a href="#u67E5_u770B_u7F51_u7EDC_u914D_u7F6E" class="headerlink" title="查看网络配置"></a>查看网络配置</h3><h4 id="Linux_u4E0B_u57FA_u672C_u7F51_u7EDC_u914D_u7F6E"><a href="#Linux_u4E0B_u57FA_u672C_u7F51_u7EDC_u914D_u7F6E" class="headerlink" title="Linux下基本网络配置"></a>Linux下基本网络配置</h4><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 修改hostname</span></span><br><span class="line">vi /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 修改hosts</span></span><br><span class="line">vi /etc/</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># DNS域名</span></span><br><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<h4 id="u670D_u52A1_u5668_u7F51_u7EDC_u8FDE_u63A5_u72B6_u51B5"><a href="#u670D_u52A1_u5668_u7F51_u7EDC_u8FDE_u63A5_u72B6_u51B5" class="headerlink" title="服务器网络连接状况"></a>服务器网络连接状况</h4><p>1.ifconfig</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 只显示eth0的网络配置</span></span><br><span class="line">ifconfig eth0</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 只显示ehto0的Ip地址</span></span><br><span class="line"><span class="preprocessor"># awk语句以空格和:为分隔符，并且打印第四列</span></span><br><span class="line">ifconfig eth0 | grep <span class="string">"inet addr"</span> | awk -F[:<span class="string">" "</span>] + <span class="string">'&#123;print $4&#125;'</span></span><br></pre></td></tr></table></figure>
<p>2.ping </p>
<p>使用ICMP协议中的ECHO_REQUEST数据报强制从特定主机返回相应，用于检测网络中某个主机是否活动或发生故障</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 发生<span class="number">5</span>个数据包</span></span><br><span class="line">ping -c <span class="number">5</span> www<span class="number">.163</span>.com</span><br></pre></td></tr></table></figure>
<p>3.netstat</p>
<p>显示网络连接、路由表和网络接口等信息。常用参数：</p>
<ul>
<li>-a: 显示所有套接字状态</li>
<li>-n: 打印实际地址，而不是显示对地址的解释或显示主机网络名之类的符号</li>
<li>-r: 打印路由选择表</li>
</ul>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -an <span class="string">| grep -v unix</span></span><br><span class="line"></span><br><span class="line">netstat -rn</span><br></pre></td></tr></table></figure>
<p>4.traceroute</p>
<p>跟踪网络数据包的路由途径，默认包大小40B。第一条是本机client的网关地址。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">tracerout</span> <span class="tag">www</span><span class="class">.163</span><span class="class">.com</span></span><br></pre></td></tr></table></figure>
<p>5.nslookup / dig</p>
<p>查询机器的IP地址和对应的域名，其中nslookup是基于交互的，dig则直接在参数中附带网址</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">nslookup</span></span><br><span class="line">&gt; <span class="tag">www</span><span class="class">.163</span><span class="class">.com</span></span><br><span class="line">&gt; ...</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; <span class="tag">exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">dig</span> <span class="tag">www</span><span class="class">.163</span><span class="class">.com</span></span><br><span class="line"></span><br><span class="line"># 从根服务器开始追踪域名的解析过程</span><br><span class="line"><span class="tag">dig</span> <span class="tag">www</span><span class="class">.163</span><span class="class">.com</span> + <span class="tag">trace</span></span><br></pre></td></tr></table></figure>
<p>6.finger</p>
<p>查询用户信息，例如用户名、主目录、登录时间等。类似w</p>
<p>7.<code>lsof</code></p>
<p>非常有用的命令，list open files。查看当前系统打开了哪些文件。</p>
<p><code>利用lsof查看打开文件列表，对于系统检测和排错非常有帮助。</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 查看某一个端口被哪些程序占用</span></span><br><span class="line">lsof -i :<span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>8.Sockstat</p>
<p>查看打开的socket情况，只适用于FreeBSD和OpenBSD，CentOS没有此命令</p>
<h3 id="u67E5_u770B_u670D_u52A1_u5668_u8FDB_u7A0B"><a href="#u67E5_u770B_u670D_u52A1_u5668_u8FDB_u7A0B" class="headerlink" title="查看服务器进程"></a>查看服务器进程</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>确定有哪些进程正在运行和运行状态、占用资源等</p>
<p>选项：参见man</p>
<p>常用：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有</span><br><span class="line"><span class="keyword">ps</span> aux</span><br><span class="line"></span><br><span class="line"># 结合<span class="keyword">grep</span>，精确定位需要的进程号</span><br><span class="line"># -<span class="keyword">v</span> ：反向选择，亦即显示出没有 <span class="string">'搜寻字符串'</span> 内容的那一行</span><br><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> -<span class="keyword">v</span> <span class="keyword">grep</span> | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>动态查看进程信息</p>
<p>还可以通过交互命令完成功能：</p>
<ul>
<li>P: 根据CPU使用多少排序</li>
<li>T: 根据时间、累计时间排序</li>
<li>M: 根据使用内存大小排序</li>
<li>q: 退出top命令</li>
<li>m: 切换显示内存信息</li>
<li>t：切换显示进程和CPU状态信息</li>
<li>c: 切换显示命令名称和完整命令行</li>
<li>W: 将当前的设置写入~/.toprc文件，这是写top配置文件的推荐方法</li>
</ul>
<h4 id="pgrep"><a href="#pgrep" class="headerlink" title="pgrep"></a>pgrep</h4><p>查找当前运行的进程Id</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pgrep</span> nginx</span><br></pre></td></tr></table></figure>
<h4 id="kill__u548C_killall"><a href="#kill__u548C_killall" class="headerlink" title="kill 和 killall"></a>kill 和 killall</h4><p>向linux内核发送操作系统信号和某个程序的进程标识号，然后系统内核就可以对进程标识号指定的进程进行kill操作。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 强行终止</span></span><br><span class="line">kill -<span class="number">9</span> [pid]</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 根据名称删除程序下所有进程</span></span><br><span class="line">killall nginx</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>[1] 构建高可用Linux服务器</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ssh_u8FDC_u7A0B_u767B_u5F55"><a href="#ssh_u8FDC_u7A0B_u767B_u5F55" class="headerlink" title="ssh远程登录"></a>ssh远程登录</h3><p>服务器需要开启远程服务</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 针对fedora</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="preprocessor"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="preprocessor"># ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Producer and Consumer]]></title>
    <link href="http://paranoidq.github.io/2015/12/08/java-producer-and-consumer/"/>
    <id>http://paranoidq.github.io/2015/12/08/java-producer-and-consumer/</id>
    <published>2015-12-08T12:34:30.000Z</published>
    <updated>2015-12-17T12:14:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29" class="headerlink" title="生产者消费者模式（以下简称PC)"></a>生产者消费者模式（以下简称PC)</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<code>阻塞队列就相当于一个缓冲区</code>，平衡了生产者和消费者的处理能力。</p>
<a id="more"></a>
<h4 id="u4E3A_u4EC0_u4E48_u4F7F_u7528PC_u6A21_u5F0F"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528PC_u6A21_u5F0F" class="headerlink" title="为什么使用PC模式"></a>为什么使用PC模式</h4><ul>
<li>解耦</li>
<li>缓冲</li>
<li>兼容不同端的处理能力差异</li>
</ul>
<h3 id="Java_u5B9E_u73B0_u65B9_u5F0F"><a href="#Java_u5B9E_u73B0_u65B9_u5F0F" class="headerlink" title="Java实现方式"></a>Java实现方式</h3><h4 id="1-_wait_28_29/nofify_28_29"><a href="#1-_wait_28_29/nofify_28_29" class="headerlink" title="1. wait()/nofify()"></a>1. wait()/nofify()</h4><p>简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingWait</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] items = <span class="keyword">new</span> Object[MAX_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// count total number of items</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(items) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 唤醒之后，可能还会被其他put线程抢占，从而导致full，因此需要用while判断</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">while</span>(count == items.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue is full, please wait for consumer to take"</span>);</span><br><span class="line">                items.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            items.notifyAll(); <span class="comment">// 对比PCQueueUsingLock,这里的实现没有区分full和empty的条件，因此需要notifyAll，否则会导致put之后唤醒的依旧是producer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(items) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 唤醒之后，可能还会被其他take线程抢占，从而导致empty，因此需要用while判断</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue is empty, please wait for producer to put"</span>);</span><br><span class="line">                items.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            items.notifyAll(); <span class="comment">// 同理</span></span><br><span class="line">            <span class="keyword">return</span> (T)x;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 这里亮神提出一个问题：是否需要再finally中使用notifyAll？ —— NO</span><br><span class="line">             * 1. synchronized会自动释放锁（包括异常情况下），除非遇到blocked。yet，blocked这种情况，finally也没有办法啊~~</span><br><span class="line">             * 2. notifyAll之后只会让线程进入到获取锁的等待队列中，还需要等到syn块结束之后，其他线程才能竞争到锁，因此不会出现return之前其他线程就执行的情况</span><br><span class="line">             * 3. 对比：Lock需要手动去释放，因此为了保证异常情况下也能够正常释放，需要通过finally块来unLock</span><br><span class="line">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：(TODO==)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-_ReentrantLock_-_Condition"><a href="#2-_ReentrantLock_-_Condition" class="headerlink" title="2. ReentrantLock - Condition"></a>2. ReentrantLock - Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max capacity for queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[MAX_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// count total number of items</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue full, wait for consumer"</span>);</span><br><span class="line">                notFull.await(); <span class="comment">// condition not met, make the thread to await</span></span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 唤醒所有的线程没有意义，因为最终只有一个能够执行</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// test </span></span><br><span class="line">            System.out.print(<span class="string">"after put: "</span>);</span><br><span class="line">            <span class="keyword">for</span>(Object obj : items) &#123;</span><br><span class="line">                System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// must in finally !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// test</span></span><br><span class="line">                System.out.println(<span class="string">"queue empty, wait for producer"</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            items[takeptr] = <span class="keyword">null</span>; <span class="comment">// set reference to null</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// test </span></span><br><span class="line">            System.out.print(<span class="string">"after take: "</span>);</span><br><span class="line">            <span class="keyword">for</span>(Object obj : items) &#123;</span><br><span class="line">                System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> (T)x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// must use finally !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> round = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        PCQueueUsingLock&lt;Integer&gt; pcQueue = <span class="keyword">new</span> PCQueueUsingLock&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        Thread p = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();  <span class="comment">// wait </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;round; i++) &#123;</span><br><span class="line">                        pcQueue.put(rand.nextInt(<span class="number">10</span>));</span><br><span class="line">                        <span class="comment">//Thread.sleep((long) (3000*Math.random()));</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt(); <span class="comment">// best practice: reset interrupt flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();  <span class="comment">// wait </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;round; i++) &#123;</span><br><span class="line">                        pcQueue.take();</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (<span class="number">3000</span>*Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt(); <span class="comment">// best practice: reset interrupt flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">        </span><br><span class="line">        startGate.countDown();  <span class="comment">// start together</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">queue empty, wait <span class="keyword">for</span> producer</span><br><span class="line">after put: <span class="number">4</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="keyword">null</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="keyword">null</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="keyword">null</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="keyword">null</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h4 id="3-_BlockingQueue"><a href="#3-_BlockingQueue" class="headerlink" title="3. BlockingQueue"></a>3. BlockingQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单封装即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingBlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; items = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(MAX_CAPACITY);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        items.put(x); <span class="comment">// offer() will not block, while put() will block if queue is full.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T x = items.take(); <span class="comment">// poll() will not block, will take() will block if queue is empty.</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedBlockingQueue的put内部实现(采用了ReentrantLock的方式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   <span class="comment">// 空元素判断</span></span><br><span class="line">       <span class="comment">// <span class="doctag">Note:</span> convention in all put/take/etc is to preset local var</span></span><br><span class="line">       <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">       <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">       Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">       <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count; <span class="comment">// 使用atomic的方式计数，保证并发put+take下的count统计正确</span></span><br><span class="line">       putLock.lockInterruptibly(); <span class="comment">// 可以被中断的lock</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/*</span><br><span class="line">            * Note that count is used in wait guard even though it is</span><br><span class="line">            * not protected by lock. This works because count can</span><br><span class="line">            * only decrease at this point (all other puts are shut</span><br><span class="line">            * out by lock), and we (or some other waiting put) are</span><br><span class="line">            * signalled if it ever changes from capacity. Similarly</span><br><span class="line">            * for all other uses of count in other wait guards.</span><br><span class="line">            */</span></span><br><span class="line">           <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">               notFull.await();</span><br><span class="line">           &#125;</span><br><span class="line">           enqueue(node);</span><br><span class="line">           c = count.getAndIncrement();</span><br><span class="line">           <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">               notFull.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>LinkedBlockingQueue的offer内部实现（非阻塞，立刻返回）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">       <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 立刻返回false</span></span><br><span class="line">       <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">       Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">       putLock.lock(); <span class="comment">// 不可中断，why？</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">               enqueue(node);</span><br><span class="line">               c = count.getAndIncrement();</span><br><span class="line">               <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                   notFull.signal();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">       <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-_Semaphore"><a href="#4-_Semaphore" class="headerlink" title="4. Semaphore"></a>4. Semaphore</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; items = <span class="keyword">new</span> ArrayList&lt;Object&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 1. mutex保证存取缓冲区时必须是线程互斥的</span><br><span class="line">     * 2. isFull保证缓冲区最多元素为initPermits，初始值代表缓冲区开始可以存放多少元素</span><br><span class="line">     * 3. isEmpty保证缓冲区为0是阻塞，初始值代表缓冲区开始有多少元素</span><br><span class="line">     * 4. = 也就是isFull和isEmpty的初始化值加起来等于缓冲区的大小</span><br><span class="line">     * </span><br><span class="line">     * 5. 注意不同的semaphore的顺序，否则会出现并发问题</span><br><span class="line">     *      - isFull的信号量可以并发获得</span><br><span class="line">     *      - 但take和put实际操作时，必须只能有一个线程，因此mutex的permit=1</span><br><span class="line">     * </span><br><span class="line">     * 6. 使用semaphore的好处：</span><br><span class="line">     *      - 避免采用wait\notify等底层机制，封装更完善</span><br><span class="line">     *      - 可以避免手动判断缓冲区的当前大小是否满或空，（Condition需要）</span><br><span class="line">     *      - 借助了AQS，似乎效率上得到了优化？？？？</span><br><span class="line">     */</span></span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">// mutex put or take</span></span><br><span class="line">    Semaphore isFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>); <span class="comment">// 缓冲区最多允许10个</span></span><br><span class="line">    Semaphore isEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>); <span class="comment">// 缓冲区初始值为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        isFull.acquire(); <span class="comment">// 大于0,意味着还有permit可以使用，缓冲区未满</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire(); <span class="comment">// acquire = ++</span></span><br><span class="line">            items.add(x);  <span class="comment">// release = --</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            isEmpty.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        Object x = <span class="keyword">null</span>;</span><br><span class="line">        isEmpty.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            <span class="comment">/* 注意List的remove定义：</span><br><span class="line">             * Removes the element at the specified position in this list (optional operation). </span><br><span class="line">             * Shifts any subsequent elements to the left (subtracts one from their indices). </span><br><span class="line">             * Returns the element that was removed from the list.</span><br><span class="line">             */</span></span><br><span class="line">            x = items.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            isFull.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-_LockSupport"><a href="#5-_LockSupport" class="headerlink" title="5. LockSupport"></a>5. LockSupport</h4><p>LockSupport可以通过park(thread)和unpark(thread)，精确地指定阻塞和唤醒线程。但是貌似就欠缺了wait/notify能够让线程在一个object上等待的接口，因此我考虑要实现PC，需要自己维护一个thread的队列才可以。</p>
<h4 id="6-_PipedInputStream_/_PipedOutputStream"><a href="#6-_PipedInputStream_/_PipedOutputStream" class="headerlink" title="6. PipedInputStream / PipedOutputStream"></a>6. PipedInputStream / PipedOutputStream</h4><h3 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要处理任务时间比较长的场景：<ul>
<li>附件上传</li>
<li>远程接口查询数据  </li>
<li>Java线程池</li>
</ul>
</li>
</ul>
<h3 id="u7EBF_u7A0B_u6C60_u4E2D_u5982_u4F55_u5B9E_u73B0PC_u6A21_u5F0F"><a href="#u7EBF_u7A0B_u6C60_u4E2D_u5982_u4F55_u5B9E_u73B0PC_u6A21_u5F0F" class="headerlink" title="线程池中如何实现PC模式"></a>线程池中如何实现PC模式</h3><h3 id="u66F4_u9AD8_u6548_u7684_u8003_u8651"><a href="#u66F4_u9AD8_u6548_u7684_u8003_u8651" class="headerlink" title="更高效的考虑"></a>更高效的考虑</h3><ol>
<li>putLock与takeLock分离（jdk LinkedBlockingQueue中的实现方式）</li>
<li>如果能够直接处理，则直接被consumer取走，不需要再存储到queue中，减少复制的开销</li>
</ol>
<h3 id="u961F_u5217_u7684_u5FAA_u73AF_u6570_u7EC4_u65B9_u5F0F_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5FAA_u73AF_u6570_u7EC4_u65B9_u5F0F_u5B9E_u73B0" class="headerlink" title="队列的循环数组方式实现"></a>队列的循环数组方式实现</h3><h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="external">聊聊并发-生产者消费者模式</a></p>
<p>[2] <a href="http://java--hhf.iteye.com/blog/2064926" target="_blank" rel="external">生产者消费者问题的实现方式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29" class="headerlink" title="生产者消费者模式（以下简称PC)"></a>生产者消费者模式（以下简称PC)</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<code>阻塞队列就相当于一个缓冲区</code>，平衡了生产者和消费者的处理能力。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="producerconsumer" scheme="http://paranoidq.github.io/tags/producerconsumer/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
</feed>
