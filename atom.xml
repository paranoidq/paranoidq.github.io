<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[钱唯の个人博客]]></title>
  <subtitle><![CDATA[佳思忽来，书能下酒；侠情一往，云可赠人。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://paranoidq.github.io/"/>
  <updated>2016-08-01T16:57:57.000Z</updated>
  <id>http://paranoidq.github.io/</id>
  
  <author>
    <name><![CDATA[Paranoid Qian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Linux服务器性能调优常用工具及实例]]></title>
    <link href="http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/"/>
    <id>http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/</id>
    <published>2016-08-01T16:37:17.000Z</published>
    <updated>2016-08-01T16:57:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="u663E_u793A_u6307_u5B9A_u7528_u6237"><a href="#u663E_u793A_u6307_u5B9A_u7528_u6237" class="headerlink" title="显示指定用户"></a>显示指定用户</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ps -u root</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line"><span class="number">7</span> ?        00:<span class="number">00</span>:<span class="number">00</span> events/<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29"><a href="#ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29" class="headerlink" title="ps 与grep 组合使用，查找特定进程 (常用)"></a>ps 与grep 组合使用，查找特定进程 (常用)</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep ssh</span><br><span class="line">root      <span class="number">2720</span>     <span class="number">1</span>  <span class="number">0</span> Nov02 ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="regexp">/usr/</span>sbin/sshd</span><br><span class="line">root     <span class="number">17394</span>  <span class="number">2720</span>  <span class="number">0</span> <span class="number">14</span>:<span class="number">58</span> ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="string">sshd:</span> root<span class="meta">@pts</span>/<span class="number">0</span></span><br><span class="line">root     <span class="number">17465</span> <span class="number">17398</span>  <span class="number">0</span> <span class="number">15</span>:<span class="number">57</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep ssh</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09"><a href="#u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09" class="headerlink" title="列出目前所有的正在内存中的程序 (常用）"></a>列出目前所有的正在内存中的程序 (常用）</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line"><span class="symbol">USER</span>       <span class="symbol">PID</span> <span class="comment">%CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></span><br><span class="line">root         <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">10368</span>   <span class="number">676</span> ?        <span class="symbol">Ss</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> init [<span class="number">3</span>]</span><br><span class="line">root         <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">1</span>]</span><br><span class="line">root         <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>输出含义：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USER：该 <span class="keyword">process</span> 属于那个使用者账号的</span><br><span class="line">PID ：该 <span class="keyword">process</span> 的号码</span><br><span class="line">%CPU：该 <span class="keyword">process</span> 使用掉的 CPU 资源百分比</span><br><span class="line">%MEM：该 <span class="keyword">process</span> 所占用的物理内存百分比</span><br><span class="line">VSZ ：该 <span class="keyword">process</span> 使用掉的虚拟内存量 (Kbytes)</span><br><span class="line">RSS ：该 <span class="keyword">process</span> 占用的固定的内存量 (Kbytes)</span><br><span class="line">TTY ：该 <span class="keyword">process</span> 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/<span class="number">0</span> 等等的，则表示为由网络连接进主机的程序。</span><br><span class="line">STAT：该程序目前的状态，主要的状态有</span><br><span class="line">R ：该程序目前正在运作，或者是可被运作</span><br><span class="line">S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (<span class="keyword">signal</span>) 唤醒。</span><br><span class="line">T ：该程序目前正在侦测或者是停止了</span><br><span class="line">Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</span><br><span class="line">START：该 <span class="keyword">process</span> 被触发启动的时间</span><br><span class="line"><span class="built_in">TIME</span> ：该 <span class="keyword">process</span> 实际使用 CPU 运作的时间</span><br><span class="line">COMMAND：该程序的实际指令</span><br></pre></td></tr></table></figure></p>
<h4 id="ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B"><a href="#ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B" class="headerlink" title="ps -ef与 ps aux的区别"></a>ps -ef与 ps aux的区别</h4><p><code>ps aux</code>最初用到Unix Style中，而<code>ps -ef</code>被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。</p>
<p><code>ps aux</code>中与<code>ps -ef</code>不同的列有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER      <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">%CPU</span>      <span class="comment">//进程占用的CPU百分比</span></span><br><span class="line"><span class="built_in">%MEM</span>      <span class="comment">//占用内存的百分比</span></span><br><span class="line">VSZ       <span class="comment">//该进程使用的虚拟內存量（KB）</span></span><br><span class="line">RSS       <span class="comment">//该进程占用的固定內存量（KB）（驻留中页的数量）</span></span><br><span class="line">STAT      <span class="comment">//进程的状态</span></span><br><span class="line">START     <span class="comment">//该进程被触发启动时间</span></span><br><span class="line">TIME      <span class="comment">//该进程实际使用CPU运行的时间</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>STAT</code>状态为的常见字符有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">D</span>      <span class="comment">//无法中断的休眠状态（通常 IO 的进程）；</span></span><br><span class="line"><span class="keyword">R</span>      <span class="comment">//正在运行可中在队列中可过行的；</span></span><br><span class="line"><span class="keyword">S</span>      <span class="comment">//处于休眠状态；</span></span><br><span class="line">T      <span class="comment">//停止或被追踪；</span></span><br><span class="line"><span class="keyword">W</span>      <span class="comment">//进入内存交换 （从内核2.6开始无效）；</span></span><br><span class="line"><span class="keyword">X</span>      <span class="comment">//死掉的进程 （基本很少见）；</span></span><br><span class="line">Z      <span class="comment">//僵尸进程；</span></span><br><span class="line">&lt;      <span class="comment">//优先级高的进程</span></span><br><span class="line">N      <span class="comment">//优先级较低的进程</span></span><br><span class="line"><span class="keyword">L</span>      <span class="comment">//有些页被锁进内存；</span></span><br><span class="line"><span class="keyword">s</span>      <span class="comment">//进程的领导者（在它之下有子进程）；</span></span><br><span class="line"><span class="keyword">l</span>      <span class="comment">//多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；</span></span><br><span class="line">+      <span class="comment">//位于后台的进程组；</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat"><a href="#u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat" class="headerlink" title="查看端口情况 netstat"></a>查看端口情况 netstat</h3><h4 id="u5217_u51FA_u6240_u6709_u8FDE_u63A5"><a href="#u5217_u51FA_u6240_u6709_u8FDE_u63A5" class="headerlink" title="列出所有连接"></a>列出所有连接</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -a</span><br><span class="line">Active Internet connections (servers <span class="keyword">and</span> established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">enlightened:</span>domain      *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ipp           *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">54750</span> li24<span class="number">0</span>-<span class="number">5</span>.members.<span class="symbol">li:</span>http ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">49980</span> del01s07-<span class="keyword">in</span>-f14.<span class="number">1</span><span class="symbol">:https</span> ESTABLISHED</span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ip6-<span class="symbol">localhost:</span>ipp       [<span class="symbol">:</span><span class="symbol">:</span>]<span class="symbol">:*</span>                  LISTEN </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t"><a href="#u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t" class="headerlink" title="列出tcp/udp连接 <code>-u</code>和<code>-t</code>"></a>列出tcp/udp连接 <code>-u</code>和<code>-t</code></h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -at</span><br><span class="line"><span class="variable">$ </span>netstat -au</span><br></pre></td></tr></table></figure>
<h4 id="u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n"><a href="#u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n" class="headerlink" title="禁用反向域名解析，加快查询速度 <code>-n</code>"></a>禁用反向域名解析，加快查询速度 <code>-n</code></h4><p>没有必要知道主机名，就使用 -n 选项禁用域名解析功能<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -ant</span><br></pre></td></tr></table></figure></p>
<h4 id="u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l"><a href="#u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l" class="headerlink" title="只列出监听中的端口 <code>-l</code>"></a>只列出监听中的端口 <code>-l</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tnl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN</span><br></pre></td></tr></table></figure>
<p>不要使用<code>-a</code>，否则linux会列出所有端口，而不只是监听（LISTEN）端口</p>
<h4 id="u53EA_u5217_u51FAactive_u7AEF_u53E3"><a href="#u53EA_u5217_u51FAactive_u7AEF_u53E3" class="headerlink" title="只列出active端口"></a>只列出active端口</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -atnp | grep ESTA</span><br><span class="line">(<span class="keyword">Not</span> all processes could be identified, non-owned process info</span><br><span class="line"> will <span class="keyword">not</span> be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">49156</span>       <span class="number">173.255</span><span class="meta">.230</span><span class="meta">.5</span>:<span class="number">80</span>        ESTABLISHED <span class="number">1691</span>/chrome     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">33324</span>       <span class="number">173.194</span><span class="meta">.36</span><span class="meta">.117</span>:<span class="number">443</span>      ESTABLISHED <span class="number">1691</span>/chrome</span><br></pre></td></tr></table></figure>
<p>active 状态的套接字连接用 “ESTABLISHED” 字段表示</p>
<h4 id="u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p"><a href="#u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p" class="headerlink" title="列出进程名，进程号和用户ID <code>-p</code>"></a>列出进程名，进程号和用户ID <code>-p</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo netstat -nlpt</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">1144</span>/dnsmasq    </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">661</span>/cupsd       </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN      <span class="number">661</span>/cupsd</span><br></pre></td></tr></table></figure>
<p>必须要root权限才能显示！如果没有root需要查看端口对应的进程，请参考<code>lsof</code><br><code>-ep</code>选项可以同时查看进程名和用户名</p>
<h4 id="u5B9E_u6218"><a href="#u5B9E_u6218" class="headerlink" title="实战"></a>实战</h4><ol>
<li><p>查看服务是否运行</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo netstat -aple | grep ntp</span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span>ntp   *<span class="symbol">:*</span>     root       <span class="number">17430</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ntp           *<span class="symbol">:*</span>     root       <span class="number">17429</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:ntp</span>                   *<span class="symbol">:*</span>     root       <span class="number">17422</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp6       <span class="number">0</span>      <span class="number">0</span> <span class="symbol">fe80:</span><span class="symbol">:</span><span class="number">216</span><span class="symbol">:</span><span class="number">36</span><span class="symbol">ff:</span><span class="symbol">fef8:</span>ntp [<span class="symbol">:</span><span class="symbol">:</span>]    root       <span class="number">17432</span>       <span class="number">1789</span>/ntpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看端口号的占用情况</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an <span class="string">| grep 12000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结合<code>watch</code>监控active状态的连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch <span class="_">-d</span> -n0 <span class="string">"netstat -atnp | grep ESTA"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="u9644_uFF1Awatch_u547D_u4EE4"><a href="#u9644_uFF1Awatch_u547D_u4EE4" class="headerlink" title="附：watch命令"></a>附：watch命令</h4><p>watch可以帮助使用者监测一个命令的运行结果，避免重复手动运行。watch命令会周期执行<br>参数：</p>
<ul>
<li>-n 时间间隔，缺省值为2s</li>
<li>-d 高亮显示变化区域</li>
<li>-t 关闭watch命令在顶部的时间间隔</li>
</ul>
<p>实例：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每隔一秒高亮显示http链接数的变化情况</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">1</span> -d <span class="string">'pstree|grep http'</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>秒一次输出系统的平均负载</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">10</span> <span class="string">'cat /proc/loadavg'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B"><a href="#u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B" class="headerlink" title="查看使用CPU\MEM最多的进程"></a>查看使用CPU\MEM最多的进程</h3><h3 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="external">ps</a><br><a href="https://linux.cn/article-2434-1.html" target="_blank" rel="external">netstat</a><br><a href="http://www.cnblogs.com/peida/archive/2012/12/31/2840241.html" target="_blank" rel="external">watch</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BASE64换行符的坑]]></title>
    <link href="http://paranoidq.github.io/2016/08/01/base64-newline-trap/"/>
    <id>http://paranoidq.github.io/2016/08/01/base64-newline-trap/</id>
    <published>2016-08-01T13:29:38.000Z</published>
    <updated>2016-08-01T15:08:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>
<a id="more"></a>
<h3 id="u95EE_u9898_u7684_u5206_u6790"><a href="#u95EE_u9898_u7684_u5206_u6790" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>问题在于为什么发送方的报文会多出来<code>/r/n</code>呢？</p>
<h4 id="Step_1"><a href="#Step_1" class="headerlink" title="Step 1"></a>Step 1</h4><p>首先看回车和换行符的区别：</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>     于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>      后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“ &lt;回车&gt;&lt;换 行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打 开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p>
</blockquote>
<p>所以导致的问题应该就是client端是windows系统，而我们这边处理的系统在linux下，因此就会有<code>/r/n</code>的问题。</p>
<h4 id="Step_2"><a href="#Step_2" class="headerlink" title="Step 2"></a>Step 2</h4><p>OK，让对方去掉报文中的换行之后，问题还是存在。而且还有新的发现：</p>
<blockquote>
<p>BASE64之后，当字符串过长（一般超过76）时会自动在中间加一个换行符。及时我们自己测试的报文完全没有任何换行存在。</p>
</blockquote>
<p>于是想办法去研究<code>sun.misc.BASE64Encoder</code>的源码，有了一些发现。</p>
<p>BASE64主要调用的方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"abcd"</span>.getBytes();</span><br><span class="line">BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">encoder.encodeBuffer(bytes);</span><br></pre></td></tr></table></figure></p>
<p>encodeBuffer源码的大致情况：(大部分源码位于<code>BASE64Encoder</code>的父类<code>CharacterEncoder</code>中)<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> encodeBuffer(<span class="built_in">byte</span> aBuffer[]) &#123;</span><br><span class="line">    ByteArrayOutputStream   outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ByteArrayInputStream    inStream = <span class="keyword">new</span> ByteArrayInputStream(aBuffer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        encodeBuffer(inStream, outStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception IOException) &#123;</span><br><span class="line">        <span class="comment">// This should never happen.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"CharacterEncoder.encodeBuffer internal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (outStream.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode bytes from the input stream, and write them as text characters</span><br><span class="line"> * to the output stream. This method will run until it exhausts the</span><br><span class="line"> * input stream, but does not print the line suffix for a final</span><br><span class="line"> * line that is shorter than bytesPerLine().</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> encode(InputStream inStream, OutputStream outStream)</span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">int</span>     j;</span><br><span class="line">    <span class="built_in">int</span>     numBytes;</span><br><span class="line">    <span class="built_in">byte</span>    tmpbuffer[] = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesPerLine()];</span><br><span class="line"></span><br><span class="line">    encodeBufferPrefix(outStream); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        numBytes = readFully(inStream, tmpbuffer);</span><br><span class="line">        <span class="keyword">if</span> (numBytes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeLinePrefix(outStream, numBytes); </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numBytes; j += bytesPerAtom()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((j + bytesPerAtom()) &lt;= numBytes) &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, bytesPerAtom());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, (numBytes)- j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numBytes &lt; bytesPerLine()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encodeLineSuffix(outStream); <span class="comment">// 这一行会输出换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    encodeBufferSuffix(outStream); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode the suffix that ends every output line. By default</span><br><span class="line"> * this method just prints a &lt;newline&gt; into the output stream.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> encodeLineSuffix(OutputStream aStream) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    pStream.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>encodeLineSuffix</code>会输出换行。也就是每次读满一个buffer大小的时候，都会输出一个换行。buffer的大小是由<code>bytesPerLine()</code>函数决定的，该函数是一个抽象函数，由子类实现。而在BASE64Encoder中，该函数的返回值为57.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * this class encodes 57 bytes per line. This results in a maximum</span><br><span class="line"> * of 57/3 * 4 or 76 characters per output line. Not counting the</span><br><span class="line"> * line termination.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bytesPerLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://stackoverflow.com/questions/9341047/carriage-return-issue-decoding-base64-from-java-and-sending-to-browser" target="_blank" rel="external">StackOverflow上有回答</a>这是做了一种<code>chunking</code>，在每一个<code>chunk</code>后面添加了<code>/n</code>。并且sun的库函数只存在于oracle的jvm下面，而不存在于其他jvm中。</p>
<h3 id="Step_3"><a href="#Step_3" class="headerlink" title="Step 3"></a>Step 3</h3><p><code>encode</code>与<code>encodeBuffer</code>有细微的区别：<code>encodeBuffer</code>会在最后一行不足<code>bytesPerline()</code>时添加一个换行符，而encode则不会做处理。</p>
<p>貌似很坑爹，做了如此多的隐含处理，让调用者想死的心都有了。</p>
<h3 id="u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5"><a href="#u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5" class="headerlink" title="一劳永逸的办法"></a>一劳永逸的办法</h3><p>建议使用<code>org.apache.commons.codec.binary.Base64</code>库：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base<span class="number">64.</span>e<span class="symbol">ncodeBase64</span><span class="comment">(..)</span>;</span><br><span class="line">Base<span class="number">64.</span>decodeBase<span class="number">64</span><span class="comment">(..)</span></span><br></pre></td></tr></table></figure></p>
<p>并且该库显示指明了，你是否需要<code>chunk</code>选项和<code>urlsafe</code>选项（避免输出<code>+</code>和<code>/</code>，而是输出<code>-</code>和<code>_</code>）：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeBase64Chunked(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData)</span><br><span class="line">encodeBase64(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData, <span class="keyword">final</span> <span class="keyword">boolean</span> isChunked)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="base64" scheme="http://paranoidq.github.io/tags/base64/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人已经破产，靠还没倒闭的行业活着（转载）]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/%E4%B8%AA%E4%BA%BA%E5%B7%B2%E7%BB%8F%E7%A0%B4%E4%BA%A7/"/>
    <id>http://paranoidq.github.io/2016/07/25/个人已经破产/</id>
    <published>2016-07-25T13:14:31.000Z</published>
    <updated>2016-07-25T13:24:20.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd" target="_blank" rel="external">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>
<a id="more"></a>
<h3 id="u4E8C"><a href="#u4E8C" class="headerlink" title="二"></a>二</h3><p>想起当年电视台如日中天炙手可热的时候，我领教过的一个台里员工。那位负责灯光的人被称为“灯爷”，对别人永远是颐指气使的口吻，对自己永远觉得含着天大的委屈，找他做最简单的事情都得陪着笑脸，而他做最分内的事情都觉得是别人在给他添麻烦。</p>
<p>更可怕的是，我们都对这样的大爷习以为常。他老人家稍微嘴脸好看点儿，手脚勤快点儿，便觉得是恩赐。</p>
<p>直到后来见识了一位香港“灯爷”：永远不用你操心、催促，在规定的时间内到位，黑着脸不许别人碰他的器材，手脚麻利地快速解决一切事情，工作成效之高、之专业，几乎都让你意识不到他的存在。</p>
<p>再看我们这位爷，遇到潜在的金主，想给自己捞点野活挣点外快，就倨傲又殷勤地给人家递名片：我是中央台的。</p>
<p>那时的我年轻气盛，看到这一幕，鄙夷地想：把你名片上“中央电视台”那几个字划掉，你什么也不是。</p>
<h3 id="u4E09"><a href="#u4E09" class="headerlink" title="三"></a>三</h3><p>这些年，中国房地产行业空前繁荣。建筑师这个职业，应该是机会大大的，挣钱多多的，心里美美的吧。</p>
<p>一位建筑界的老师却对我说，高歌猛进的房地产行业，还有那些地标式的公共建筑，不仅对城市、对环境造成破坏，对公众审美形成摧残，还把一代建筑师给毁了。</p>
<p>我吃惊地问为什么。他的要点是：因为活儿太多，素质不高的设计师也可以有干不完的单子应接不暇；因为钱太好挣，许多建筑师没有了自我提高的主动与自觉；因为工程太赶，缺乏原创、智慧含量和时间成本越少的设计成为首选，行业的水准线便越来越低。</p>
<p>一位做建筑图书的出版业同行，准备引进一套欧洲建筑丛书，全套有二三百本，囊括了当代建筑的各位大师，全面呈现其作品和建筑理念。我想当然地认为这套书会很好卖，因为它本来口碑就好，建筑装饰类图书又永远在书店里占据相当比重，中国的建筑设计行业人多，钱多，需求又大。</p>
<p>她说给我的发行量却低得惊人。这套书只引进了十几种，原来宏伟的出版计划看来会中途夭折。</p>
<p>她的观点也是：大家的学习动力没有了，因为钱太容易挣。一个建筑师不用看这些书，照样有挣不完的钱。</p>
<p>一个行业的繁荣，对个人来说是好事还是坏事？</p>
<h3 id="u56DB"><a href="#u56DB" class="headerlink" title="四"></a>四</h3><p>我们去年签下一套英文书的版权，写人类伟大的历史文化遗迹。因为它和建筑有很大关系，所以我想邀请建筑界的专家——外语又好、又懂建筑的人来翻译。</p>
<p>找到一位人脉广的老师求助，他说，你可能在建筑界找不到人。没人愿意接你的活儿。你看，能够胜任翻译的人，得是具备一定能力和资历的人。一本书的翻译至少要几个月的时间，稿费最多几万块钱，可人家用几个晚上时间画建筑图纸，就能挣几万块。</p>
<p>我说，这不正好吗？用几天时间画图，把几万块钱挣出来，那不就没有后顾之忧，更能踏踏实实、专心致志搞翻译了吗？</p>
<p>你这个逻辑太自作多情了，也把你的书看得太重要了。人家想的是，花几个月时间来翻译你这本书的话，就意味着耽误了画多少图、失去了挣多少钱的机会。并且这种活儿都还排着队等他来接呢，谁还稀罕为你翻译，谁算不明白这笔账呢？</p>
<p>一个人都温饱无忧了，何必还为挣钱，把自己搞得连翻译一本书这么有乐趣的事都不做呢？我兀自不甘心地咕哝。</p>
<p>有了小房子还要改善性住宅，有了大房子还要弄别墅。永远挣不完的钱，永远画不完的图。大家的时间，都用来赶这些行活了。</p>
<p>好吧，我之蜜糖，彼之砒霜。</p>
<h3 id="u4E94"><a href="#u4E94" class="headerlink" title="五"></a>五</h3><p>改革开放三十多年，破产的公司、机构不计其数，但中国几百家出版社，好像自始至终没有一家倒闭的。</p>
<p>行业的繁荣或依赖政策形成的稳定，会给一些鱼龙混杂、蜂拥而入的从业人员造成错觉，相信自己可以高枕无忧不思进取，甚至以为自己“亦有贡献”。可在危机来临之前，一个人的能力储备、职业素养、知识更新、自我成长，会自觉地被激发、强调出来么？</p>
<p>写到这里，我突然有一种担心：这些永不倒闭的出版社，已经把一些编辑养残，自我破产了。</p>
<p>我们有没有勇气和清醒，独立于外部环境和行业冷暖，明白自己要做些什么？</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="社会" scheme="http://paranoidq.github.io/categories/%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的书单]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/just-reading/"/>
    <id>http://paranoidq.github.io/2016/07/25/just-reading/</id>
    <published>2016-07-24T16:14:07.000Z</published>
    <updated>2016-07-24T16:26:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/" target="_blank" rel="external">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/" target="_blank" rel="external">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/" target="_blank" rel="external">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/" target="_blank" rel="external">创业维艰</a></p>
<a id="more"></a>
<h3 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h3><p><a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">浪潮之巅</a> (完成)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/">创业维艰</a></p>]]>
    
    </summary>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生新阶段随笔（1）]]></title>
    <link href="http://paranoidq.github.io/2016/07/15/%E4%BA%BA%E7%94%9F%E6%96%B0%E9%98%B6%E6%AE%B5%E9%9A%8F%E7%AC%94-1/"/>
    <id>http://paranoidq.github.io/2016/07/15/人生新阶段随笔-1/</id>
    <published>2016-07-15T12:02:53.000Z</published>
    <updated>2016-07-15T12:45:30.000Z</updated>
    <content type="html"><![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>
<a id="more"></a>
<p>说道知识和技能，这个其实是我不太满意的地方。虽说之前可能也有心理准备，但是进入到公司才发现，国企确实在技术上的发展不够好，或者说不够有技术的激情。当然，已经工作多年的前辈肯定是比我懂得多，但总感觉整个技术开发中心的氛围不够好，这点可能真的无法跟互联网公司相比。不过，其实互联网公司的技术其实也就集中于几个核心的部门，其他大部分也都是完成业务而已。这点上，在EMC这样的外企实习过的同事其实还蛮有发言权的。因此，<strong>公司可能只是一个平台，更多的还是要考自己去主动地学习和探索。问题其实天天都会有，就看你愿不愿意花时间去学了</strong>。</p>
<p>工作的同事其实还是蛮nice的，大家人都非常随和，没有传统国企那种等级森严的感觉。虽然有些师兄已经工作了近十年了，但是还是可以跟我们聊得很好。当然，我之前定下的目标就是要努力处理好自己的人事关系，目前看来还算不错，基本上跟组里的同事相处的很好，能够主动跟他们交流。搁过去的话，我估计还不会有这样的表现，所以算是步入社会之后强迫自己的一种改变吧。能够跟各种人正常的交往也算是一种极为重要的生活技能。</p>
<p>目前组里做的东西说白了就是适配，适配各种行业和机构的接口。本质上，这东西其实还是有一定技术含量的，不过就我目前研究的线上系统WCG的源码来看，写的确实不怎么样，感觉连我这个在校生都不如，各种magic number随便乱写，配置也随便乱写，系统模块和类设计不合理的地方很多。所以目前我的想法是能够重构这个系统，感觉如果能够进行下去的话，应该是一次难得的学习机会，毕竟无论是个人技术成长还是将来跳槽，这都是一个有利的加分项。而<strong>难点在于，如何设计一个好的系统架构，并且考虑到测试成本的问题，系统重构的过程需要尽量的step-by-step，类似于持续集成吧</strong>。这方面，在没有人带我的情况下，感觉是最困难的地方了。架构的问题，可能需要我上网查阅很多资料，如果能够有人请教的话就最好了。而关于重构成本的问题，这估计也是领导最为关心的问题，所以我接下来要做的工作应该是<strong>证明系统重构能够带来很大的好处，并且尽量减小重构对于目前运行的功能的稳定性影响</strong>。</p>
<p>跳槽的问题其实也是这两周困扰我的问题之一，虽然目前还算适应现在的工作环境，但是跳槽可能还是在我的计划中，毕竟我向往更加富有技术激情和技术发展空间的平台。因此，每天晚上我都会固定时间学习，但是总感觉时间不够用。觉得可能是效率不够高。反思一下，应该是学习的东西太过零散，然后每次看到比较复杂的东西，总是想往后拖，然后就不了了之了。所以，后续的改进方向应该是: <strong>大概每周确定一个学习的目标，围绕着这个主线学习。然后抽出一部分时间，解决工作中遇到的问题，每次解决一个问题的时候，就尽量深入弄懂，不要一知半解地结束。这样每接触到一个知识，就能解决一个了。然后每周的主线应该围绕将来自己想深入的方向去学习探索，主要的手段是看书+看系列博客+写demo相结合的方式。</strong><br>其实，做site project是个不错的选择，但是缺的是idea。比较好的方案是，写一些算法相关的project或者小游戏，这些花费的时间不多，并且应该能有一些帮助。这个后续需要再思考思考！！！毕竟，<strong>项目经验在未来的跳槽中估计有着很重要的作用，这点需要时刻提醒自己注意一下</strong>！！！</p>
<p>生活上，发现自己基本上没什么娱乐时间了，感觉回来学习一会儿，运动一会洗个澡，再视频半小时就睡觉了。唉，发现到了工作中真的是时间不够用了。之前计划好的，学日语、学上海话还有看电影写影评之类的通通没时间完成，估计应该调整一下思路，这些东西应该放到周末休息时间去做。这样比较合理。</p>
<p>另外就是去苏州看了一下房子，海胥澜庭地段确实好，也是个三学区的房子。不过价格超贵，感觉还是有点承受不起。前几日，考虑到我跳槽不一定能跳到苏州的问题，觉得可能园区还是比较适合。以来跳槽之后在园区的可能性比较大，上班方便；而来，如果不能跳，将来工作重新找到浦西的话，去上海上班还是比较方便的。而且园区房价的抗跌性还是很好的。如果想去杭州的话，房子卖了应该不成问题。另一个考虑就是学区房的问题，这个需要调查一下，到底学区房需要提前几年买的问题。目前我的估计是5年之内我应该用不上学区房了。所以可以不考虑学区房的问题暂时。目前是这样打算的。</p>
<p>恩，总结到这里，最后摘一句话自勉：<br>—— <em>其实学习是个慢功夫，讲究节奏，就像认真的模仿，看上去很慢很循规蹈矩，但一步步走下来，确是成长最快的途径。这在我们这个事事都追求效率的时代，显得弥足珍贵</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://paranoidq.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://paranoidq.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java局部类不能访问外围的非final局部变量的探索]]></title>
    <link href="http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/"/>
    <id>http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/</id>
    <published>2016-07-04T13:04:47.000Z</published>
    <updated>2016-07-15T12:43:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>
<a id="more"></a>
<p>为了清晰，首先用例子探索一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by paranoidq on 16/7/4.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        String str = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">        Date[] dates = <span class="keyword">new</span> Date[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dates.length; i++) &#123;</span><br><span class="line">            dates[i] = <span class="keyword">new</span> Date() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span> </span>&#123;</span><br><span class="line">                    System.out.println(counter);    <span class="comment">// case1: int不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(counter++);  <span class="comment">// case2: int修改 -&gt; compiler error</span></span><br><span class="line">                    System.out.println(str);        <span class="comment">// case3: string不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(str + <span class="string">"t"</span>);  <span class="comment">// case4: string为不可变对象 -&gt; 通过</span></span><br><span class="line"></span><br><span class="line">                    str = <span class="string">"aaa"</span>;</span><br><span class="line">                    System.out.println(str);        <span class="comment">// case5: 修改了string -&gt; 不通过</span></span><br><span class="line">                    <span class="comment">// Error:</span></span><br><span class="line">                    <span class="comment">// Variable str is accessed from within inner class,</span></span><br><span class="line">                    <span class="comment">// need to be final or effectively final</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.compareTo(anotherDate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>我们发现，其实编译器足够智能，对于case1和case3而言，虽然访问了非final局部变量，但是还是通过编译了，而只有在case2、case5中修改了局部变量时，才报错。而对于case4而言，涉及到string对象不可变的另一个知识点，这里略过。</p>
<p>分析报错的提示，可以知道，实际上对于局部类访问外部变量的规则，相对比较宽松，只要是<code>final or effectively final</code>即可，所谓<code>effectively final</code>其实也就是在局部类内没有做出实质性的修改动作，这一类情况编译器也是让过的。</p>
<h3 id="u539F_u56E0"><a href="#u539F_u56E0" class="headerlink" title="原因"></a>原因</h3><p>为什么在局部类内不能访问外部的非final局部变量呢？参考<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="external">这个帖子</a>，写的很到位。引用如下</p>
<p>这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;  </span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome();  </span><br><span class="line">  some.dosome();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是:</p>
<pre><code>class Outer$Dosome{  
    public Dosome(final String a,final int b){  
        this.Dosome$a=a;  
        this.Dosome$b=b;  
    }  
    public void dosome(){  
        System.out.println(this.Dosome$a+this.Dosome$b);  
    }  
}
</code></pre><p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。  </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>内部类的原理分析：<a href="http://android.blog.51cto.com/268543/384809" target="_blank" rel="external">http://android.blog.51cto.com/268543/384809</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="inner-class" scheme="http://paranoidq.github.io/tags/inner-class/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java动态代理与CgLib对比]]></title>
    <link href="http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/"/>
    <id>http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/</id>
    <published>2016-06-08T07:48:27.000Z</published>
    <updated>2016-06-08T03:59:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>
<a id="more"></a>
<h3 id="JDK_u52A8_u6001_u4EE3_u7406"><a href="#JDK_u52A8_u6001_u4EE3_u7406" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real object."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Jdk 动态代理必须代理接口,不能代理正常的类.</span><br><span class="line"> *</span><br><span class="line"> * 创建速度快于Cgi,但是运行速度大约比Cgi慢10倍.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> proxy The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.</span><br><span class="line">     *              Most often you don't need this object.</span><br><span class="line">     * <span class="doctag">@param</span> method</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     * <span class="doctag">@throws</span> Throwable</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">        System.out.println(<span class="string">"method: "</span> + method);</span><br><span class="line">        System.out.println(<span class="string">"args: "</span> + args);</span><br><span class="line">        <span class="keyword">if</span> (method.getName().contains(<span class="string">"do"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method contains do*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = proxy.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      equals</span><br><span class="line">         *      toString</span><br><span class="line">         *      hashCode</span><br><span class="line">         *      doSomething !!!</span><br><span class="line">         */</span></span><br><span class="line">        Class[] interfaces = proxy.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">            System.out.println(c);  <span class="comment">// interface me.util.proxy.jdkproxy.Subject</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      interface me.util.proxy.jdkproxy.Subject</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args); <span class="comment">// 在实际对象上invoke方法,同时传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxy = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                Subject.class.getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> JdkProxy(subject));</span><br><span class="line"></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"======="</span>);</span><br><span class="line">        System.out.println(proxy); <span class="comment">// toString的调用同样会dispatch到invoke,因此会被也"包装"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u603B_u7ED3_u51E0_u70B9_uFF1A"><a href="#u603B_u7ED3_u51E0_u70B9_uFF1A" class="headerlink" title="总结几点："></a>总结几点：</h4><ol>
<li>只能代理接口，不能代理类（原因在与newProxyInstane参数中需要被代理类的接口数组）。如果将newProxyInstance返回的Object转为RealSubject，则报异常：<code>java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to me.util.proxy.jdkproxy.RealSubject</code></li>
<li><code>java.lang.Object</code>的方法<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>也会被代理类拦截。（原因在代码最后的<code>toString(proxy)</code>也触发了代理类的输出）</li>
<li>代理实例本身会被传递给invoke，作为第一个参数，即proxy。可以通过这个获取代理实例及其类型信息（代码中，我们获得了代理实例实际上有doSomething()这个方法，因为代理实例也继承了接口Subject！<strong>所以说为什么要传入classloader，因为实际上是Java在用bytecode生成一个实现了Subject接口的动态代理类啊！这不就是隐式地在用反射构建一个类么？</strong>）</li>
</ol>
<p>JDK动态代理类的字节码是由Java在运行时通过反射动态生成的。</p>
<p>上面的例子基本已经显示了JDK代理的重要特性，下面整理说明一些重点：（主要参考Oracle JavaDoc）</p>
<ol>
<li>invoke()的返回值会传递给代理实例，从而返回给客户端，因此客户端的代理实例声明的返回值类型要注意匹配。</li>
<li></li>
<li>invoke代理的函数的参数列表以数组形式给出，对基本类型做了默认的boxing。另外，注意，在invoke内部可以任意修改这个参数数组，这里Java没有约束。（当然，一般来说修改函数的参数是很危险的，尤其还是这种经过代理的调用，会让调用方完全不知情！）</li>
</ol>
<h3 id="CGLib_u52A8_u6001_u4EE3_u7406"><a href="#CGLib_u52A8_u6001_u4EE3_u7406" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * cgi代理可以代理任何类,采用的方式是创建类的子类,然后在子类中调用父类的方法,并织入aop的逻辑</span><br><span class="line"> *</span><br><span class="line"> * 创建慢,但运行性能快于jdk.</span><br><span class="line"> * 适用于对象创建少,长期使用的情况,如singleton.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CgLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);  <span class="comment">// 设置被代理类, CgLib根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before method"</span>);</span><br><span class="line">        <span class="comment">// invoke()会造成循环调用, 因为调用的还是子类对象的方法, 而子类对象的方法还是会被拦截.</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After method"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CgLibProxy proxyHandler = <span class="keyword">new</span> CgLibProxy();</span><br><span class="line">        <span class="comment">// proxy normal class: RealSubject</span></span><br><span class="line">        RealSubject proxy = (RealSubject) proxyHandler.getProxy(RealSubject.class);</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类</li>
<li>可以代理没有接口的类(JDK动态代理则不行)</li>
<li>通过字节码技术为被代理的类创建子类，并在子类中采用方法<code>intercept</code>拦截所有父类方法的调用</li>
<li>显然，基于第三点，CGlib不能代理final类</li>
<li>pom包: cglib + asm (底层依赖于asm)</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="external">Java Doc</a><br><a href="http://blog.csdn.net/janice0529/article/details/42884019" target="_blank" rel="external">http://blog.csdn.net/janice0529/article/details/42884019</a><br><a href="http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html</a><br><a href="http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/" target="_blank" rel="external">http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="proxy" scheme="http://paranoidq.github.io/tags/proxy/"/>
    
      <category term="cglib" scheme="http://paranoidq.github.io/tags/cglib/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node.js安装express框架时出现command not found问题]]></title>
    <link href="http://paranoidq.github.io/2016/06/07/nodejs-express-install/"/>
    <id>http://paranoidq.github.io/2016/06/07/nodejs-express-install/</id>
    <published>2016-06-07T12:23:45.000Z</published>
    <updated>2016-06-07T12:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br><a id="more"></a></p>
<p>安装时在文件夹下输入：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express</span><br></pre></td></tr></table></figure></p>
<p>但是无法使用express命令，出现<code>express: command not found</code>。原因在于在express4.0中，cli需要单独安装才能使用，cli功能被包含在<code>express-generator</code> package中。</p>
<p>因此需要如下操作：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express-generator</span><br></pre></td></tr></table></figure></p>
<p>参考: <a href="http://stackoverflow.com/questions/23002448/express-command-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/23002448/express-command-not-found</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://paranoidq.github.io/tags/express/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyenv神器]]></title>
    <link href="http://paranoidq.github.io/2016/06/04/pyenv%E7%A5%9E%E5%99%A8/"/>
    <id>http://paranoidq.github.io/2016/06/04/pyenv神器/</id>
    <published>2016-06-04T09:23:24.000Z</published>
    <updated>2016-06-07T12:09:46.000Z</updated>
    <content type="html"><![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u8BBE_u7F6E_u56FD_u5185_u955C_u50CF"><a href="#u8BBE_u7F6E_u56FD_u5185_u955C_u50CF" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mirrors</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_BUILD_MIRROR_URL=<span class="string">"http://pyenv.qiniudn.com/pythons/"</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">version</span><span class="comment"> // 正在使用的版本</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="comment">--list</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv uninstall <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 全局设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">global</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 本地目录设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="keyword">system</span> <span class="comment"> // 直接使用系统自带版本</span></span><br></pre></td></tr></table></figure>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ol>
<li>如何删除已经安装的python版本: <a href="http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di" target="_blank" rel="external">http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di</a></li>
<li>一般而言，系统库放/System/Library，而应用程序依赖的放/Library，所以，苹果自带的python放在前者，而用户自己装的python（比如官方网站下载的）会自动装在后者。（homebrew安装的就在后者）</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">https://github.com/yyuu/pyenv</a><br><a href="http://v2in.com/pyenv-installation-and-usage.html" target="_blank" rel="external">http://v2in.com/pyenv-installation-and-usage.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="http://paranoidq.github.io/tags/pyenv/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 分支管理与实践（hexo博客源文件管理）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Git-branch-management/"/>
    <id>http://paranoidq.github.io/2016/05/27/Git-branch-management/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br><code>git branch -a</code></p>
<p>查看本地分支和远程分支的push情况<br><code>git log &lt;local-branch&gt; ^origin/&lt;remote-branch&gt;</code>   # 可以查看本地有远程没有的提交。<br><code>git log &lt;remote-branch&gt; ^&lt;local-branch&gt;</code>       # 可以查看远程有本地没有的提交。</p>
<h3 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h3><p>创建本地分支<br><code>git checkout -b dev</code></p>
<h3 id="u5173_u8054"><a href="#u5173_u8054" class="headerlink" title="关联"></a>关联</h3><p>目的：避免每次都需要制定push的具体分支，可以关联后在本地分支下直接push即可</p>
<p>两种方案：</p>
<ol>
<li>在本地branch第一次push的时候就指定：<br> <code>git push -u origin &lt;remote-branch&gt;</code></li>
<li>以后指定：<br><code>git branch --set-upstream &lt;local-branch&gt; origin/&lt;remote-branch&gt;</code><br>或<br><code>git push --set-upstream origin &lt;remote-branch&gt;</code><br>你的repo下的git/config会多出类似这样的配置：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[branch "src"]</span></span><br><span class="line"><span class="attr">remote</span> = origin</span><br><span class="line"><span class="attr">merge</span> = refs/heads/src</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u63A8_u9001"><a href="#u63A8_u9001" class="headerlink" title="推送"></a>推送</h3><p><code>git push origin &lt;local-branch&gt;</code>  # 推送本地分支到对应的远程分支</p>
<p><code>git push</code> # 如果指定了远程关联，可以直接push</p>
<p>两种配置： (注意，这个配置是写在~/.gitconfig中的，对所有的repo生效)<br><code>git config --global push.default simple</code>(更好, 只push当前分支到你使用git pull拉取的远程代码)<br><code>git config --global push.default matching</code> （如果没有指定具体分支，会push所有名字对应的分支）</p>
<h3 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h3><p>删除本地分支<br><code>git branch -d dev (用-D强行删除)</code></p>
<p>删除远程分支<br><code>git push origin --delete dev</code></p>
<h3 id="u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F"><a href="#u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F" class="headerlink" title="实例： 管理hexo的src分支"></a>实例： 管理hexo的src分支</h3><p>说明：hexo的deployer本身在部署的时候只会生成static文件，并上传到github的master分支，而hexo的一些source和_config.yaml等配置文件则只在本地。因此需要将这些文件也管理到git中去，方便备份和多终端同步。</p>
<p>基本思路是在本地利用src分支，然后上传源文件到src分支，并push到远程的src分支，即可管理。</p>
<p>master分支由于是hexo的页面展示部分，所以其实是不能与origin/master保持同步的，也千万不能push，否则结果就是源文件覆盖了hexo-deployer push到master分支的静态文件，从而访问的时候404了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd &lt;repo&gt;</span><br><span class="line"><span class="variable">$ </span>git init (optional)</span><br><span class="line"><span class="variable">$ </span>git checkout -b src</span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"first commit for src branch"</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>&lt;username&gt;<span class="symbol">:&lt;username&gt;</span>.github.io.git (optional)</span><br><span class="line"><span class="variable">$ </span>git push origin src</span><br></pre></td></tr></table></figure>
<ol>
<li>optional部分，可能由于之前开始建立repo的时候已经做过了，所以不一定要在分支的过程中做了</li>
<li>checkout的时候，需要保证master分支全部commit。（这里其实我做的不够完善，一开始应该是整个本地的网站不要init，让master分支全部被hexo-deployer接管。然后在创建分支的时候，才init。这样可以保证本地只有一个src的分支需要我手动管理。</li>
<li>如果你手贱之前已经建立了master分支，那么有两个办法：<ul>
<li>忽略与origin/master不同步的本地master分支</li>
<li>删除本地的master分支 <code>git branch -D master</code></li>
</ul>
</li>
</ol>
<p><strong>另外一台电脑上如何使用：</strong><br>安装node环境和hexo-cli环境<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew update </span><br><span class="line">$ brew install <span class="keyword">node</span></span><br><span class="line"><span class="title">$</span> npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<p>不要执行hexo init了，而是clone远程的src仓库<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -<span class="selector-tag">b</span> src git@github<span class="selector-class">.com</span>:&lt;username&gt;:&lt;username&gt;<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span></span><br><span class="line">$ npm install <span class="comment">//根据package.json来下载依赖包</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以继续写博客了，整个过程，手动管理的只有src，master分支本地需要，由hexo-deployer负责push。</p>
<p>参考文献[1]中还提到了用git submodule解决第三方主题的同步问题，很不错。<br>参考文献[3]中修改hexo-deployer源码，添加了自动在deploy的时候提交src的功能，很nice。</p>
<p>具体方法：<br>修改<code>node_modules\hexo-deployer-git\lib\deployer.js</code>插件的代码，添加gitBaseDir函数。 注意gitBaseDir函数必须写在module块中，否则会出现错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: deployDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gitBaseDir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: baseDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在push函数中添加提交到src的功能<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(repo)</span>&#123;</span></span><br><span class="line">   <span class="keyword">return</span> git(<span class="string">'add'</span>, <span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'commit'</span>, <span class="string">'-m'</span>, message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">       <span class="comment">// Do nothing. It's OK if nothing to commit.</span></span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'push'</span>, <span class="string">'-u'</span>, repo.url, <span class="string">'master:'</span> + repo.branch, <span class="string">'--force'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> gitBaseDir(<span class="string">'checkout'</span>,<span class="string">'source'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'add'</span>,<span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> gitBaseDir(<span class="string">'commit'</span>,<span class="string">'-m'</span>,message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'push'</span>,<span class="string">'-u'</span>,repo.url,<span class="string">'source:source'</span>,<span class="string">'--force'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="http://devtian.me/2015/03/17/blog-sync-solution/" target="_blank" rel="external">如何管理hexo的源文件</a></li>
<li><a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-Master-%E5%88%86%E6%94%AF?locale=zh-CN" target="_blank" rel="external">为何以及如何删除master分支</a></li>
<li><a href="http://boenyang.github.io/2015/09/09/hello-world/" target="_blank" rel="external">自动化hexo的源文件提交-修改hexo-deployer源码部分</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br]]>
    </summary>
    
      <category term="git" scheme="http://paranoidq.github.io/tags/git/"/>
    
      <category term="git" scheme="http://paranoidq.github.io/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python super详解（译 + 进一步理解）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/python-super-considered-super/"/>
    <id>http://paranoidq.github.io/2016/05/27/python-super-considered-super/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21"><a href="#u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21" class="headerlink" title="翻译：Python’s super() considered super!"></a>翻译：Python’s super() considered super!</h2><h3 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h3><p>如果你没有惊讶于Python内置的super()，那么很可能你并没有真正知道它能做什么以及它如何有效的使用。本文章就主要在已有的python super()解释的基础上做出进一步的深入，主要包括：</p>
<ul>
<li>提供了实际的使用cases</li>
<li>给出了理论模型，演示它如何工作</li>
<li>展示如何使super()发挥它的作用</li>
<li>使用super()的建议</li>
<li>真实的例子</li>
</ul>
<p>本文的例子同时适用于python2和python3版本</p>
<p>首先，一个例子：子类继承内置的类，并且扩展了内置类的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoingDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Setting to %r'</span> % (key, value))</span><br><span class="line">        super().__setitem__(key, value)</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，LoggingDict完成了dict的同样的工作——update元素，只不过扩展了功能，在update元素之前先打log了，然后通过super()将实际update的工作<strong>代理</strong>给了dict对象</p>
<p>如果没有super()，我们可以这样做：<code>dict.__setitem__(self, key, value)</code>，但是问题在于：这种硬编码的方式不利于程序的扩展性。利用super()实际上是一种`<strong>间接引用</strong>（computed indirect reference）。</p>
<p>间接引用的好处之一：<strong>隔离</strong>。不用在是函数内部制定代理类的具体名字。如果要修改base class为另一个类，那么<code>super()</code>会自动切换给代理类，而硬编码的方式则要修改具体实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoingDict</span><span class="params">(SomeOtherMapping)</span>:</span>        <span class="comment"># new base class</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Setting to %r'</span> % (key, value))</span><br><span class="line">        super().__setitem__(key, value)     <span class="comment"># no change needed</span></span><br></pre></td></tr></table></figure></p>
<p>间接引用的另一个好处：<strong>动态</strong>。可以在运行时自由指定间接引用指向的类。引用指向的具体计算方式依赖两点：</p>
<ol>
<li>调用super的class</li>
<li>实例的基类的继承树</li>
</ol>
<p>第一点往往与源码有关，在例子中，super()的调用者是<code>LoggingDict.__setitem__()</code>，这是固定的。<br>第二点则是关键的动态性所在（我们可以创建具有复杂继承关系的子类）。一个logging ordered dictionary，不改变我们已有的类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingOD</span><span class="params">(LoggingDict, collections.OrderedDict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>新类的继承树：<code>LoggingOD, LoggingDict, OrderedDict, dict, object</code>。注意：OrderedDict在dict的前面，因此，调用super()的<code>LoggingDict.__setitem__()</code>现在就把具体的upate任务代理给了OrderedDict，而不是上一个例子中的dict。</p>
<p>仔细考虑一下：在这个例子中，我们并没有改变LoggingDict的源码，而是新增了一个子类，这个新增子类的唯一逻辑就是组合了两个已有的类，并且控制他们的继承顺序。而super()则自动根据新类定义的继承顺序发挥了它的动态性能力！</p>
<h3 id="u57FA_u7C7B_u7684_u67E5_u627E_u987A_u5E8F"><a href="#u57FA_u7C7B_u7684_u67E5_u627E_u987A_u5E8F" class="headerlink" title="基类的查找顺序"></a>基类的查找顺序</h3><p>实际上，这里我称为检索顺序或继承树的说法，正式的叫法应该是：<strong>方法解析顺序(Method Resolution Order, MRO)</strong>。想要知道一个类的MRO可以用<code>__mro__</code>属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pprint(LoggingOD.__mro__)</span><br><span class="line">(&lt;class '__main__.LoggingOD'&gt;,</span><br><span class="line"> &lt;class '__main__.LoggingDict'&gt;,</span><br><span class="line"> &lt;class 'collections.OrderedDict'&gt;,</span><br><span class="line"> &lt;class 'dict'&gt;,</span><br><span class="line"> &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure></p>
<p>如果想按照我们想的MRO创建子类，那么首先需要了解MRO的计算机制：</p>
<blockquote>
<p>MRO的序列包括：本类，基类以及基类的基类们，直到object为止。一个类始终出现在它的基类前面，如果有多个同级基类，那么这些基类的顺序依照声明的顺序排列。</p>
</blockquote>
<p>上述例子遵从MRO的规范：</p>
<ul>
<li>LoggingOD在它的基类LogginDict和OrderedDict前面</li>
<li>LoggingDict在OrderedDict前面，因为<code>LoggingOD.__bases__</code>的声明顺序是(LoggingDict, OrderedDict)</li>
<li>LogginDict在它的基类dict前面</li>
<li>OrderedDict在它的基类dict前面</li>
<li>dict在它的基类object前面</li>
</ul>
<p>解析约束的过程被称作<code>线性化(linearizatoin)</code>。有很多论文研究这方面的内容，但是我们只需要知道两点即可：</p>
<ul>
<li>基类永远出现在派生类后面</li>
<li>如果有多个基类，基类的相对顺序保持不变。</li>
</ul>
<h3 id="u5B9E_u8DF5_u5EFA_u8BAE"><a href="#u5B9E_u8DF5_u5EFA_u8BAE" class="headerlink" title="实践建议"></a>实践建议</h3><p>super()的作用是将本类方法的调用代理给继承树中的某一个基类实例去完成。这里给出三个注意点：</p>
<ul>
<li>保证通过super()调用的基类方法必须存在</li>
<li>调用者和被调用者需要有匹配的函数签名</li>
<li>调用super()的方法，每次出现都同样必须使用super()</li>
</ul>
<p>1): 我们先看这一点：调用者的参数与被调用方法的参数一致。<br>这跟普通的方法调用不同，普通的方法调用在的时候被调用的方法是已知的，但是有了super()，在本类编码的时候被super()调用的方法是未知的。想象一下，我们可以之后定义一个subclass，从而在正在编写的class的MRO中引入新的类，改变MRO的顺序，从而可能改变super()实际调用的类！</p>
<p>我们的方法是：利用位置参数指定固定的签名。例如，在<code>__setitem__()</code>中，就保持了固定的两个位置参数：key和value。这种方法在LoggingDict也有体现，即<code>__setitem__()</code>与dict有同样的函数签名。</p>
<p>更灵活的方法：让继承树中的所有方法都接受这样的参数:<code>关键字参数 + 可变关键字参数</code>，并且每一层取走自己想要的参数，并通过<code>**kwargs</code>向上一层forward余下的参数，最终在调用链的最后一层使得可变关键字参数为空(<code>object.__init__()</code>不需要任何参数)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classs Shape:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, shapename, **kwargs)</span>:</span></span><br><span class="line">        self.shapename = shapename</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredShape</span><span class="params">(Shape)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color, **kwargs)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line">        super().__init(**kwargs)</span><br><span class="line"></span><br><span class="line">cs = ColoredShape(color=<span class="string">'red'</span>, shapename=<span class="string">'circule'</span>)</span><br></pre></td></tr></table></figure></p>
<p>2): 如何确定目标函数存在？<br>上面的例子就是最简单的case，即object有我们调用的方法，因此无论什么样的继承树都会有我们的目标方法，不会出现AttributeError。</p>
<p>那么对于object不存在的方法，我们的处理方法是：编写一个root类包含我们的目标方法，并且在object前面被调用。这个root类的职责就是’吞掉’方法的调用，不让super()继续向上层类传递（因为上层类没有我们的目标方法了，再传递就会最终出现AttributeError）。</p>
<p>Root的draw方法还可以利用防御性编程的策略，即用assert来确保调用链的上层没有draw方法了。这是为了避免子类可能错误的继承了一个没有声明Root为基类的类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Root：</span><br><span class="line">    def draw(self):</span><br><span class="line">        # the delegatioin chain stops here</span><br><span class="line">        assert not hasattr(super(), 'draw')</span><br><span class="line"></span><br><span class="line">class Shape(Root):</span><br><span class="line">    def __init__(self, shapename, **kwargs):</span><br><span class="line">        self.shapename = shapename</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    def draw(self):</span><br><span class="line">        print('Drawing. Setting shape to: ', self.shapename)</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line">class ColoredShape(Shape):</span><br><span class="line">    def __init__(self, color, **kwargs):</span><br><span class="line">        self.color = color</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    def draw(self):</span><br><span class="line">        print('Drawing. Setting color to: ', self.color)</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line">cs = ColoredShape(color='blue', shapename='square')</span><br><span class="line">cs.draw()</span><br></pre></td></tr></table></figure></p>
<p>如果一个子类希望在MRO中引入其他类，那么这些其他类也必须继承自Root，从而确保draw方法不会到达object，而无法被Root.draw阻止下来。这个约定必须写在文档中，就像pyhon中所有的自定义异常都必须继承自BaseException一样。</p>
<p>3): 调用链的每层函数的调用都加上super()方法即可，这是约定。</p>
<h3 id="u5982_u4F55_u5F15_u5165_u2019_u5F02_u7C7B_u2019_uFF08non-cooperative_class_uFF09"><a href="#u5982_u4F55_u5F15_u5165_u2019_u5F02_u7C7B_u2019_uFF08non-cooperative_class_uFF09" class="headerlink" title="如何引入’异类’（non-cooperative class）"></a>如何引入’异类’（non-cooperative class）</h3><p>有时候，我们也要想引入一些第三方的类，这些类并没有针对super设计或者没有遵循Root的约定。解决方法是：利用适配器包装一下。<br>例如下面的Moveable类并没有super()调用，并且它的<code>__init__()</code>方法函数签名与object不一致，并且它没有继承Root。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Drawing at position: '</span>, self.x, self.y)</span><br></pre></td></tr></table></figure></p>
<p>如果你希望把这个类引入ColoredShape的层次中，你需要做一个adapter：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveableAdapter</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, **kwargs)</span>:</span></span><br><span class="line">        self.moveable = Moveable(x, y)</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.moveable.draw()</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovableColoredShape</span><span class="params">(ColoredShape, MoveableAdapter)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">MovableColoredShape(color=<span class="string">'red'</span>, shapename=<span class="string">'triangle'</span>,</span><br><span class="line">                    x=<span class="number">10</span>, y=<span class="number">20</span>).draw()</span><br></pre></td></tr></table></figure></p>
<h3 id="u539F_u6587"><a href="#u539F_u6587" class="headerlink" title="原文"></a>原文</h3><p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a></p>
<h2 id="u8FDB_u4E00_u6B65_u7406_u89E3"><a href="#u8FDB_u4E00_u6B65_u7406_u89E3" class="headerlink" title="进一步理解"></a>进一步理解</h2><h3 id="super_u7684_u672C_u8D28"><a href="#super_u7684_u672C_u8D28" class="headerlink" title="super的本质"></a>super的本质</h3><p>主要来自于<a href="http://zhihu.com/question/20040039/answer/57883315" target="_blank" rel="external">知乎-laike9m的回答</a>，少量删改。</p>
<p>不要一说到 super 就想到基类！super 指的是 MRO 中的下一个类！<br>super干的事情其实是这个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>两个参数分别作了两件事情:</p>
<ol>
<li>inst负责生成MRO的list</li>
<li>通过cls定位当前的MRO中的index,并返回mro[index+1]</li>
</ol>
<p>一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'this is root'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter B'</span>)</span><br><span class="line">        <span class="comment"># print(self)  # &lt;__main__.D object at 0x...&gt;</span></span><br><span class="line">        super().__init__()  <span class="comment"># python3中不用写成super(B, self).__init__()</span></span><br><span class="line">        print(<span class="string">'leave B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter C'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'leave c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">print(D.__mro__)</span><br><span class="line">print(B.__mro__)</span><br><span class="line">print(C.__mro__)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enter b</span><br><span class="line">enter c</span><br><span class="line">this is root</span><br><span class="line">leave c</span><br><span class="line">leave b</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.B'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure></p>
<p>因此，实际上super()调用的时MRO中的下一个类的对应方法，所以不难理解enter b之后是enter c而不是thi is root。因为C是B的下一个，至于为什么C是下一个，那就要看上文翻译中讲的MRO规范了。</p>
<p>需要注意的是，这里的MRO是self生成的，指的是self这个instance对应的类的MRO，self不同，MRO也不同。例如d的MRO就是第一行MRO，而如果instance是B，则MRO就是第二行了。而在上面的例子中，self一直是d。super().func是把实例的MRO中相对于当前类的下一个类的func执行，这个实例并非一定是当前类的，并且如果下一个类的func不再以super的方式调用，则调用终止（但是不建议，除非到了object或者Root）。</p>
<p>注意super继承只能用于新式类，用于经典类时就会报错。</p>
<ul>
<li>新式类：必须有继承的类，如果没什么想继承的，那就继承objcet</li>
<li>经典类：没有基类，如果此时调用super就会出现错误：“super() argument 1 must be type, not classobj”</li>
</ul>
<h3 id="super_u7528_u5728_u4F55_u5904_uFF1F"><a href="#super_u7528_u5728_u4F55_u5904_uFF1F" class="headerlink" title="super用在何处？"></a>super用在何处？</h3><p>主要来自于<a href="http://zhihu.com/question/20040039/answer/13772641" target="_blank" rel="external">知乎-松鼠奥利奥的的回答</a>，少量删改。</p>
<p>super主要用于解决多继承的问题，直接用类名调用基类的方法在单继承的时候没问题，但是如果使用多继承，则会涉及到查找顺序（MRO）、重复调用（钻石继承）等问题。</p>
<p>如果没有复杂的继承结构，super作用不大。而复杂的继承结构本身就是不良设计。对于多重继承的用法，现在比较推崇 Mixin 的方式，也就是</p>
<ul>
<li>普通类多重继承只能有一个普通父类和若干个 Mixin 类（保持主干单一）</li>
<li>Mixin 类不能继承普通类（避免钻石继承）</li>
<li>Mixin 类应该单一职责（参考 Java 的 interface 设计，Mixin 和此极其相似，只不过附带实现而已）<br>如果按照上述标准，只使用 Mixin形式的多继承，那么不会有钻石继承带来的重复方法调用，也不会有复杂的查找顺序 —— 此时 super 是可以有无的了，用不用全看个人喜好，只是记得千万别和类名调用的方式混用就好。</li>
</ul>
<p>Python的多继承类是通过mro的方式来保证各个基类的函数被逐一调用，而且保证每个基类函数只调用一次（如果每个类都使用super）</p>
<h3 id="u6E90_u7801_u7EA7_u522B_u7684_u89E3_u91CA"><a href="#u6E90_u7801_u7EA7_u522B_u7684_u89E3_u91CA" class="headerlink" title="源码级别的解释"></a>源码级别的解释</h3><p><a href="http://blog.csdn.net/johnsonguo/article/details/585193" target="_blank" rel="external">http://blog.csdn.net/johnsonguo/article/details/585193</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21"><a href="#u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_supe]]>
    </summary>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="super" scheme="http://paranoidq.github.io/tags/super/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.util.ResourceBundle 源码分析]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/ResourceBundle-source-code-inside/"/>
    <id>http://paranoidq.github.io/2016/05/27/ResourceBundle-source-code-inside/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ResourceBundle_u7B80_u4ECB"><a href="#ResourceBundle_u7B80_u4ECB" class="headerlink" title="ResourceBundle简介"></a>ResourceBundle简介</h3><p>顾名思义，ResourceBundle主要就是管理Java程序的一些配置资源的工具类。但是这个管理与一般管理不同的地方在于:</p>
<ul>
<li><p>locale-independent, 即ResourceBundle封装了本地化的读取方法，并且根据Locale参数读对应的本地化配置，从而能够使程序自动在不同地区载入不同的配置文件(<code>name_CN.properties</code>, <code>name_US.properties</code>等)。JavaDoc说法:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">be </span>easily localized, <span class="keyword">or </span>translated, into <span class="keyword">different </span>languages</span><br><span class="line"><span class="number">2</span>. handle <span class="keyword">multiple </span>locales <span class="built_in">at</span> once</span><br><span class="line"><span class="number">3</span>. <span class="keyword">be </span>easily modified later to support even more locales</span><br></pre></td></tr></table></figure>
</li>
<li><p>在没有指定Locale的情况下，自动载入默认配置<code>name.properties</code></p>
</li>
<li>带有缓存功能</li>
<li>线程安全</li>
</ul>
<h3 id="ResourceBundle_u4F7F_u7528"><a href="#ResourceBundle_u4F7F_u7528" class="headerlink" title="ResourceBundle使用"></a>ResourceBundle使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBundleUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourceBundleUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResourceBundle <span class="title">newResourceBundle</span><span class="params">(String resourcePath)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResourceBundle.getBundle(resourcePath, Locale.ENGLISH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResourceBundle <span class="title">newResourceBundle</span><span class="params">(String resourcePath, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceBundle.getBundle(resourcePath, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ResourceBundle rb = ResourceBundleUtil.newResourceBundle(<span class="string">"with_classpath"</span>);</span><br><span class="line">        String value1 = rb.getString(<span class="string">"key1"</span>);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，如果不在clsspath的root目录下，需要指定全名</span></span><br><span class="line">        ResourceBundle rb2 = ResourceBundleUtil.newResourceBundle(<span class="string">"i18n.within_folder"</span>);</span><br><span class="line">        value1 = rb2.getString(<span class="string">"key1"</span>);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义ResourceBundle例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResources</span> <span class="keyword">extends</span> <span class="title">ResourceBundle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleGetObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(<span class="string">"okKey"</span>)) <span class="keyword">return</span> <span class="string">"Ok"</span>;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(<span class="string">"cancelKey"</span>)) <span class="keyword">return</span> <span class="string">"Cancel"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// keySet() is inherted from super class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Overrides handleKeySet() so that the getKeys() implementation</span></span><br><span class="line">    <span class="comment">// can rely on the keySet() value.</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">handleKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(<span class="string">"okKey"</span>, <span class="string">"cancelKey"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceBundle_u7C7B_u7ED3_u6784"><a href="#ResourceBundle_u7C7B_u7ED3_u6784" class="headerlink" title="ResourceBundle类结构"></a>ResourceBundle类结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle</span><br><span class="line">    |__ ListResourceBundle</span><br><span class="line">    |__ PropertyResourceBundle</span><br></pre></td></tr></table></figure>
<h3 id="ResourceBundle_u6E90_u7801_u7279_u6027"><a href="#ResourceBundle_u6E90_u7801_u7279_u6027" class="headerlink" title="ResourceBundle源码特性"></a>ResourceBundle源码特性</h3><h4 id="u5DE5_u5382_u65B9_u6CD5"><a href="#u5DE5_u5382_u65B9_u6CD5" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>通过工厂方法<code>getBundle()</code>返回ResourceBundle的子类对象，处理不同的配置资源加载过程。</p>
<h4 id="u5B9E_u73B0_u7C7B"><a href="#u5B9E_u73B0_u7C7B" class="headerlink" title="实现类"></a>实现类</h4><p>ResourceBundle本身是abstract，实际使用的是两个实现类。<br>ListResourceBundle将配置资源看做key/value组成的列表，而PropertyResourceBundle使用properties来维护配置资源。</p>
<p>可以自己实现ResourceBundle，需要实现两个方法：<code>handleGetObject()</code> 和 <code>getKeys()</code>。另外需要注意的是，自己实现的ResourceBundle类要保证线程安全性，因为可能被多个线程同时使用。（ResourceBundle的非abstract方法和两个已知实现类的方法都是线程安全的）</p>
<h4 id="u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>ResourceBundle的非abstract方法和两个已知实现类的方法都是线程安全的。<br>另外，自己实现的ResourceBundle类的<code>handleGetObject()</code>和<code>getKeys()</code>要保证线程安全性，因为可能被多个线程同时使用。</p>
<h4 id="u8D44_u6E90_u52A0_u8F7D_u8FC7_u7A0B_u7684_u63A7_u5236_uFF1AResourceBundle-Control"><a href="#u8D44_u6E90_u52A0_u8F7D_u8FC7_u7A0B_u7684_u63A7_u5236_uFF1AResourceBundle-Control" class="headerlink" title="资源加载过程的控制：ResourceBundle.Control"></a>资源加载过程的控制：ResourceBundle.Control</h4><p>可以控制资源的搜索顺序、bundle的格式或缓存方式等。两种方式控制ResourceBundle加载配置资源的过程：</p>
<ol>
<li>在<code>getBundle()</code>的参数中指定Control实例</li>
<li>通过指定<code>ResourceBundleControlProvider</code>的实现类。这个实现类会在ResouceBundle类被加载的时候就检测到，如果实现类针对某一个base name提供了Control对象，那么加载这个base name时的默认行为就会被改变。如果有多个providers针对同一个base name，那么选择第一个provider。</li>
</ol>
<p>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle.getBundle(String, Locale, ClassLoader, Control);</span><br></pre></td></tr></table></figure>
<h4 id="Cache_management"><a href="#Cache_management" class="headerlink" title="Cache management"></a>Cache management</h4><p><code>getBundle()</code>返回的ResourceBundle会被默认缓存起来，从而下次请求同样的配置名时，会返回缓存过的ResourceBundle实例。<br>使用者可以选择不缓存、控制缓存时间（通过<code>time-to-live</code>变量），也可以清空cache。<br>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle.clearCache();</span><br><span class="line">ResourceBundle.Control.getTimeToLive();</span><br><span class="line">ResourceBundle.Control.needsReload();</span><br></pre></td></tr></table></figure>
<h3 id="ResourceBundle_u6E90_u7801_u5206_u6790"><a href="#ResourceBundle_u6E90_u7801_u5206_u6790" class="headerlink" title="ResourceBundle源码分析"></a>ResourceBundle源码分析</h3><h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>java.util.ResourceBundle源码(JDK1.8)<br><a href="http://blog.csdn.net/haiyan0106/article/details/2257725" target="_blank" rel="external">http://blog.csdn.net/haiyan0106/article/details/2257725</a><br><a href="http://san-yun.iteye.com/blog/1683558" target="_blank" rel="external">Java WeakReference与SoftReference</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ResourceBundle_u7B80_u4ECB"><a href="#ResourceBundle_u7B80_u4ECB" class="headerlink" title="ResourceBundle简介"></a>ResourceBundle简介</]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="resourcebundle" scheme="http://paranoidq.github.io/tags/resourcebundle/"/>
    
      <category term="jdk" scheme="http://paranoidq.github.io/tags/jdk/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSH Principles（总结和笔记）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/SSH-Principles/"/>
    <id>http://paranoidq.github.io/2016/05/27/SSH-Principles/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T16:01:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="meta"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="meta"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><ol>
<li>基本流程：<ul>
<li>client请求登陆remote server</li>
<li>server发送公钥给client，并告知client发送自己的密码</li>
<li>client用公钥加密密码，发送给server</li>
<li>server用私钥解密密码，如果成功，就允许用户登陆</li>
</ul>
</li>
<li>为何安全：<ul>
<li>全程不传输私钥，及时截获报文，只要私钥不泄露，就不能获取密码</li>
<li>密码由随机的公钥加密，可换</li>
</ul>
</li>
<li>为何有风险：<ul>
<li>如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的</li>
<li>中间人攻击（Man-in-the-middle attack）：如果攻击者插在用户与远程主机之间（比如在公共的wifi区域）用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了</li>
</ul>
</li>
</ol>
<h3 id="u4E24_u79CD_u767B_u5F55_u65B9_u5F0F"><a href="#u4E24_u79CD_u767B_u5F55_u65B9_u5F0F" class="headerlink" title="两种登录方式"></a>两种登录方式</h3><h4 id="u53E3_u4EE4_u767B_u5F55"><a href="#u53E3_u4EE4_u767B_u5F55" class="headerlink" title="口令登录"></a>口令登录</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'host (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。然后要求用户输入密码<br>    <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'host,12.18.429.21'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts.</span><br><span class="line">Password: (enter password)</span><br></pre></td></tr></table></figure></p>
<p>保存远程主机的公钥在<code>$HOME/.ssh/known_hosts</code>中，以后连接主机时client能识别公钥已经保存在本地，跳过警告部分。（但是仍然需要输入密码）</p>
<p><code>/etc/ssh/ssh_known_hosts</code>保存对所有用户可信的远程主机公钥</p>
<h4 id="u516C_u94A5_u767B_u5F55"><a href="#u516C_u94A5_u767B_u5F55" class="headerlink" title="公钥登录"></a>公钥登录</h4><blockquote>
<p>原理：</p>
</blockquote>
<ol>
<li>用户将自己的公钥储存在远程主机上。</li>
<li>登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。</li>
<li>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码</li>
</ol>
<blockquote>
<p>操作：</p>
</blockquote>
<p>用户生成自己的公钥：在<code>$HOME/.ssh</code>下会生成<code>id_rsa.pub</code>和<code>id_rsa</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>拷贝公钥到server：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-copy-id user<span class="variable">@host</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="variable">$ </span>scp /Users/paranoidq/.ssh/id_rsa.pub paranoidq<span class="variable">@192</span>.<span class="number">168.235</span>.<span class="number">131</span><span class="symbol">:/home/paranoidq/</span>.ssh/authorized_keys </span><br><span class="line"><span class="comment"># 但是scp不能附加多个authorized_keys，所以貌似只能支持一个用户一个公钥！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于ssh-copy-id的过程：</p>
</blockquote>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh user<span class="variable">@host</span> <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li><code>$ ssh user@host</code>表示登录远程主机；</li>
<li><code>mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>表示登录后在远程shell上执行的命令</li>
<li><code>mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个</li>
<li><code>cat &gt;&gt; .ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件<code>authorized_keys</code>的末尾</li>
</ol>
<p>注：有必要学习一下bash和shell的知识了，推荐Mendel Cooper的<a href="http://www.tldp.org/LDP/abs/html/" target="_blank" rel="external">《Advanced Bash: Scrpiting Guide》</a></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">廖雪峰的官方网站，ssh原理与运用</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="meta"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="meta"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ssh" scheme="http://paranoidq.github.io/tags/ssh/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac中如何查找Java的路径]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Mac-java-config/"/>
    <id>http://paranoidq.github.io/2016/05/27/Mac-java-config/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u65B9_u6CD52_uFF1A"><a href="#u65B9_u6CD52_uFF1A" class="headerlink" title="方法2："></a>方法2：</h3><p>step-wise的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br></pre></td></tr></table></figure>
<p>如果输出的时/usr/bin/java, 证明是链接，需要找到链接的source<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="_">-l</span> `<span class="built_in">which</span> java`</span><br></pre></td></tr></table></figure></p>
<p>输出为实际的java安装路径: <code>rwxr-xr-x  1 root  wheel  74 11 25 13:36 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</code></p>
<p>如果/usr/bin/java指向的仍然是一个symbolic link, 那么继续执行以下命令，直到找到source为止 </p>
<p>[注]</p>
<p>ls -l ` which java`</p>
<p>单引号把Linux命令视为字符集合。反引号会强迫执行Linux命令。和<code>$()</code>一样。在执行一条命令时，会先将其中或者是<code>$()</code> 中的语句当作命令执行一遍，再将结果加入到外层命令中执行</p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac" target="_blank" rel="external">http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="mac" scheme="http://paranoidq.github.io/tags/mac/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大数据生态圈技术总结（持续补充）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/"/>
    <id>http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><ol>
<li><p>磁盘</p>
<ul>
<li>HDFS</li>
<li>S3</li>
<li>Ceph</li>
<li>NFS</li>
<li>Gluster FS</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li>Tachyon</li>
<li>Spark</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u6570_u636E_u5E93"><a href="#u5206_u5E03_u5F0F_u6570_u636E_u5E93" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><ol>
<li><p>磁盘</p>
<ul>
<li>Cassandra</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
</li>
<li><p>内存 </p>
<ul>
<li>Redis</li>
<li>Memcached</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u8BA1_u7B97"><a href="#u5206_u5E03_u5F0F_u8BA1_u7B97" class="headerlink" title="分布式计算"></a>分布式计算</h3><ol>
<li><p>批处理</p>
<ul>
<li>Hadoop MapReduce</li>
<li>Spark(支持迭代)</li>
<li>Flink(支持迭代)</li>
</ul>
</li>
<li><p>流式计算</p>
<ul>
<li>Storm</li>
<li>Samza</li>
<li>Spark Streaming</li>
<li>Flink</li>
</ul>
</li>
<li><p>即席查询(ad-hoc)</p>
<ul>
<li>Hive</li>
<li>SparkSQL</li>
<li>Presto(Facebook)</li>
<li>Impala</li>
<li>Drill(Google Dremel的开源实现)</li>
</ul>
</li>
</ol>
<h3 id="u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406"><a href="#u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406" class="headerlink" title="资源调度与管理"></a>资源调度与管理</h3><ul>
<li>ZooKeeper</li>
<li>YARN</li>
<li>Mesos</li>
</ul>
<h3 id="u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h3><ul>
<li>StormMQ</li>
<li>RabbitMQ</li>
<li>ZeroMQ</li>
<li>Apache ActiveMQ</li>
<li>Jafka(LinkedIn)</li>
<li>Kafka(LinkedIn)</li>
</ul>
<h3 id="RPC_u6846_u67B6"><a href="#RPC_u6846_u67B6" class="headerlink" title="RPC框架"></a>RPC框架</h3><ul>
<li>Apache Avro</li>
<li>Thrift(Facebook)</li>
<li>Kyro</li>
</ul>
<h3 id="u96C6_u7FA4_u76D1_u63A7"><a href="#u96C6_u7FA4_u76D1_u63A7" class="headerlink" title="集群监控"></a>集群监控</h3><ul>
<li>Zabbix</li>
<li>Ganglia</li>
<li>Nagios</li>
<li>Ambari()</li>
</ul>
<h3 id="u6570_u636E_u6536_u96C6"><a href="#u6570_u636E_u6536_u96C6" class="headerlink" title="数据收集"></a>数据收集</h3><ul>
<li>Flume</li>
<li>Scribe(Facebook)</li>
<li>Logstash</li>
<li>Kafka</li>
</ul>
<h3 id="u56FE_u8BA1_u7B97_u6846_u67B6"><a href="#u56FE_u8BA1_u7B97_u6846_u67B6" class="headerlink" title="图计算框架"></a>图计算框架</h3><ul>
<li>Spark Graphx</li>
<li>PowerGraph</li>
<li>Giraph</li>
<li>Neo4j</li>
</ul>
<h3 id="u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60"><a href="#u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h3><ul>
<li>Spark MLlib</li>
<li>Mahout</li>
<li>PredictionIO</li>
</ul>
<h3 id="u641C_u7D22_u5F15_u64CE"><a href="#u641C_u7D22_u5F15_u64CE" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul>
<li>Lucene</li>
<li>Solr</li>
<li>ElasticSearch</li>
<li>Sphinx</li>
<li>SenseiDB</li>
</ul>
<h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><ul>
<li>OpenStack</li>
<li>Docker </li>
<li>Kubernetes(容器调度管理)</li>
</ul>
<h3 id="u57FA_u7840_u7ED3_u6784"><a href="#u57FA_u7840_u7ED3_u6784" class="headerlink" title="基础结构"></a>基础结构</h3><ul>
<li>LevelDB</li>
<li>SSTable(BigTable基础)</li>
<li>RecordIO(文件格式)</li>
<li>Flat Buffer(Google, 高效、跨平台的序列化库)</li>
<li>ProtocolBuffers(Google, 数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面)</li>
<li>Consistent Hashing</li>
<li>Netty(提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序)</li>
<li>BloomFilter</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.36dsj.com/archives/25042" target="_blank" rel="external">http://www.36dsj.com/archives/25042</a><br><a href="http://www.csdn.net/article/2015-09-11/2825674" target="_blank" rel="external">http://www.csdn.net/article/2015-09-11/2825674</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"><]]>
    </summary>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="大数据" scheme="http://paranoidq.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="攻略" scheme="http://paranoidq.github.io/tags/%E6%94%BB%E7%95%A5/"/>
    
      <category term="大数据" scheme="http://paranoidq.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx与tomcat有什么区别]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/"/>
    <id>http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>
<a id="more"></a>
<p>Http Server的核心是Http协议层面的传输和访问控制，包括代理、负载均衡等。客户端通过Http协议访问Http Server上的文件资源(HTML文件、图片等)，然后Http Server如实将文件通过Http协议传输给客户端。当然，通过<code>CGI</code>技术也可以对Http Server传输的内容进行一些处理。<br>大多数时候，Nginx主要作为Tomcat前端的负载均衡器和代理，负责请求的转发和静态内容的直接返回。因为其高效的IO机制[2]，能够显著提高系统的吞吐率。</p>
<p>Web App Server，应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，<br>应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>Tomcat和Jetty，WebLogic同属一类。</p>
<p><hr></p>
<blockquote>
<p>“tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”</p>
</blockquote>
<p>—— 不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用，也就是说servlet容器必须由java或者基于jvm的语言实现。<br><strong>本质上，Servlet是J2EE规范的一部分，规定了容器和Web App必须遵循的接口规范。容器必须按照接口解析Java类，然后处理请求；同样Web App也只有按照规范来编写实现类，才能被容器所加载解析，从而完成特定的功能。</strong></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.zhihu.com/question/32212996" target="_blank" rel="external">https://www.zhihu.com/question/32212996</a></li>
<li><a href="http://90112526.blog.51cto.com/6013499/1059700" target="_blank" rel="external">http://90112526.blog.51cto.com/6013499/1059700</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="nginx" scheme="http://paranoidq.github.io/tags/nginx/"/>
    
      <category term="tomcat" scheme="http://paranoidq.github.io/tags/tomcat/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 插件NERDTree命令]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/NERDTree-commands/"/>
    <id>http://paranoidq.github.io/2016/05/27/NERDTree-commands/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">h</span>    光标 focus 左侧树形目录</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">l</span>    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">w</span>    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">r</span>    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line"><span class="keyword">s</span>       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line"><span class="keyword">x</span>       合拢选中结点的父目录</span><br><span class="line"><span class="keyword">X</span>       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line"># 双击    相当于 NERDTree-o (Mac下无效...)</span><br><span class="line"># 中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line"><span class="keyword">D</span>       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line"><span class="keyword">K</span>       跳到当前目录下同级的第一个结点</span><br><span class="line"><span class="keyword">J</span>       跳到当前目录下同级的最后一个结点</span><br><span class="line"><span class="keyword">k</span>       跳到当前目录下同级的前一个结点</span><br><span class="line"><span class="keyword">j</span>       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line"><span class="keyword">r</span>       递归刷新选中目录</span><br><span class="line"><span class="keyword">R</span>       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line"><span class="keyword">q</span>       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure>
<p>操作tab<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">tabnew</span> [++<span class="keyword">opt</span>选项] ［＋cmd］ 文件      建立对指定文件新的<span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabc</span>   关闭当前的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabo</span>   关闭所有其他的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabs</span>   查看所有打开的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabp</span>   前一个 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabn</span>   后一个 <span class="keyword">tab</span></span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 <span class="keyword">tab</span></span><br><span class="line">gt      后一个 <span class="keyword">tab</span></span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 <span class="keyword">tab</span> 的关闭、切换</span><br><span class="line">cmd+<span class="keyword">w</span>   关闭当前的 <span class="keyword">tab</span></span><br><span class="line">cmd+&#123;   前一个 <span class="keyword">tab</span></span><br><span class="line">cmd+&#125;   后一个 <span class="keyword">tab</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">h</span>    光标 focus 左侧树形目录</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">l</span>    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">w</span>    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">r</span>    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://paranoidq.github.io/tags/vim/"/>
    
      <category term="nerdtree" scheme="http://paranoidq.github.io/tags/nerdtree/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是中间件？]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/"/>
    <id>http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料研究研究。</p>
<h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><p>维基百科定义：</p>
<blockquote>
<p>提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。如数据库、Apache的Tomcat，IBM公司的WebSphere,BEA公司的WebLogic[[应用服务器]，东方通公司的Tong系列中间件，以及Kingdee公司的等都属于中间件。</p>
</blockquote>
<p>简单归纳：<br>业务应用 - 中间件 - 基础资源</p>
<ul>
<li>中间件处于两者中间的的位置，封装基础资源，向上层提供更完善的功能。</li>
<li>基础资源包括硬的资源：如CPU、存储(分布式)、网络；我个人认为也包括进程、线程、消息队列、数据库这种软性资源，中间件对这些资源做了封装处理。</li>
</ul>
<h3 id="u4F5C_u7528"><a href="#u4F5C_u7528" class="headerlink" title="作用"></a>作用</h3><ul>
<li>封装</li>
<li>整合</li>
<li>屏蔽</li>
<li>容错</li>
</ul>
<p>我个人归纳为这四个主要功能。封装和整合的是基础资源，使得难用的基础资源更便于使用，而不用考虑细节。（调用顺序、分布式、配置、初始化属性等等）。屏蔽的是底层细节，同时也屏蔽底层的差异（例如，JVM这种本质意义上其实也可算作中间件，通过JVM屏蔽不同系统的差异，从而能够无差异运行Java程序）。容错，则是中间件的另一个重要作用，保证上层无论如何调用，都会得到相应的处理，而不会将错误传递到底层去或直接消失。</p>
<h3 id="u5E38_u89C1_u79CD_u7C7B_uFF1A"><a href="#u5E38_u89C1_u79CD_u7C7B_uFF1A" class="headerlink" title="常见种类："></a>常见种类：</h3><ul>
<li>分布式调用RPC：</li>
<li>消息队列</li>
<li>事务处理</li>
<li>数据库组件</li>
<li>安全组件</li>
<li>并发组件</li>
<li>应用容器组件</li>
<li>日志组件：Apache Kafaka</li>
<li>监控组件：Zookkeeper, Mesos, </li>
</ul>
<h3 id="u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29"><a href="#u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29" class="headerlink" title="阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)"></a>阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)</h3><p><img src="http://jm.taobao.org/wp-content/uploads/2013/07/jm.jpg" alt="阿里巴巴中间件支撑平台"></p>
<ul>
<li><strong>Diamond</strong>: 软负载配置中心，用于存储静态配置，并能够提供配置变更动态推送功能，结构简单，超高可用性。在全网被使用于存储不经常发生变化的配置信息。</li>
<li><strong>Notify</strong>, <strong>Meta</strong>: 消息中间件</li>
<li><strong>HSF</strong>: 阿里分布式服务框架，统一整个集团rpc的调用，包括服务方式的统一调用，软负载，服务治理等，提供一套简单方便，高性能的分布式服务框架。</li>
<li><strong>eagleeye</strong>: 淘宝分布式跟踪系统，该系统实现基于单链路的实时监控，系统依赖，性能调优，风险控制等</li>
<li><strong>Pandora</strong>: 淘宝隔离容器，该系统主要解决大规模富二方包升级，二方包隔离，二方包监控等问题。</li>
<li><strong>TDDL</strong>: 通用数据访问层，部署在客户端的jar包，用于将用户的SQL路由到指定的数据库中。目前有1000+应用在使用</li>
<li><strong>精卫</strong>: 通用数据总线，用于将数据从一个数据节点迁移到其他一个或多个数据节点中，目前支持mysql,oracle,hbase等。目前有100+应用在使用</li>
<li><strong>愚公</strong>: 数据自动迁移引擎，海量数据自动运维工具，可用于对用户无影响的自动扩容和缩容，数据平滑迁移，以及异构数据源迁移，目前已经完成了214次业务迁移或扩容。</li>
<li><strong>NewSQL</strong>: NewSQL系统，可以将SQL运行于传统MYSQL/Oracle关系数据库，也可以支持NoSQL数据库如bdb , hbase等。 可以实现其中的跨机合并和跨机交操作等复杂关系操作。</li>
<li><strong>CSP2.0</strong>: 持续稳定性平台帮助阿里系统保障高可用性，包含线上压测、容量规划、依赖治理、限流降级、监控报警、问题定位等模块。</li>
<li><strong>Hotspot</strong>: 性能分析平台通过对基础软件、服务端、前端加载、网络、CDN等方面的性能分析，来帮助阿里系统提升吞吐量、降低延迟时间、节约成本。</li>
<li><strong>TProfiler</strong>: TProfiler是可以在生产环境长期使用的性能分析工具，通过在Java层面记录代码执行热点、对象创建热点等数据，帮助系统定位性能瓶颈。</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6</a><br><a href="http://jm-blog.aliapp.com/?page_id=2449" target="_blank" rel="external">阿里巴巴中间件团队博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac Terminal Commands]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/mac-terminal-commands/"/>
    <id>http://paranoidq.github.io/2016/05/27/mac-terminal-commands/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p>   本文所有快捷键基于iterm2. 有些快捷键被系统屏蔽了，到<code>系统偏好设置</code>中删除无用的快捷键即可</p>
<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><ul>
<li>显示光标位置： <code>command + /</code></li>
<li>移动到行首： <code>ctrl + a</code></li>
<li>移动到行尾： <code>ctrl + e</code></li>
<li>向前移动一个字符： <code>ctrl + f</code> = Forward</li>
<li>向后移动一个字符： <code>ctrl + b</code> = Backward</li>
<li>向前移动一个单词： <code>alt + f</code></li>
<li>向后移动一个单词： <code>alt + b</code></li>
</ul>
<h3 id="u5B57_u7B26_u64CD_u4F5C"><a href="#u5B57_u7B26_u64CD_u4F5C" class="headerlink" title="字符操作"></a>字符操作</h3><ul>
<li>删除一个字符： <code>ctrl + d</code> = <code>Delete</code></li>
<li>删除一个字符（前向）： <code>ctrl + h</code> = <code>Backspace</code></li>
<li>删除光标前到行首的字符： <code>ctrl + u</code> = 清除本行</li>
<li>删除光标前到行尾的字符： <code>ctrl + k</code></li>
<li>恢复之前的操作： <code>ctrl + y</code></li>
</ul>
<h3 id="u8F93_u5165_u64CD_u4F5C"><a href="#u8F93_u5165_u64CD_u4F5C" class="headerlink" title="输入操作"></a>输入操作</h3><ul>
<li>自动补全历史记录： <code>command + ;</code></li>
</ul>
<h3 id="u5C4F_u5E55_u64CD_u4F5C"><a href="#u5C4F_u5E55_u64CD_u4F5C" class="headerlink" title="屏幕操作"></a>屏幕操作</h3><ul>
<li>清屏： <code>command + r</code></li>
<li>新建标签： <code>ctrl + t</code></li>
<li>关闭当前标签页： <code>command + w</code></li>
<li>左右分割： <code>command + d</code></li>
<li>垂直分割： <code>command + shift + d</code></li>
<li>切换标签页： <code>command + (+alt) +[number]/[up/down]</code></li>
<li></li>
</ul>
<h3 id="u6587_u4EF6_u64CD_u4F5C"><a href="#u6587_u4EF6_u64CD_u4F5C" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>打开文件： <code>command + [Click]</code></li>
</ul>
<h3 id="job_u64CD_u4F5C"><a href="#job_u64CD_u4F5C" class="headerlink" title="job操作"></a>job操作</h3><ul>
<li>挂起job： <code>ctrl + z</code></li>
<li>查看挂起的job： <code>jobs</code></li>
<li>继续执行挂起的job： <code>fg</code></li>
<li></li>
<li></li>
<li></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>   本文所有快捷键基于iterm2. 有些快捷键被系统屏蔽了，到<code>系统偏好设置</code>中删除无用的快捷键即可</p>
<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" c]]>
    </summary>
    
      <category term="mac" scheme="http://paranoidq.github.io/tags/mac/"/>
    
      <category term="快捷键" scheme="http://paranoidq.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
      <category term="mac" scheme="http://paranoidq.github.io/categories/mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[20个工具监控Linux服务性的性能(转)]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/linux-server-monitoring-tools/"/>
    <id>http://paranoidq.github.io/2016/05/27/linux-server-monitoring-tools/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p>对于每个系统管理员或网络管理员来说，每天要监控和调试 Linux 系统性能问题都是非常困难的工作。我已经有5年 Linux 管理员的工作经历，知道如何监控系统使其保持正常运行。为此，我们编写了对于 Linux/Unix 系统管理员非常有用的并且最常用的20个命令行系统监视工具。这些命令可以在所有版本的 Linux 下使用去监控和查找系统性能的实际原因。这些监控命令足够你选择适合你的监控场景。</p>
<a id="more"></a>
<h3 id="top__u2014Linux_u7CFB_u7EDF_u8FDB_u7A0B_u76D1_u63A7"><a href="#top__u2014Linux_u7CFB_u7EDF_u8FDB_u7A0B_u76D1_u63A7" class="headerlink" title="top —Linux系统进程监控"></a>top —Linux系统进程监控</h3><p>top 命令是性能监控程序，它可以在很多 Linux/Unix 版本下使用，并且它也是 Linux 系统管理员经常使用的监控系统性能的工具。Top 命令可以定期显示所有正在运行和实际运行并且更新到列表中，它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。它也会显示内存和 CPU 使用率过高的正在运行的进程。当我们对 Linux 系统需要去监控和采取正确的行动时，top 命令对于系统管理员是非常有用的。让我们看下 top 命令的实际操作。</p>
<p><img src="http://www.linuxstory.org/wp-content/uploads/2015/12/1.jpg" alt="top"></p>
<h3 id="vmstat__u2014__u865A_u62DF_u5185_u5B58_u7EDF_u8BA1"><a href="#vmstat__u2014__u865A_u62DF_u5185_u5B58_u7EDF_u8BA1" class="headerlink" title="vmstat — 虚拟内存统计"></a>vmstat — 虚拟内存统计</h3><p>vmstat 命令是用于显示虚拟内存、内核线程、磁盘、系统进程、I/O 模块、中断、CPU 活跃状态等更多信息。在默认的情况下，Linux 系统是没有 vmstat 这个命令的，如果你要使用它，必须安装一个包名叫 sysstat 的程序包。命令格式常用用法如下：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span> <span class="comment">vmstat</span></span><br><span class="line"><span class="comment">procs</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">memory</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">swap</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">io</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">system</span><span class="literal">-</span><span class="literal">-</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">cpu</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span></span><br><span class="line"> <span class="comment">r</span>  <span class="comment">b</span>   <span class="comment">swpd</span>   <span class="comment">free</span>  <span class="comment">inact</span> <span class="comment">active</span>   <span class="comment">si</span>   <span class="comment">so</span>    <span class="comment">bi</span>    <span class="comment">bo</span>   <span class="comment">in</span>   <span class="comment">cs</span> <span class="comment">us</span> <span class="comment">sy</span> <span class="comment">id</span> <span class="comment">wa</span> <span class="comment">st</span></span><br><span class="line"> <span class="comment">1</span>  <span class="comment">0</span>      <span class="comment">0</span> <span class="comment">810420</span>  <span class="comment">97380</span>  <span class="comment">70628</span>    <span class="comment">0</span>    <span class="comment">0</span>   <span class="comment">115</span>     <span class="comment">4</span>   <span class="comment">89</span>   <span class="comment">79</span>  <span class="comment">1</span>  <span class="comment">6</span> <span class="comment">90</span>  <span class="comment">3</span>  <span class="comment">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="lsof__u2014__u6253_u5F00_u6587_u4EF6_u5217_u8868"><a href="#lsof__u2014__u6253_u5F00_u6587_u4EF6_u5217_u8868" class="headerlink" title="lsof — 打开文件列表"></a>lsof — 打开文件列表</h3><p>lsof 命令对于很多 Linux/Unix 系统都可以使用，主要以列表的形式显示打开的文件和进程。</p>
<p>打开的文件主要包括磁盘文件、网络套接字、管道、设备和进程。使用这个命令的主要原因是一个一个盘不能卸载并且显示文件正在使用或者打开的错误信息。这个命令很容易看出哪些文件正在使用。这个命令最常用的格式：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsof</span></span><br><span class="line">COMMAND     PID      USER   FD      TYPE     DEVICE     SIZE       NODE NAME</span><br><span class="line">init          <span class="number">1</span>      root  cwd       DIR      <span class="number">104</span>,<span class="number">2</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">init          <span class="number">1</span>      root  rtd       DIR      <span class="number">104</span>,<span class="number">2</span>     <span class="number">4096</span>          <span class="number">2</span> /</span><br><span class="line">init          <span class="number">1</span>      root  txt       REG      <span class="number">104</span>,<span class="number">2</span>    <span class="number">38652</span>   <span class="number">17710339</span> /sbin/init</span><br><span class="line">init          <span class="number">1</span>      root  mem       REG      <span class="number">104</span>,<span class="number">2</span>   <span class="number">129900</span>     <span class="number">196453</span> /<span class="class"><span class="keyword">lib</span>/<span class="title">ld</span>-2.5.<span class="title">so</span></span></span><br><span class="line">init          <span class="number">1</span>      root  mem       REG      <span class="number">104</span>,<span class="number">2</span>  <span class="number">1693812</span>     <span class="number">196454</span> /<span class="class"><span class="keyword">lib</span>/<span class="title">libc</span>-2.5.<span class="title">so</span></span></span><br><span class="line">init          <span class="number">1</span>      root  mem       REG      <span class="number">104</span>,<span class="number">2</span>    <span class="number">20668</span>     <span class="number">196479</span> /<span class="class"><span class="keyword">lib</span>/<span class="title">libdl</span>-2.5.<span class="title">so</span></span></span><br><span class="line">init          <span class="number">1</span>      root  mem       REG      <span class="number">104</span>,<span class="number">2</span>   <span class="number">245376</span>     <span class="number">196419</span> /<span class="class"><span class="keyword">lib</span>/<span class="title">libsepol</span>.<span class="title">so</span>.1</span></span><br><span class="line">init          <span class="number">1</span>      root  mem       REG      <span class="number">104</span>,<span class="number">2</span>    <span class="number">93508</span>     <span class="number">196431</span> /<span class="class"><span class="keyword">lib</span>/<span class="title">libselinux</span>.<span class="title">so</span>.1</span></span><br><span class="line">init          <span class="number">1</span>      root   <span class="number">10</span>u     FIFO       <span class="number">0</span>,<span class="number">17</span>                 <span class="number">953</span> /dev/initctl</span><br></pre></td></tr></table></figure>
<h3 id="tcpdump__u2014__u7F51_u7EDC_u6570_u636E_u5305_u5206_u6790_u5668"><a href="#tcpdump__u2014__u7F51_u7EDC_u6570_u636E_u5305_u5206_u6790_u5668" class="headerlink" title="tcpdump — 网络数据包分析器"></a>tcpdump — 网络数据包分析器</h3><p>tcpdump 是一种使用最广泛的命令行网络数据包分析器或数据包嗅探程序，主要用于捕获和过滤 TCP/IP 包收到或者转移在一个网络的特定借口信息。它也提供了一个选项参数去保存将捕获的包在一个文件中用于以后分析使用，tcpdump 几乎在所有的 Linux 版本中都是可用的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">tcpdump</span> <span class="selector-tag">-i</span> <span class="selector-tag">eth0</span></span><br><span class="line"><span class="selector-tag">tcpdump</span>: <span class="selector-tag">verbose</span> <span class="selector-tag">output</span> <span class="selector-tag">suppressed</span>, <span class="selector-tag">use</span> <span class="selector-tag">-v</span> <span class="selector-tag">or</span> <span class="selector-tag">-vv</span> <span class="selector-tag">for</span> <span class="selector-tag">full</span> <span class="selector-tag">protocol</span> <span class="selector-tag">decode</span></span><br><span class="line"><span class="selector-tag">listening</span> <span class="selector-tag">on</span> <span class="selector-tag">eth0</span>, <span class="selector-tag">link-type</span> <span class="selector-tag">EN10MB</span> (<span class="selector-tag">Ethernet</span>), <span class="selector-tag">capture</span> <span class="selector-tag">size</span> 96 <span class="selector-tag">bytes</span></span><br><span class="line">22<span class="selector-pseudo">:08</span><span class="selector-pseudo">:59.617628</span> <span class="selector-tag">IP</span> <span class="selector-tag">tecmint</span><span class="selector-class">.com</span><span class="selector-class">.ssh</span> &gt; 115<span class="selector-class">.113</span><span class="selector-class">.134</span><span class="selector-class">.3</span><span class="selector-class">.static-mumbai</span><span class="selector-class">.vsnl</span><span class="selector-class">.net</span><span class="selector-class">.in</span><span class="selector-class">.28472</span>: <span class="selector-tag">P</span> 2532133365<span class="selector-pseudo">:2532133481(116)</span> <span class="selector-tag">ack</span> 3561562349 <span class="selector-tag">win</span> 9648</span><br><span class="line">22<span class="selector-pseudo">:09</span><span class="selector-pseudo">:07.653466</span> <span class="selector-tag">IP</span> <span class="selector-tag">tecmint</span><span class="selector-class">.com</span><span class="selector-class">.ssh</span> &gt; 115<span class="selector-class">.113</span><span class="selector-class">.134</span><span class="selector-class">.3</span><span class="selector-class">.static-mumbai</span><span class="selector-class">.vsnl</span><span class="selector-class">.net</span><span class="selector-class">.in</span><span class="selector-class">.28472</span>: <span class="selector-tag">P</span> 116<span class="selector-pseudo">:232(116)</span> <span class="selector-tag">ack</span> 1 <span class="selector-tag">win</span> 9648</span><br><span class="line">22<span class="selector-pseudo">:08</span><span class="selector-pseudo">:59.617916</span> <span class="selector-tag">IP</span> 115<span class="selector-class">.113</span><span class="selector-class">.134</span><span class="selector-class">.3</span><span class="selector-class">.static-mumbai</span><span class="selector-class">.vsnl</span><span class="selector-class">.net</span><span class="selector-class">.in</span><span class="selector-class">.28472</span> &gt; <span class="selector-tag">tecmint</span><span class="selector-class">.com</span><span class="selector-class">.ssh</span>: . <span class="selector-tag">ack</span> 116 <span class="selector-tag">win</span> 64347</span><br></pre></td></tr></table></figure></p>
<h3 id="netstat__u2014__u7F51_u7EDC_u7EDF_u8BA1"><a href="#netstat__u2014__u7F51_u7EDC_u7EDF_u8BA1" class="headerlink" title="netstat — 网络统计"></a>netstat — 网络统计</h3><p>netstat 命令是一个监控网络数据包传入和传出的统计界面的命令行工具。它对于许多系统管理员去监控网络性能和解决网络相关问题是一个非常有用的工具。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -a | more</span></span><br><span class="line">Active Internet connections (servers <span class="keyword">and</span> established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:mysql</span>                     *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:sunrpc</span>                    *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:realm-rusd</span>                *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:ftp</span>                       *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> localhost.<span class="symbol">localdomain:</span>ipp   *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> localhost.<span class="symbol">localdomain:</span>smtp  *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> localhost.<span class="symbol">localdomain:</span>smtp  localhost.<span class="symbol">localdomain:</span><span class="number">42709</span> TIME_WAIT</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> localhost.<span class="symbol">localdomain:</span>smtp  localhost.<span class="symbol">localdomain:</span><span class="number">42710</span> TIME_WAIT</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:http</span>                      *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:ssh</span>                       *<span class="symbol">:*</span>                         LISTEN</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:https</span>                     *<span class="symbol">:*</span>                         LISTEN</span><br></pre></td></tr></table></figure></p>
<p>(Linux Story译文这里的图片给错了，我重新从英文原文找到对应的图)</p>
<h3 id="htop__u2014__u8FDB_u7A0B_u76D1_u63A7"><a href="#htop__u2014__u8FDB_u7A0B_u76D1_u63A7" class="headerlink" title="htop — 进程监控"></a>htop — 进程监控</h3><p>htop 是一个更加先进的交互式的实时监控工具。htop 与 top 命令非常相似，但是他有一些非常丰富的功能，如用户友好界面管理进程、快捷键、横向和纵向进程等更多的。htop 是一个第三方工具并不包括在 Linux 系统中，你需要使用包管理工具进行安装。</p>
<p><img src="http://www.linuxstory.org/wp-content/uploads/2015/12/6.jpg" alt="htop"></p>
<h3 id="iotop__u2014__u76D1_u63A7_Linux__u78C1_u76D8_I/O"><a href="#iotop__u2014__u76D1_u63A7_Linux__u78C1_u76D8_I/O" class="headerlink" title="iotop — 监控 Linux 磁盘 I/O"></a>iotop — 监控 Linux 磁盘 I/O</h3><p>iotop 也是和 top 和 htop 命令相似，但是它会有一个报告功能去监控和显示实时的磁盘 I/O 输入和输出和程序进程。这个工具对于查找精确的高的磁盘读/写过程是非常有用的。</p>
<p><img src="http://www.linuxstory.org/wp-content/uploads/2015/12/7.jpg" alt="iotop"></p>
<h3 id="iostat__u2014__u8F93_u5165/_u8F93_u51FA_u7EDF_u8BA1"><a href="#iostat__u2014__u8F93_u5165/_u8F93_u51FA_u7EDF_u8BA1" class="headerlink" title="iostat — 输入/输出统计"></a>iostat — 输入/输出统计</h3><p>iostat 是收集和展示系统输入和输出存储设备统计的简单工具。这个工具通常用于查找存储设备性能问题，包括设备、本地磁盘、例如 NFS 远程磁盘。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># iostat</span><br><span class="line">Linux <span class="number">2.6.18-238</span>.<span class="number">9</span>.<span class="number">1</span>.el5 (tecmint.com)         <span class="number">09/13/2012</span></span><br><span class="line"> </span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           <span class="number">2</span>.<span class="number">60</span>    <span class="number">3</span>.<span class="number">65</span>    <span class="number">1</span>.<span class="number">04</span>    <span class="number">4</span>.<span class="number">29</span>    <span class="number">0</span>.<span class="number">00</span>   <span class="number">88</span>.<span class="number">42</span></span><br><span class="line"> </span><br><span class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</span><br><span class="line">cciss/c0d0       <span class="number">17</span>.<span class="number">79</span>       <span class="number">545</span>.<span class="number">80</span>       <span class="number">256</span>.<span class="number">52</span>  <span class="number">855159769</span>  <span class="number">401914750</span></span><br><span class="line">cciss/c0d0p1      <span class="number">0</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>       <span class="number">5459</span>       <span class="number">3518</span></span><br><span class="line">cciss/c0d0p2     <span class="number">16</span>.<span class="number">45</span>       <span class="number">533</span>.<span class="number">97</span>       <span class="number">245</span>.<span class="number">18</span>  <span class="number">836631746</span>  <span class="number">384153384</span></span><br><span class="line">cciss/c0d0p3      <span class="number">0</span>.<span class="number">63</span>         <span class="number">5</span>.<span class="number">58</span>         <span class="number">3</span>.<span class="number">97</span>    <span class="number">8737650</span>    <span class="number">6215544</span></span><br><span class="line">cciss/c0d0p4      <span class="number">0</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>         <span class="number">0</span>.<span class="number">00</span>          <span class="number">8</span>          <span class="number">0</span></span><br><span class="line">cciss/c0d0p5      <span class="number">0</span>.<span class="number">63</span>         <span class="number">3</span>.<span class="number">79</span>         <span class="number">5</span>.<span class="number">03</span>    <span class="number">5936778</span>    <span class="number">7882528</span></span><br><span class="line">cciss/c0d0p6      <span class="number">0</span>.<span class="number">08</span>         <span class="number">2</span>.<span class="number">46</span>         <span class="number">2</span>.<span class="number">34</span>    <span class="number">3847771</span>    <span class="number">3659776</span></span><br></pre></td></tr></table></figure></p>
<h3 id="IPTraf__u2014_u5B9E_u65F6IP_u5C40_u57DF_u7F51_u76D1_u63A7"><a href="#IPTraf__u2014_u5B9E_u65F6IP_u5C40_u57DF_u7F51_u76D1_u63A7" class="headerlink" title="IPTraf —实时IP局域网监控"></a>IPTraf —实时IP局域网监控</h3><p>IPTraf 是一个基于开源的 Linux 系统实时网络（IP 网络）监测的工具。它能收集到各种各样的信息，如通过网络对 IP 流量监测，包括 TCP 标志信息、ICMP 详细细节、TCP/UDP 流量故障、TCP 连接的数据包和拜恩计数。并且它还收集 TCP，UDP，ICMP，IP，非 IP，IP 校验错误，界面活性等一般信息和详细信息的接口统计数据。<br><img src="http://www.tecmint.com/wp-content/uploads/2013/02/IPTraf2.png" alt="IPtraf"></p>
<h3 id="Psacct__u6216_u8005_Acct__u2014__u76D1_u89C6_u7528_u6237_u6D3B_u52A8"><a href="#Psacct__u6216_u8005_Acct__u2014__u76D1_u89C6_u7528_u6237_u6D3B_u52A8" class="headerlink" title="Psacct 或者 Acct — 监视用户活动"></a>Psacct 或者 Acct — 监视用户活动</h3><p>Psacct 或者 Acct 是用于监测每个用户对系统的活跃状态的一个非常有用的工具。在后台有两个守护进程在运行，一个是密切关注系统上每个用户的整体活动，另一个进程关注有哪些资源被它们消耗。</p>
<p>这个工具对于系统管理员是非常有用的去跟踪每个用户的活动，可以知道用户正在做什么，发出了什么样的命令，占用了多少资源，多长时间活跃在系统上。</p>
<h3 id="Monit__u2014__u7A0B_u5E8F_u548C_u670D_u52A1_u76D1_u6D4B"><a href="#Monit__u2014__u7A0B_u5E8F_u548C_u670D_u52A1_u76D1_u6D4B" class="headerlink" title="Monit — 程序和服务监测"></a>Monit — 程序和服务监测</h3><p>这是一个免费的开源的基于 web 程序的自动监控和管理系统进程、程序、文件、目录、权限、校验文件系统。它监控的服务包括 Apache、MYSQL、Mail、FTP、Nginx 等等。系统状态是可以从命令行或者自己的网络接口来查看。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/02/Monit-Monitoring.jpg" alt="Monit"></p>
<h3 id="NetHogs__u2014__u76D1_u89C6_u6BCF_u4E2A_u8FDB_u7A0B_u7684_u7F51_u7EDC_u5E26_u5BBD"><a href="#NetHogs__u2014__u76D1_u89C6_u6BCF_u4E2A_u8FDB_u7A0B_u7684_u7F51_u7EDC_u5E26_u5BBD" class="headerlink" title="NetHogs — 监视每个进程的网络带宽"></a>NetHogs — 监视每个进程的网络带宽</h3><p>NetHogs 是一个开源的漂亮的小程序（类似于 Linux 上面的 top 命令），在您的系统上保持每个进程的网络活动状态。它也保持了一个程序或者应用实时的网络流量带宽使用情况。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/02/NetHogs-bandwidth-Monitoring.jpg" alt="NetHogs"></p>
<h3 id="iftop__u2014__u7F51_u7EDC_u5E26_u5BBD_u76D1_u63A7"><a href="#iftop__u2014__u7F51_u7EDC_u5E26_u5BBD_u76D1_u63A7" class="headerlink" title="iftop — 网络带宽监控"></a>iftop — 网络带宽监控</h3><p>iftop 是另一个基于终端的开源的系统监测工具，主要功能是通过你自己系统上的网络接口显示一个经常更新的网络带宽利用率的列表（即源主机和目的主机）。iftop 监控的是网络的使用情况，而 top 监控的是 CPU 的使用情况。iftop 监视一个选定的接口并且显示两台主机之间当前宽带的使用情况。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/04/iftop.png" alt="iftop"></p>
<h3 id="Monitorix__u2014__u7CFB_u7EDF_u548C_u7F51_u7EDC_u76D1_u63A7"><a href="#Monitorix__u2014__u7CFB_u7EDF_u548C_u7F51_u7EDC_u76D1_u63A7" class="headerlink" title="Monitorix — 系统和网络监控"></a>Monitorix — 系统和网络监控</h3><p>Monitorix 是一个尽可能多的在 Linux/Unix 上一个轻量级监控工具，主要设计是监控正在运行的系统和网络资源。它有一个内置的 HTTP web 服务去定期收集系统和网络信息并显示成图片。它可以监视系统的平均负载使用、内存的分配、磁盘驱动器、系统服务、网络端口、邮件统计（Sendmail、Postfix、Dovecot 等等）、MYSQL 数据库等等更多的服务。它的主要目的是监控整个系统的性能，并且有助于监测故障、瓶颈、异常活动等状况。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/04/Monitorix-Monitoring.png" alt="Monitorix"></p>
<h3 id="Arpwatch__u2014__u4EE5_u592A_u7F51_u6D3B_u52A8_u76D1_u63A7_u5668"><a href="#Arpwatch__u2014__u4EE5_u592A_u7F51_u6D3B_u52A8_u76D1_u63A7_u5668" class="headerlink" title="Arpwatch — 以太网活动监控器"></a>Arpwatch — 以太网活动监控器</h3><p>Arpwatch是一种用来监视 Linux 网络的以太网的网络流量的地址解析（网络地址转换）的一个程序。它一直随着网络时间戳的变化监视以太网流量和产生日志的 IP 和 MAC 地址对。当一个 IP 地址或 MAC 地址对发生变化的时候，它会发送电子邮件通知管理员。</p>
<p>并且它在检测 ARP 攻击是非常有用的。</p>
<h3 id="Suricata__u2014__u7F51_u7EDC_u5B89_u5168_u76D1_u63A7"><a href="#Suricata__u2014__u7F51_u7EDC_u5B89_u5168_u76D1_u63A7" class="headerlink" title="Suricata — 网络安全监控"></a>Suricata — 网络安全监控</h3><p>Suricata 是一个高性能的开源的网络安全与入侵检测与预防 Linux、FreeBSD、Windows 等操作系统的监控工具。它是一个非营利基金 OISF（Open Information Security Foundation）拥有的。</p>
<h3 id="VnStat_PHP__u2014__u76D1_u6D4B_u7F51_u7EDC_u5E26_u5BBD"><a href="#VnStat_PHP__u2014__u76D1_u6D4B_u7F51_u7EDC_u5E26_u5BBD" class="headerlink" title="VnStat PHP — 监测网络带宽"></a>VnStat PHP — 监测网络带宽</h3><p>VnStat PHP 是一个 web 前端应用最流行的社交工具叫“vnstat”。 VnStat PHP 使用了很好的图形模式监控网络流量的使用情况。它显示了每时、每天、每月的总结报告中的网络流量使用情况。</p>
<h3 id="Nagios__u2014__u7F51_u7EDC/_u670D_u52A1_u5668_u76D1_u63A7"><a href="#Nagios__u2014__u7F51_u7EDC/_u670D_u52A1_u5668_u76D1_u63A7" class="headerlink" title="Nagios — 网络/服务器监控"></a>Nagios — 网络/服务器监控</h3><p>Nagios 是一个领先的开源的强大的监控系统，网络/系统管理员在他们影响主要业务流程之前识别和解决服务器相关的问题。Nagios 可以监控远程 Linux、Windows、开关、单窗口的路由器和打印机。它能显示你的网络和服务器关键的告警，有利于在错误反生之前帮助你解决问题。</p>
<h3 id="Nmon__u2014__u76D1_u63A7Linux_u7CFB_u7EDF_u6027_u80FD"><a href="#Nmon__u2014__u76D1_u63A7Linux_u7CFB_u7EDF_u6027_u80FD" class="headerlink" title="Nmon — 监控Linux系统性能"></a>Nmon — 监控Linux系统性能</h3><p>Nmon（即奈吉尔性能监视器）工具用来监视 Linux 系统的所有资源包括：CPU、内存、磁盘使用率、网络上的进程、NFS、内核等等。这个工具有两个模式：即在线模式和捕捉模式。在线模式适用于实时监控，捕捉模式用于存储输出为 CSV 格式后的处理。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/12/Nmon.jpeg" alt="Nmon"></p>
<h3 id="Collectl__u2014__u4E00_u4F53_u5316_u6027_u80FD_u68C0_u6D4B_u5DE5_u5177"><a href="#Collectl__u2014__u4E00_u4F53_u5316_u6027_u80FD_u68C0_u6D4B_u5DE5_u5177" class="headerlink" title="Collectl — 一体化性能检测工具"></a>Collectl — 一体化性能检测工具</h3><p>Collectl 是另一个功能强大的基于命令行的监控工具，它可用于收集有关系统资源的信息，包括 CPU 使用率、内存、网络、节点、进程、NFS、TCP 套接等等。</p>
<p><img src="http://www.tecmint.com/wp-content/uploads/2013/12/Collectl.jpg" alt="Collectl"></p>
<h3 id="LinuxStory_u8BD1_u6587_uFF0C_u539F_u6587"><a href="#LinuxStory_u8BD1_u6587_uFF0C_u539F_u6587" class="headerlink" title="LinuxStory译文，原文"></a>LinuxStory译文，原文</h3><p><a href="http://www.linuxstory.org/command-line-tools-to-monitor-linux-performance/" target="_blank" rel="external">http://www.linuxstory.org/command-line-tools-to-monitor-linux-performance/</a><br><a href="http://www.tecmint.com/command-line-tools-to-monitor-linux-performance/" target="_blank" rel="external">http://www.tecmint.com/command-line-tools-to-monitor-linux-performance/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于每个系统管理员或网络管理员来说，每天要监控和调试 Linux 系统性能问题都是非常困难的工作。我已经有5年 Linux 管理员的工作经历，知道如何监控系统使其保持正常运行。为此，我们编写了对于 Linux/Unix 系统管理员非常有用的并且最常用的20个命令行系统监视工具。这些命令可以在所有版本的 Linux 下使用去监控和查找系统性能的实际原因。这些监控命令足够你选择适合你的监控场景。</p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
</feed>
