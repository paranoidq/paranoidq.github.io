<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[钱唯の个人博客]]></title>
  <subtitle><![CDATA[佳思忽来，书能下酒；侠情一往，云可赠人。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://paranoidq.github.io/"/>
  <updated>2016-11-29T13:45:22.000Z</updated>
  <id>http://paranoidq.github.io/</id>
  
  <author>
    <name><![CDATA[Paranoid Qian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我的书单]]></title>
    <link href="http://paranoidq.github.io/2016/11/29/just-reading/"/>
    <id>http://paranoidq.github.io/2016/11/29/just-reading/</id>
    <published>2016-11-29T13:45:07.000Z</published>
    <updated>2016-11-29T13:45:22.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/" target="_blank" rel="external">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/" target="_blank" rel="external">更多的人死于心碎</a></p>
<a id="more"></a>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/" target="_blank" rel="external">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/" target="_blank" rel="external">创业维艰</a></p>
<h3 id="u5386_u53F2"><a href="#u5386_u53F2" class="headerlink" title="历史"></a>历史</h3><p><a href="https://book.douban.com/subject/26315806/" target="_blank" rel="external">台湾往事：台湾经济改革故事</a> (完成)<br><a href="https://book.douban.com/subject/26754615/" target="_blank" rel="external">极简人类史</a> (完成)</p>
<h3 id="u79D1_u666E"><a href="#u79D1_u666E" class="headerlink" title="科普"></a>科普</h3><p><a href="https://book.douban.com/subject/1636374/" target="_blank" rel="external">人类的群星闪耀时</a></p>
<h3 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h3><p><a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">浪潮之巅</a> (完成)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/">更多的人死于心碎</a></p>]]>
    
    </summary>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Http KeepAlive的理解]]></title>
    <link href="http://paranoidq.github.io/2016/11/29/http-keepalive-vs-pipeline/"/>
    <id>http://paranoidq.github.io/2016/11/29/http-keepalive-vs-pipeline/</id>
    <published>2016-11-29T13:11:10.000Z</published>
    <updated>2016-11-29T13:18:41.000Z</updated>
    <content type="html"><![CDATA[<p>本篇结合资料，阐述了Http协议中的keep alive的理解。<br><a id="more"></a></p>
<h3 id="keepalive_u4E3A_u4EC0_u4E48_u4E0D_u80FD_u8FDE_u7EED_u53D1_u9001_u591A_u4E2A_u8BF7_u6C42_u62A5_u6587"><a href="#keepalive_u4E3A_u4EC0_u4E48_u4E0D_u80FD_u8FDE_u7EED_u53D1_u9001_u591A_u4E2A_u8BF7_u6C42_u62A5_u6587" class="headerlink" title="keepalive为什么不能连续发送多个请求报文"></a>keepalive为什么不能连续发送多个请求报文</h3><p>知乎原贴：<a href="https://www.zhihu.com/question/26515427" target="_blank" rel="external">https://www.zhihu.com/question/26515427</a></p>
<p>keepalive之前，是发出一个request,然后等待收取 response,在没有 conten-length的时候利用关闭链接的事件来判断 response接收完毕。因为那个时候网站就是一个HTML的文本，你仅仅需要请求一次就可以得到整个页面了。</p>
<p>后来,随着网页表现形式的多样化，一个页面的资源增多，构成一个页面的文件数不再是一个，为了快速加载网页(是快速，理论上你只开一个socket用完了关，再用再开也行)，同时并行地打开多个socket来获取资源(网络IO时间和页面渲染时间的比重越大，这个效果越明显)。</p>
<p>这个时候有一个问题就来了，我们为什么不在 一个socket上连续发送多个request。原因是因为HTTP1.1 及更低版本的协议，并没有一个字段用来区分一个response是归属于哪一个request的。但HTTP 2 就有这个字段了。因此在HTTP1.1 及更低版本，你只能在发送一个request之后，等待response的到来。</p>
<p>直到今日，应用最广泛的依然是HTTP1.1协议,这就造成了目前浏览器都是并行加载的,是的都是并行的。</p>
<p>在真正试图解决你的疑问的之前，我们来看一下,从发出request之前到接收respon之后，都发生了什么。</p>
<ul>
<li>你向浏览器的地址栏输入一个域名.如 <a href="http://www.zhihu.com" target="_blank" rel="external">http://www.zhihu.com</a></li>
<li>浏览器向你的本地DNS服务器请求解析该域名,即将你的<a href="http://www.zhihu.com" target="_blank" rel="external">http://www.zhihu.com</a> 解析为真实的IP地址.详细协议请查询RFC文档，其中对DNS协议的格式内容，指令意义，压缩算法，等都作出了规定。</li>
<li>拿到ip地址之后，发起TCP 握手(3次)，详情请看计算机网络TCP协议部分</li>
<li>握手成功，构造request,即 HTTP 中request请求.并发送到目的地。有关HTTP协议的内容请查阅RFC文档可以购买HTTP权威指南作为参考和释疑.</li>
<li>服务器接受到一个完整的request(该边界的指定一般是conten-length,chunked也有),根据用户的request内容运算出相应的response。</li>
<li>服务器将response 沿着request建立的连接，向浏览器(客户端)发送数据。</li>
<li>keepalive的时候不关闭该连接，没有keepalive的时候发起tcp close,4次握手</li>
<li>浏览器根据接收到的response开始渲染页面。</li>
</ul>
<p>至此，一个网页的打开过程完毕，我们从中提取出耗时的部分。</p>
<ul>
<li>DNS查询时间(一来一回,走UDP协议) 网络IO</li>
<li>tcp 建立连接握手 网络IO</li>
<li>request构造时间(cpu运算)</li>
<li>request发送完毕时间(网络IO)</li>
<li>服务器接收request运算构造response(CPU运算,特指构造response过程中没有任何IO操作)</li>
<li>服务器发送response到客户端的时间(网络IO)</li>
<li>服务器关闭连接时间(IO)</li>
<li>客户端接收数据渲染页面时间(cpu运算)。</li>
</ul>
<p>至此，一个流程就这样简单地构造完毕了。</p>
<p>好了，我们的目标是,尽可能地缩短完成一个页面加载的时间。<br>那么我们就需要不断地削减上述时间中的某一个。<br>到底什么才是最好的方案，将随着上述时间的比重不断地变化，没有什么是最优的。</p>
<p>浏览器默认的常用做法是，并行打开多个连接向服务器请求资源.（这里要注意）请求第一个页面的时候，只有一个连接(有的浏览器为了加速后面的多tcp问题，会有预连接,但是效果却因为资源不一定在一个ip上或者服务器不支持过多的连接而没有太大效果)，这里请求道的response之后解析出其关联的其他资源，才开始并行连接获取资源。</p>
<p>但是,tcp的握手和关闭是一个想当耗时,而且重复的过程(当传输速度变快的时候这个的比重相当大)，因此 keepalive的作用就是用来 复用已经打开的tcp连接.</p>
<p>这里有个数学问题，请求6个资源是，开3个连接复用三个呢,还是开6个连接,这就看情况了。</p>
<p>1.浏览器已经并行了，这个跟你想的不一样.<br>2.keepalive，是复用的意思，不是连续发出多个request.(这是HTTP1.1)，不算是串行。</p>
<p>个人看法：<br>HTTP1.1 request和response 的无标识符问题(即response无法指明是哪一个request的)，就造就了现在这种情况。HTTP 2 协议解除了这个问题。</p>
<p>HTTP 1.1，也没有一个request 多个 response的机制，没request，光有response的机制。关于这个特性HTTP 2有实现，但是争议依然比较大。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇结合资料，阐述了Http协议中的keep alive的理解。<br>]]>
    
    </summary>
    
      <category term="http" scheme="http://paranoidq.github.io/tags/http/"/>
    
      <category term="network" scheme="http://paranoidq.github.io/tags/network/"/>
    
      <category term="keepalive" scheme="http://paranoidq.github.io/tags/keepalive/"/>
    
      <category term="network" scheme="http://paranoidq.github.io/categories/network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HttpClient使用实践]]></title>
    <link href="http://paranoidq.github.io/2016/11/29/httpclient-usage-practice/"/>
    <id>http://paranoidq.github.io/2016/11/29/httpclient-usage-practice/</id>
    <published>2016-11-29T12:51:09.000Z</published>
    <updated>2016-11-29T13:37:14.000Z</updated>
    <content type="html"><![CDATA[<p>本篇主要总结在HttpClient使用过程中的最佳实践、注意点以及踩到的坑。<br><a id="more"></a></p>
<h3 id="u5305_u542B_u8FDE_u63A5_u6C60_u7684HttpClient"><a href="#u5305_u542B_u8FDE_u63A5_u6C60_u7684HttpClient" class="headerlink" title="包含连接池的HttpClient"></a>包含连接池的HttpClient</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager();</span><br><span class="line">poolingHttpClientConnectionManager.setDefaultMaxPerRoute(WcgProperties.WCG_HTTP_CLIENT_POOL_MAX_CONNECTION_PER_ROUTE);</span><br><span class="line">poolingHttpClientConnectionManager.setMaxTotal(WcgProperties.WCG_HTTP_CLIENT_POOL_MAX_CONNECTION_PER_TARGET);</span><br><span class="line"></span><br><span class="line">HttpClientBuilder clientBuilder = HttpClientBuilder.create();</span><br><span class="line">clientBuilder.setConnectionManager(poolingHttpClientConnectionManager)</span><br><span class="line">        .setConnectionTimeToLive(WcgProperties.WCG_HTTP_CLIENT_POOL_TTL, TimeUnit.SECONDS)</span><br><span class="line">        .setConnectionManagerShared(<span class="keyword">true</span>)</span><br><span class="line">        .setKeepAliveStrategy(<span class="keyword">new</span> DefaultConnectionKeepAliveStrategy() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public long getKeepAliveDuration(HttpResponse response, HttpContext context) &#123;</span><br><span class="line">            <span class="keyword">return</span> WcgProperties.WCG_HTTP_CLIENT_KEEP_ALIVE_TIMEOUT * <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">client = clientBuilder.build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否开启idle connection auto close</span></span><br><span class="line"><span class="keyword">if</span> (WcgProperties.ENABLE_IDLE_CONNECTION_AUTO_CLOSE == <span class="number">1</span>) &#123;</span><br><span class="line">    IdleConnManageUtil.closeIdleConnectionsPeriodically(poolingHttpClientConnectionManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*/</span></span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IdleConnManageUtil</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> closeIdleConnectionsPeriodically(PoolingHttpClientConnectionManager connectionManager) &#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public Thread newThread(Runnable runnable) &#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">                thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> IdleConnectionMonitorThread(connectionManager), <span class="number">60</span>, WcgProperties.WCG_HTTP_IDLE_CONNECTION_ALIVE_TIMEOUT, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>可以理解为<code>setDefaultMaxPerRoute</code>针对单个IP，<code>setMaxTotal</code>针对所有请求</li>
<li><code>setKeepAliveStrategy</code>可以自定义TCP连接KeepAlive的时间。但是需要注意的是，如果TCP连接在池中空闲的期间到期了，那么即使Server端关闭连接，Client端的这个TCP socket也感知不到。此时Server处于<code>CLOSE_WAIT</code>状态，知道TCP Socket从池中被唤醒或者超过CLOSE_WAIT时间或者被池自己关掉。当TCP被唤醒时，C端会感知到S端的关闭连接操作，因此会关闭这个TCP链路，重新建立一条链路发送下一次请求。（等于说每次request之前都会检查一下从池中取出的TCP链路是否有效，通过这个机制来保证不会出现C端拿着无效的TCP链路去请求）但是同样，以上的机制可能会导致S端有很多的<code>CLOSE_WAIT</code>状态，严重时可能造成Socket耗尽，这点需要注意。</li>
<li><code>closeIdleConnectionsPeriodically</code>是自定义函数，可以定时关闭连接池中长时间不用的连接</li>
</ul>
<h3 id="u53D1_u9001request_u7684_u51E0_u79CD_u65B9_u6CD5_u548C_u6CE8_u610F_u70B9"><a href="#u53D1_u9001request_u7684_u51E0_u79CD_u65B9_u6CD5_u548C_u6CE8_u610F_u70B9" class="headerlink" title="发送request的几种方法和注意点"></a>发送request的几种方法和注意点</h3><h4 id="u63A8_u8350_u7684_u65B9_u5F0F"><a href="#u63A8_u8350_u7684_u65B9_u5F0F" class="headerlink" title="推荐的方式"></a>推荐的方式</h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">response</span> = this.client.<span class="keyword">execute</span>(<span class="built_in">request</span>, <span class="keyword">new</span> ResponseHandler&lt;<span class="built_in">Response</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Response</span> handleResponse(HttpResponse <span class="built_in">response</span>) throws ClientProtocolException, IOException &#123;</span><br><span class="line">        return <span class="built_in">Response</span>.create(</span><br><span class="line">                <span class="built_in">response</span>.getStatusLine().getStatusCode(),</span><br><span class="line">                <span class="built_in">response</span>.getStatusLine().getReasonPhrase(),</span><br><span class="line">                HttpClient.this.getHttpResponse(</span><br><span class="line">                        IOUtils.toByteArray(<span class="built_in">response</span>.getEntity().getContent()),</span><br><span class="line">                        paramsPack)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方式下，HttpClient将会替你<strong>回收</strong>连接。这里用<strong>回收</strong>而不是销毁，是因为HttpClient在默认的情况下，是会进行连接复用的。</p>
<h4 id="u81EA_u884C_u63A7_u5236_u7684_u65B9_u5F0F"><a href="#u81EA_u884C_u63A7_u5236_u7684_u65B9_u5F0F" class="headerlink" title="自行控制的方式"></a>自行控制的方式</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpMethod <span class="function"><span class="keyword">method</span> = <span class="title">new</span> <span class="title">GetMethod</span><span class="params">(uri)</span>;</span></span><br><span class="line"><span class="keyword">try</span> <span class="comment">&#123;</span><br><span class="line">    int statusCode = httpClient.executeMethod(method);</span><br><span class="line">    byte[] responseBody = method.getResponseBody();</span><br><span class="line">    // ...</span><br><span class="line">    return stuff;</span><br><span class="line">&#125;</span> <span class="keyword">finally</span> <span class="comment">&#123;</span><br><span class="line">    method.releaseConnection();</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用<code>method.releaseConnection();</code>释放了connection使得connection对于HttpClient而言重新可用，而非真正的关闭该connection，原因在于使用了Http1.1协议，HttpClient可以在同一个connection中批量发送后续的请求。</p>
<h4 id="u81EA_u884C_u63A7_u5236_u7684_u65B9_u5F0F2"><a href="#u81EA_u884C_u63A7_u5236_u7684_u65B9_u5F0F2" class="headerlink" title="自行控制的方式2"></a>自行控制的方式2</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    CloseableHttpResponse resp = httpClient.execute(httpGet);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Do what you have to do </span></span><br><span class="line">    <span class="comment">// but make sure the response gets closed no matter what</span></span><br><span class="line">    <span class="comment">// even if do not care about its content</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        resp.close();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125; <span class="keyword">while</span> (nextPage);</span><br></pre></td></tr></table></figure>
<p>注意：必须要在finally块中调用<code>resp.close()</code>，否则这次请求会一直占用连接，不会被回收。而<strong>默认的情况下，一个正常new出来的HttpClient实例只会给一个route留2个connection</strong> [1]，因此一旦没有关闭，那么在多线程的情况下，上面的代码至多只能执行2次就会阻塞。</p>
<p>另一种释放连接的方法是：调用<code>EntityUtils.consume(resp);</code>，该函数内部会调用<code>resp.close()</code>从而释放连接。但是需要注意的是这种方式存在安全隐患，要明确resp不会过大或者是恶意的应答，从而挤爆缓冲区。最好能判断一下resp的大小，对于明显过大的应答要进行过滤。</p>
<h3 id="u53D6_u6D88request"><a href="#u53D6_u6D88request" class="headerlink" title="取消request"></a>取消request</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpGet <span class="keyword">get</span> = <span class="keyword">new</span> HttpGet();</span><br><span class="line"><span class="keyword">get</span>.abor1.</span><br></pre></td></tr></table></figure>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><ol>
<li><a href="http://stackoverflow.com/questions/22069821/apache-httpclient-4-3-3-execute-method-for-a-get-request-blocks-and-never-return" target="_blank" rel="external">http://stackoverflow.com/questions/22069821/apache-httpclient-4-3-3-execute-method-for-a-get-request-blocks-and-never-return</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇主要总结在HttpClient使用过程中的最佳实践、注意点以及踩到的坑。<br>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="httpclient" scheme="http://paranoidq.github.io/tags/httpclient/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java程序和Jvm编码机制的分析]]></title>
    <link href="http://paranoidq.github.io/2016/10/25/java-and-jvm-encoding-analysis/"/>
    <id>http://paranoidq.github.io/2016/10/25/java-and-jvm-encoding-analysis/</id>
    <published>2016-10-25T13:55:12.000Z</published>
    <updated>2016-12-11T15:32:01.000Z</updated>
    <content type="html"><![CDATA[<p>本文起源于一次测试环境下构造报文发送时对于java编码的疑惑，经过查找资料和分析总结而成。对于JVM和Java代码中的编码问题和原理进行了较为深入的分析。如有错漏，欢迎指正。</p>
<a id="more"></a>
<p>首先上一个原理图，借用自<a href="https://www.zhihu.com/question/30977092" target="_blank" rel="external">知乎</a>。个人认为非常恰当地描述了整个编码的原理，除了output部分不够详细。</p>
<p><img src="/img/java-jvm-encoding.jpg" alt="java-jvm-encoding"></p>
<h3 id="Java_u7A0B_u5E8F_u5185_u90E8_u7F16_u7801_u7684_u5206_u6790"><a href="#Java_u7A0B_u5E8F_u5185_u90E8_u7F16_u7801_u7684_u5206_u6790" class="headerlink" title="Java程序内部编码的分析"></a>Java程序内部编码的分析</h3><p>该过程的分析参考了<a href="http://blog.csdn.net/dslztx/article/details/47005107" target="_blank" rel="external">这篇文章</a>。<br><br></p>
<ol>
<li>在IDE中编写java代码然后保存，此时会根据<code>file.encoding</code>或<code>system.defaultEncoding</code>将文件编码为二进制的流，然后写入磁盘。<ul>
<li>这个过程用到了系统编码或文件编码，一般为GBK或者UTF-8等<br><br></li>
</ul>
</li>
<li>然后IDE进行编译或javac进行编译：<ul>
<li>这个过程会从磁盘读取二进制流，然后根据<code>file.encoding</code>或<code>system.defaultEncoding</code>来解码出原始文件的内容</li>
<li>可以指定解码的方式，如：<ul>
<li><code>javac -encoding utf-8 Main.java</code></li>
<li><code>maven compiler plugin中指定encoding</code></li>
</ul>
</li>
<li>然后javac编译器会将读取的文件编译为Unicode的格式，因此此时源文件中的所有字符都是Unicode编码方式存储在内存中的*.class文件中</li>
<li>然后将内存中的.class文件以二进制流的方式输入磁盘，使用系统默认编码即可（<strong>实际上，这时候不存在编码的问题了，因为都是Unicode字符</strong>）</li>
<li>需要注意的是：在简体中文的Windows上，平台默认编码会是GBK，那么<strong>javac就会默认假定输入的Java源码文件是以GBK编码的</strong>。javac能够正确读取文件内容并将其中的字符串以Unicode输出到Class文件里，就跟自己写个程序以GBK读文件以UTF-8写文件一样。如果实际输入的确实是GBK编码（GBK兼容ASCII编码）的文件，那么一切都会正常。但如果实际输入的是别的编码的文件，例如超过了ASCII范围的UTF-8，那javac读进来的内容就会出问题，就“乱码”了</li>
<li>对于任何的字符串，如String a= “我是字符串”而言，不论在java源码中以何种编码方式存在，编译为class文件之后，就全都是Unicode了。也就是，<strong>我们可以认为，源文件的编码方式丢失了</strong>。<br><br></li>
</ul>
</li>
<li><p>编译过程完成之后，运行程序，此时JVM开始载入.class文件来运行，此时，在JVM内存中的各个字符仍然是Unicode编码的方式存在</p>
</li>
<li><p>当产生output的行为时，就需要显式或隐式做编码转换的工作了，也即是<strong>从Unicode转换为另一种具体的编码</strong>。output的行为可以有多种：</p>
<ul>
<li>取得字节数组，即a.getBytes()或a.getBytes(“GBK”)。此时就从Unicode转换为了系统默认编码方式的二进制表示或指定编码方式的二进制表示</li>
<li>显示在命令行界面上，如System.out.println(a)。此时隐式调用了转换和解码，将Unicode转为了系统默认编码的二进制表示，然后利用系统默认编码方式解码出具体的字符显示出来。</li>
<li>输出为文件，同样系统默认编码方式或指定编码方式</li>
<li>网络传输</li>
<li>需要注意的是：<strong>单纯以上过程只是在Unicode和具体某种编码之间转，不会出现乱码问题</strong>。只有在不同的具体编码之间，才可能出现乱码问题。并且<strong>编码本身没有问题，乱码只会出现在需要解码的时候</strong>。<blockquote>
<p>一个典型的错误是：new String(a.getBytes(“UTF-8”), “GBK”);<br>1) 其中a.getBytes()是按照UTF-8将a在内存中的Unicode表示转换出来，也就是这是一个编码的过程，使用了UTF-8编码方式<br>2) 而new String()这个过程是将转换得到的byte[]数组用GBK解码，然后显示实际的字符<br>3) 显然会发生乱码。这个问题的关键在于，没有理解字符串在JVM内存中的表示形式，以为是UTF-8的形式存储的。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="Java_u5916_u90E8_u7F16_u7801_u7684_u5206_u6790"><a href="#Java_u5916_u90E8_u7F16_u7801_u7684_u5206_u6790" class="headerlink" title="Java外部编码的分析"></a>Java外部编码的分析</h3><p>java程序中的字符串很多来自于外部，这个时候就需要注意乱码的问题了</p>
<ul>
<li>首先，外部过来的字符串肯定是以某种编码方式编好的byte[]。数组，无论从文件读取、命令行输入还是从网络传输，本质上都是byte[]</li>
<li>java程序需要将这些byte[]读取到JVM中进行处理，也就是<strong>从具体的编码方式转换为Unicode的过程，因此提前知道数据源的编码方式才能正确转换</strong>。这点很重要，如果不指定编码方式，那么默认就会采用系统编码，此时就有可能解码解的不对。</li>
<li>尽量要使用带有明确指定编码方式的method，而不要不知情的情况下使用了系统默认的编码，否则就可能造成解码错误，解出了乱码。</li>
</ul>
<h3 id="u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="http://blog.csdn.net/jessenpan/article/details/15505515" target="_blank" rel="external">http://blog.csdn.net/jessenpan/article/details/15505515</a></li>
<li><a href="https://www.zhihu.com/question/30977092" target="_blank" rel="external">https://www.zhihu.com/question/30977092
</a></li>
<li><a href="http://bbs.csdn.net/topics/390806040" target="_blank" rel="external">http://bbs.csdn.net/topics/390806040</a></li>
<li><a href="http://xm-koma.iteye.com/blog/2074191" target="_blank" rel="external">http://xm-koma.iteye.com/blog/2074191</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文起源于一次测试环境下构造报文发送时对于java编码的疑惑，经过查找资料和分析总结而成。对于JVM和Java代码中的编码问题和原理进行了较为深入的分析。如有错漏，欢迎指正。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="基础" scheme="http://paranoidq.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="encoding" scheme="http://paranoidq.github.io/tags/encoding/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Webservice实践（3）在tomcat容器中发布webservice服务]]></title>
    <link href="http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-3/"/>
    <id>http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-3/</id>
    <published>2016-10-20T13:39:04.000Z</published>
    <updated>2016-10-25T13:31:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>在<a href="http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-2/">第一篇实践</a>中，我们讲述了如何用standalone的方式部署一个webservice服务。但是很多情况下，我们需要将webservice部署在web服务器上，因此本文实践如何在tomcat服务器上部署webservice。</p>
<p>本文中，我们将讲述web容器的两种配置部署方式，一种是<strong>基于Java Servlet的方式</strong>，一种是<strong>基于Spring框架的方式</strong>。我们知道CXF本身设计就是与Spring无缝集成的，因此基于Spring框架的方式更方便通用；但是，有时候我们也希望通过简单的servlet就能够快速搞定一个webservice的发布。</p>
 <a id="more"></a>
<h3 id="u57FA_u4E8Espring_framework"><a href="#u57FA_u4E8Espring_framework" class="headerlink" title="基于spring framework"></a>基于spring framework</h3><p>基于Spring的配置方式很简单，我们只需要关联对应的webservice bean，然后定义访问路径就可以了。</p>
<p>项目的结构类似下图：<br><img src="/img/webservice/spring-config-1.png" alt="cxf-spring-intergeration"></p>
<h4 id="Step_1"><a href="#Step_1" class="headerlink" title="Step 1"></a>Step 1</h4><p>在<code>webservice-definition-beans.xml</code>中，我们给出jaxws的endpoint的定义，配置某一个webservice的实现类以及这个服务<strong>对应于项目路径的相对URL</strong>。需要注意的是，这里可以直接写具体的实现类，而不一定需要引用<code>service-definition-beans.xml</code>中定义的bean。当然，如果统一在spring的beans定义文件中定义了，那么在webservice的xml定义中只需要简单引用一下即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:jaxws</span>=<span class="string">"http://cxf.apache.org/jaxws"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">                       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                       http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;import resource="classpath:service-definition-beans.xml"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-extension-soap.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:META-INF/cxf/cxf-servlet.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jaxws:endpoint</span> <span class="attr">id</span>=<span class="string">"webservice"</span> <span class="attr">implementor</span>=<span class="string">"com.cup.wcg.access.webservice.WcgWsImpl"</span> <span class="attr">address</span>=<span class="string">"/request"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Step_2"><a href="#Step_2" class="headerlink" title="Step 2"></a>Step 2</h4><p>配置完webservice bean的xml文件之后，配置web.xml:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;context-param&gt;</span></span><br><span class="line">    <span class="params">&lt;param-name&gt;</span>contextConfigLocation<span class="params">&lt;/param-name&gt;</span></span><br><span class="line">    <span class="params">&lt;param-value&gt;</span>WEB-INF/webservice-definition-beans.xml<span class="params">&lt;/param-value&gt;</span></span><br><span class="line"><span class="params">&lt;/context-param&gt;</span></span><br><span class="line"><span class="params">&lt;servlet&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>CXFServlet<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-class&gt;</span>org.apache.cxf.transport.servlet.CXFServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line">    <span class="params">&lt;load-on-startup&gt;</span><span class="number">1</span><span class="params">&lt;/load-on-startup&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet&gt;</span></span><br><span class="line"><span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">    <span class="params">&lt;servlet-name&gt;</span>CXFServlet<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="params">&lt;url-pattern&gt;</span><span class="meta-keyword">/ws/</span>*<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet-mapping&gt;</span></span><br><span class="line"><span class="params">&lt;listener&gt;</span></span><br><span class="line">    <span class="params">&lt;listener-class&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="params">&lt;/listener-class&gt;</span></span><br><span class="line"><span class="params">&lt;/listener&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>其中CXFServlet指明了路径到webservice的映射关系。</p>
<h3 id="u57FA_u4E8EServlet"><a href="#u57FA_u4E8EServlet" class="headerlink" title="基于Servlet"></a>基于Servlet</h3><p>参考这篇文章<a href="https://www.oschina.net/question/54100_26066" target="_blank" rel="external">https://www.oschina.net/question/54100_26066</a></p>
<h4 id="Step_1-1"><a href="#Step_1-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>继承CXFNoSpringServlet，并override其中的loadBus方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.<span class="type">ServletConfig</span>;</span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.<span class="type">Endpoint</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.cxf.transport.servlet.<span class="type">CXFNonSpringServlet</span>;</span><br><span class="line">  </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WebServiceServlet</span> <span class="keyword">extends</span> <span class="title">CXFNonSpringServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">-5314312869027558456</span>L;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void loadBus(<span class="type">ServletConfig</span> servletConfig) &#123;</span><br><span class="line">        <span class="keyword">super</span>.loadBus(servletConfig);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"#####################"</span>);</span><br><span class="line">        <span class="type">Endpoint</span>.publish(<span class="string">"/helloWorldService"</span>, <span class="keyword">new</span> <span class="type">HelloWorldServiceImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Step_2-1"><a href="#Step_2-1" class="headerlink" title="Step 2"></a>Step 2</h4><p>配置web.xml，指定webapp的URL以及对应的servlet<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;servlet&gt;</span></span><br><span class="line">  <span class="params">&lt;servlet-name&gt;</span>webservice<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">  <span class="params">&lt;servlet-class&gt;</span>com.crazycoder2010.webservice.cxf.server.servlet.WebServiceServlet<span class="params">&lt;/servlet-class&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet&gt;</span></span><br><span class="line"><span class="params">&lt;servlet-mapping&gt;</span></span><br><span class="line">  <span class="params">&lt;servlet-name&gt;</span>webservice<span class="params">&lt;/servlet-name&gt;</span></span><br><span class="line">  <span class="params">&lt;url-pattern&gt;</span><span class="meta-keyword">/webservice/</span>*<span class="params">&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="params">&lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>部署之后就可以通过<code>http://localhost:8080/CXF-Server/webservice/helloWorldService?wsdl</code>访问webservice服务了。</p>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.oschina.net/question/54100_26066" target="_blank" rel="external">https://www.oschina.net/question/54100_26066</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>在<a href="http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-2/">第一篇实践</a>中，我们讲述了如何用standalone的方式部署一个webservice服务。但是很多情况下，我们需要将webservice部署在web服务器上，因此本文实践如何在tomcat服务器上部署webservice。</p>
<p>本文中，我们将讲述web容器的两种配置部署方式，一种是<strong>基于Java Servlet的方式</strong>，一种是<strong>基于Spring框架的方式</strong>。我们知道CXF本身设计就是与Spring无缝集成的，因此基于Spring框架的方式更方便通用；但是，有时候我们也希望通过简单的servlet就能够快速搞定一个webservice的发布。</p>]]>
    
    </summary>
    
      <category term="webservice" scheme="http://paranoidq.github.io/tags/webservice/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Webservice实践（2）构建Webservice客户端]]></title>
    <link href="http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-2/"/>
    <id>http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-2/</id>
    <published>2016-10-20T13:39:04.000Z</published>
    <updated>2016-10-25T13:31:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>总体而言，构建Webservice客户端的方式有很多种，概括起来分为两个环节：客户端stub生成和调用远程服务。对于生成stub而言，主要的方式是有两种：<strong>通过wsdl静态生成然后导入客户端代码</strong>和<strong>通过Java反射机制动态生成（利用了JAXB API）</strong>。</p>
<p>动态生成这里不介绍了，介绍一下静态生成的方法，具体可以细分为以下几种：</p>
<ul>
<li>jdk1.6+/bin中自带工具: <code>wsimport</code></li>
<li>cxf/bin中的工具: <code>wsdl2java</code></li>
<li>axis/bin中工具</li>
</ul>
<p>调用的方法可以分为：</p>
<ul>
<li>通过stub静态调用</li>
<li>通过JaxWsProxyFactoryBean半动态调用</li>
<li>通过CXF动态调用：<ul>
<li>DynamicClientFactory方式（对于非JAX-WS标准）</li>
<li>JaxWsDynamicClientFactory方式（针对JAX-WS标准）</li>
</ul>
</li>
<li>通过Axis动态调用：<ul>
<li>Service.createCall()</li>
</ul>
</li>
<li>通过HTTPURLConnection的方式调用（手动组装SOAP报文）</li>
<li>通过JAX Dispatch API的方式构建SOAP报文并调用</li>
</ul>
<a id="more"></a>
<h3 id="Stub_u7684_u751F_u6210"><a href="#Stub_u7684_u751F_u6210" class="headerlink" title="Stub的生成"></a>Stub的生成</h3><h4 id="u901A_u8FC7wsimport_u751F_u6210stub"><a href="#u901A_u8FC7wsimport_u751F_u6210stub" class="headerlink" title="通过wsimport生成stub"></a>通过wsimport生成stub</h4><p>wsimport调用的方法是：<code>wsimport -d [目录] -keep -Xnocompile -verbose [wsdl]</code><br>其中<code>-d</code>后面表示生成文件存放的目录，<code>-keep</code>表示生成源文件，<code>-verbose</code>表示显示生成的详细过程，<code>-Xnocompile</code>表示不自动编译源码。<br>生成之后，导入到客户端的项目中。生成文件的结构类似下图：<br><img src="/img/webservice/wsimport.png" alt="wsimport-java-structure"></p>
<p>接着，就可以在客户端调用了<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WcgWebService serverStub = <span class="keyword">new</span> WcgWebService();</span><br><span class="line">com.up.<span class="keyword">client</span>.WcgWsInterface <span class="keyword">client</span> = serverStub.getWcgWsImplPort();</span><br><span class="line">String resp = <span class="keyword">client</span>.wsRequest(<span class="string">"service"</span>, <span class="string">"requestMsg"</span>);</span><br><span class="line">System.out.println(resp);</span><br></pre></td></tr></table></figure></p>
<h4 id="u901A_u8FC7wsdl2java_u751F_u6210"><a href="#u901A_u8FC7wsdl2java_u751F_u6210" class="headerlink" title="通过wsdl2java生成"></a>通过wsdl2java生成</h4><p>wsdl2java的调用方法与wsimport类似：<code>sh wsdl2java -d src -client http://localhost:8080/cxf-server/wcg/webservice/interface\?wsdl</code><br>其中<code>-d</code>指定输出的目录，<code>-client</code>输出客户端代码，也可以指定<code>-server</code>输出服务端代码<br>生成之后，导入客户端的项目中。生成的文件结构类似下图：<br><img src="/img/webservice/wsdl2java.png" alt="wsdl2java"></p>
<p>接着，在客户端调用如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WcgWebserviceInterface client = <span class="keyword">new</span> Webservice().getWcgWebserviceImplPort();</span><br><span class="line"><span class="keyword">String</span> requestResponse = client.request(<span class="string">"param"</span>, <span class="string">"param"</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(requestResponse);</span><br></pre></td></tr></table></figure></p>
<h4 id="u901A_u8FC7Axis_u5BA2_u6237_u7AEF_u7684_u5DE5_u5177_u751F_u6210"><a href="#u901A_u8FC7Axis_u5BA2_u6237_u7AEF_u7684_u5DE5_u5177_u751F_u6210" class="headerlink" title="通过Axis客户端的工具生成"></a>通过Axis客户端的工具生成</h4><p>TODO</p>
<h3 id="u8C03_u7528_u65B9_u5F0F"><a href="#u8C03_u7528_u65B9_u5F0F" class="headerlink" title="调用方式"></a>调用方式</h3><h4 id="u901A_u8FC7CXF_u9759_u6001_u8C03_u7528"><a href="#u901A_u8FC7CXF_u9759_u6001_u8C03_u7528" class="headerlink" title="通过CXF静态调用"></a>通过CXF静态调用</h4><p>将生成的stub引入到客户端的代码中进行调用。例如，对于通过<code>wsimport</code>生成的stub，我们可以用如下的方式调用：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UpWsAccess_Service serviceStub = <span class="keyword">new</span> UpWsAccess_Service(<span class="keyword">new</span> URL(<span class="string">"http://0.0.0.0:8080/cxf-server/ws/request?wsdl"</span>));</span><br><span class="line">UpWsAccess action = serviceStub.getUpWsAccessPort();</span><br><span class="line"><span class="built_in">Response</span> <span class="built_in">response</span> = action.<span class="built_in">request</span>(<span class="string">"demo"</span>, <span class="string">"&lt;msg&gt;&lt;/msg&gt;"</span>);</span><br><span class="line">System.out.println(<span class="string">"RETURN: ["</span> + <span class="built_in">response</span>.getStatus() + <span class="string">", "</span> + <span class="built_in">response</span>.getResponseMsg() + <span class="string">"]"</span>);</span><br></pre></td></tr></table></figure></p>
<p>其中<code>getUpWsAccessPort</code>这个方法也就是获取了webservice的某一个服务，wsdl中的每一个port代表的都是一个可供调用的服务。</p>
<p>这种方式的明显有点就是具有强类型支持，并且使用起来非常方便。并且，能够让人只管的理解webservice的本质：<code>通过客户端的stub来调用remote的服务</code>。<br>但是缺点就是比较“重量级”，需要一整套的流程。而且如果服务端的wsdl变了的话，那么客户端就需要重新生成一套新的stub了。这在变更的时候非常不方便。</p>
<p><strong>注意，导入的的stub直接使用会出现类似如下的错误：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com<span class="selector-class">.sun</span><span class="selector-class">.xml</span><span class="selector-class">.bind</span><span class="selector-class">.v2</span><span class="selector-class">.runtime</span><span class="selector-class">.IllegalAnnotationsException</span>: <span class="number">1</span> counts of IllegalAnnotationExceptions</span><br><span class="line">Two classes have the same XML type name <span class="string">"&#123;http://xxx.yyyy.com&#125;createProcessResponse"</span>. Use @XmlType<span class="selector-class">.name</span> and @XmlType<span class="selector-class">.namespace</span> to assign different names to them.</span><br><span class="line">    this problem is related to the following location:</span><br><span class="line">        at xxx<span class="selector-class">.yyy</span><span class="selector-class">.gwfp</span><span class="selector-class">.ws</span><span class="selector-class">.dto</span><span class="selector-class">.CreateProcessResponse</span></span><br><span class="line">        at private xxx<span class="selector-class">.yyy</span><span class="selector-class">.gwfp</span><span class="selector-class">.ws</span><span class="selector-class">.dto</span><span class="selector-class">.CreateProcessResponse</span> xxx<span class="selector-class">.yyy</span><span class="selector-class">.gwfp</span><span class="selector-class">.ws</span><span class="selector-class">.jaxws_asm</span><span class="selector-class">.CreateProcessResponse</span>._return</span><br><span class="line">        at xxx<span class="selector-class">.yyy</span><span class="selector-class">.gwfp</span><span class="selector-class">.ws</span><span class="selector-class">.jaxws_asm</span><span class="selector-class">.CreateProcessResponse</span></span><br><span class="line">    this problem is related to the following location:</span><br><span class="line">        at xxx<span class="selector-class">.yyy</span><span class="selector-class">.gwfp</span><span class="selector-class">.ws</span><span class="selector-class">.jaxws_asm</span><span class="selector-class">.CreateProcessResponse</span></span><br></pre></td></tr></table></figure></p>
<p>原因是JAX-WS对webservice里面得每个方法都生成一个类，生成的类名为: methodName + “Response”,所以就回导致生成的类和原来的类有两个相同的xml type。最直接的解决方法就是修改@WebService中的name属性，与类的名字不同即可。参考<a href="http://www.cnblogs.com/happyPawpaw/p/4370967.html" target="_blank" rel="external">这篇文章</a>。</p>
<h4 id="u901A_u8FC7Axis_u9759_u6001_u8C03_u7528"><a href="#u901A_u8FC7Axis_u9759_u6001_u8C03_u7528" class="headerlink" title="通过Axis静态调用"></a>通过Axis静态调用</h4><p>调用方式：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NativeUpayServiceLocator locator = new NativeUpayServiceLocator()<span class="comment">;</span></span><br><span class="line">PayFeeInfo payData = new PayFeeInfo()<span class="comment">;</span></span><br><span class="line">payData.setBusinessID(<span class="string">"123456"</span>)<span class="comment">;</span></span><br><span class="line">payData.setChargeDate(<span class="string">"20161011121212"</span>)<span class="comment">;</span></span><br><span class="line">payData.setRealPayFee(<span class="number">1231</span>.<span class="number">0</span>f)<span class="comment">;</span></span><br><span class="line">payData.setSerialNo(<span class="string">"123457"</span>)<span class="comment">;</span></span><br><span class="line">PayFeeInfo[] pay = new PayFeeInfo[<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">pay[<span class="number">0</span>] = payData<span class="comment">;</span></span><br><span class="line">PayResult result = locator.getNativeUpayPort().writePayFee(<span class="string">""</span>, <span class="string">"C0100001"</span>,pay )<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是：需要指定编码方式时，可以通过以下方式设置<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stub<span class="selector-class">._setProperty</span>(Call.CHARACTER_SET_ENCODING, <span class="string">"GBK"</span>);</span><br></pre></td></tr></table></figure></p>
<p>参考自：<a href="http://stackoverflow.com/questions/9093078/apache-axis-charset-wrong-encoding-on-tomcat" target="_blank" rel="external">http://stackoverflow.com/questions/9093078/apache-axis-charset-wrong-encoding-on-tomcat</a></p>
<h4 id="u901A_u8FC7CXF_u52A8_u6001_u8C03_u7528"><a href="#u901A_u8FC7CXF_u52A8_u6001_u8C03_u7528" class="headerlink" title="通过CXF动态调用"></a>通过CXF动态调用</h4><p>可以看出Stub调用的方式比较简单，只需要根据wsdl生成好对应的代理类就可以了，一般3-4行代码可以搞定。但是缺点就是接口不能随意改动，并且扩展起来不方便。<br>因此CXF提供了动态调用的API，利用Java反射的机制（ASM）动态解析WSDL文件并生成类，从而完成调用，这样的方式就很灵活。客户端完全不需要具体的类型信息，只需要制动调用什么方法，传递什么参数就可以了。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JaxWsDynamicClientFactory </span>clientFactory = <span class="keyword">JaxWsDynamicClientFactory.newInstance();</span><br><span class="line"></span>Client client = clientFactory.createClient(<span class="string">"http://localhost:8080/cxf-server/ws/request?wsdl"</span>)<span class="comment">;</span></span><br><span class="line">Object[] result = client.invoke(<span class="string">"request"</span>, <span class="string">"KEVIN"</span>, <span class="string">"&lt;msg&gt;adfsfsd&lt;/msg&gt;"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>JaxWsDynamicClientFactory</code>这种方式的缺点也很明显：</p>
<ul>
<li><p>首先，不能处理复杂的输入和返回(complex type)。输入类型可以进行一些指定，这点可以做到；但是对于返回类型，由于是根据wsdl动态生成的Response类，因此客户端无法通过编码的方式将Object强制转换为complex type。也就是像下面这样的方式是会包<code>ClassCastException</code>的，即使在引入了Stub生成的Response的情况下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will throw ClassCastException</span></span><br><span class="line">Response response = (Response) <span class="keyword">result</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次，由于需要解析wsdl，并且生成相应的类，因此<code>JaxWsDynamicClientFactory</code>生成客户端的开销还是比较大的，实际运行中如果不采用一定的缓存策略，那么很难处理大量请求的场景。</p>
</li>
<li>最后，虽然这种方式是动态的，但是客户端在调用的时候依然需要明确调用哪个方法，这个方法需要什么参数。从而，服务端对于接口的改动依然会影响到客户端的代码，这一点是无法避免的。正如<a href="http://stackoverflow.com/questions/16871098/ws-dynamic-client-and-complextype-parameter" target="_blank" rel="external">StackOverflow中的回答</a>一样，无论选择静态还是动态的方式，客户端一定需要知道服务调用的具体接口细节。</li>
</ul>
<p><strong>注意，在调用的时候如果使用了老版本的CXF(如2.2.12)可能会出现版本bug导致的错误：</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javacTask: 目标发行版 <span class="number">1.5</span> 与默认的源发行版 <span class="number">1.7</span> 冲突</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.IllegalStateException</span>: </span><br><span class="line">Unable to create JAXBContext <span class="keyword">for</span> generated packages: </span><br><span class="line">Provider com<span class="selector-class">.sun</span><span class="selector-class">.xml</span><span class="selector-class">.bind</span><span class="selector-class">.v2</span><span class="selector-class">.ContextFactory</span> could not be instantiated: </span><br><span class="line">javax<span class="selector-class">.xml</span><span class="selector-class">.bind</span><span class="selector-class">.JAXBException</span>: <span class="string">"com.bd.service"</span> doesnt contain ObjectFactory<span class="selector-class">.class</span> or jaxb.index</span><br></pre></td></tr></table></figure></p>
<p>解决方法可以参考<a href="http://www.yyjjssnn.cn/articles/703.html" target="_blank" rel="external">这篇文章</a>将CXF的版本进行升级，或用JDK1.6的版本。</p>
<h4 id="u901A_u8FC7CXF_u534A_u52A8_u6001_u8C03_u7528"><a href="#u901A_u8FC7CXF_u534A_u52A8_u6001_u8C03_u7528" class="headerlink" title="通过CXF半动态调用"></a>通过CXF半动态调用</h4><p>利用JaxWsProxyFactoryBean不需要生成stub，但是需要知道接口。因此我们将这种方式称为半动态的调用。例如，下面的代码只需要引入<code>UpWsAccess</code>这个服务端对应的接口即可，而不需要一整套的stub，相比静态调用的方式还是方便了不少的。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JaxWsProxyFactoryBean <span class="keyword">factory</span> = <span class="keyword">new</span> JaxWsProxyFactoryBean();</span><br><span class="line"><span class="keyword">factory</span>.setServiceClass(UpWsAccess.<span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">factory</span>.setAddress(<span class="string">"http://localhost:8080/cxf-server/ws/request"</span>);</span><br><span class="line">UpWsAccess client = (UpWsAccess) <span class="keyword">factory</span>.create();</span><br><span class="line">Response response = client.request(<span class="string">"nmdl/reqry.do"</span>, <span class="string">"&lt;msg&gt;sdfsdf&lt;/msg&gt;"</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="u901A_u8FC7Axis_u52A8_u6001_u8C03_u7528"><a href="#u901A_u8FC7Axis_u52A8_u6001_u8C03_u7528" class="headerlink" title="通过Axis动态调用"></a>通过Axis动态调用</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> namespace = <span class="string">"http://ws.wcg.unionpay.com"</span>;  <span class="comment">// 定义命名空间</span></span><br><span class="line"><span class="keyword">String</span> serviceName = <span class="string">"wcgWebService"</span>; <span class="comment">// 定义服务名</span></span><br><span class="line">QName service = <span class="keyword">new</span> QName(namespace, serviceName);</span><br><span class="line"><span class="keyword">String</span> operationName = <span class="string">"WsRequest"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Call</span> <span class="keyword">call</span> = <span class="keyword">new</span> Service().createCall();</span><br><span class="line"><span class="keyword">call</span>.setPortTypeName(service);</span><br><span class="line"><span class="keyword">call</span>.setOperationName(<span class="keyword">new</span> QName(namespace, operationName));</span><br><span class="line"><span class="keyword">call</span>.setProperty(...)</span><br><span class="line"><span class="keyword">call</span>.addParameter(<span class="string">"service"</span>, ParameterMode.IN);</span><br><span class="line"><span class="keyword">call</span>.addParameter(<span class="string">"requestMsg"</span>, ParameterMode.IN);</span><br><span class="line"><span class="keyword">call</span>.setReturnType();</span><br><span class="line">Object[] inParams = <span class="keyword">new</span> Object[]&#123;<span class="string">"demo"</span>, <span class="string">"demo"</span>&#125;;</span><br><span class="line"><span class="keyword">String</span> ret = (<span class="keyword">String</span>)<span class="keyword">call</span>.invoke(inParams);</span><br></pre></td></tr></table></figure>
<p>这种调用方式跟前文中的<code>JaxWsDynamicFactory</code>一样，只是传递参数的时候更直观了一些。缺点也是显而易见的，只能返回简单类型的response，一旦返回的是complex type，由于complex是借助于反射动态生成的，因此无法将Object强制转换为具体的类型。</p>
<h4 id="u901A_u8FC7HTTPURLConnection_u8C03_u7528"><a href="#u901A_u8FC7HTTPURLConnection_u8C03_u7528" class="headerlink" title="通过HTTPURLConnection调用"></a>通过HTTPURLConnection调用</h4><p>这种调用方式就需要手动去组装SOAP报文，是一种最为原始的方式。但其实这种方式体现除了Webservice的本质，就是SOAP + HTTP POST。只不过这种方式在便利程度和扩展性方面不是很友好。<br>具体的代码如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private static String <span class="keyword">buildSOAP() </span>&#123;</span><br><span class="line">    String soap = <span class="string">"&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:ws=\"http://ws.wcg.unionpay.com\"&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;soapenv:Header/&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;soapenv:Body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;ws:WsRequest&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;service&gt;apram&lt;/service&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;requestMsg&gt;param&lt;/requestMsg&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;/ws:WsRequest&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;/soapenv:Body&gt;\n"</span> +</span><br><span class="line">            <span class="string">"    &lt;/soapenv:Envelope&gt;"</span><span class="comment">;</span></span><br><span class="line">    return soap<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    String soap = <span class="keyword">buildSOAP();</span><br><span class="line"></span></span><br><span class="line">    HttpURLConnection connection = (HttpURLConnection) (new URL(<span class="string">"http://localhost:8080/cxf-server/ws/request?wsdl"</span>)).openConnection()<span class="comment">;</span></span><br><span class="line">    connection.setDoInput(true)<span class="comment">;</span></span><br><span class="line">    connection.setDoOutput(true)<span class="comment">;</span></span><br><span class="line">    connection.setRequestMethod(<span class="string">"POST"</span>)<span class="comment">;</span></span><br><span class="line">    connection.setRequestProperty(<span class="string">"Content-Length"</span>, String.valueOf(soap.length()))<span class="comment">;</span></span><br><span class="line">    connection.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/xop+xml; charset=utf-8; type=\"test/xml\""</span>)<span class="comment">;</span></span><br><span class="line">    connection.setRequestProperty(<span class="string">"SOAPAction"</span>, <span class="string">"xxx"</span>)<span class="comment">;</span></span><br><span class="line">    connection.setUseCaches(false)<span class="comment">;</span></span><br><span class="line">    connection.connect()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    connection.getOutputStream().write(soap.getBytes(<span class="string">"UTF-8"</span>))<span class="comment">;</span></span><br><span class="line">    connection.getOutputStream().flush()<span class="comment">;</span></span><br><span class="line">    connection.getOutputStream().<span class="keyword">close();</span><br><span class="line"></span></span><br><span class="line">    InputStream in = connection.getInputStream()<span class="comment">;</span></span><br><span class="line">    String resp = IOUtils.toString(in)<span class="comment">;</span></span><br><span class="line">    System.out.println(resp)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="u901A_u8FC7SOAPConnection_u7684_u65B9_u5F0F_u8C03_u7528"><a href="#u901A_u8FC7SOAPConnection_u7684_u65B9_u5F0F_u8C03_u7528" class="headerlink" title="通过SOAPConnection的方式调用"></a>通过SOAPConnection的方式调用</h4><p>相比于之前的HttpURLConnection方式，SOAPConnection的方式稍微高级一些，不需要通过字符串的方式手动拼报文了，SOAPConnection的API会帮你拼，你只需要做一些定制化的工作就可以了，并且可以进行一些复杂的配置。</p>
<p>参考这篇文章：<a href="http://blog.csdn.net/wanghuan203/article/details/9219565" target="_blank" rel="external">http://blog.csdn.net/wanghuan203/article/details/9219565</a></p>
<h3 id="Axis_u548CApache_u7684_u5BF9_u6BD4"><a href="#Axis_u548CApache_u7684_u5BF9_u6BD4" class="headerlink" title="Axis和Apache的对比"></a>Axis和Apache的对比</h3><table>
<thead>
<tr>
<th></th>
<th>Axis2</th>
<th>CXF</th>
</tr>
</thead>
<tbody>
<tr>
<td>目标</td>
<td>WebService引擎</td>
<td>简易的SOA框架，可以作为ESB</td>
</tr>
<tr>
<td>ws* 标准支持</td>
<td>不支持WS-Policy</td>
<td>WS-Addressing，WS-Policy， WS-RM， WS-Security，WS-I Basic Profile</td>
</tr>
<tr>
<td>数据绑定支持</td>
<td>XMLBeans、JiBX、JaxMe 、JaxBRI、ADB</td>
<td>JAXB, Aegis, XMLBeans, SDO, JiBX</td>
</tr>
<tr>
<td>spring集成</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>应用集成</td>
<td>困难</td>
<td>简单</td>
</tr>
<tr>
<td>多语言</td>
<td>支持C/C++</td>
<td>不支持</td>
</tr>
<tr>
<td>部署</td>
<td>web应用</td>
<td>嵌入式</td>
</tr>
<tr>
<td>服务监控和管理</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.cnblogs.com/holbrook/archive/2012/12/12/2814821.html" target="_blank" rel="external">http://www.cnblogs.com/holbrook/archive/2012/12/12/2814821.html</a></li>
<li><a href="http://blog.csdn.net/zolalad/article/details/31735791" target="_blank" rel="external">http://blog.csdn.net/zolalad/article/details/31735791</a></li>
<li><a href="http://stackoverflow.com/questions/16871098/ws-dynamic-client-and-complextype-parameter" target="_blank" rel="external">http://stackoverflow.com/questions/16871098/ws-dynamic-client-and-complextype-parameter</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h3><p>总体而言，构建Webservice客户端的方式有很多种，概括起来分为两个环节：客户端stub生成和调用远程服务。对于生成stub而言，主要的方式是有两种：<strong>通过wsdl静态生成然后导入客户端代码</strong>和<strong>通过Java反射机制动态生成（利用了JAXB API）</strong>。</p>
<p>动态生成这里不介绍了，介绍一下静态生成的方法，具体可以细分为以下几种：</p>
<ul>
<li>jdk1.6+/bin中自带工具: <code>wsimport</code></li>
<li>cxf/bin中的工具: <code>wsdl2java</code></li>
<li>axis/bin中工具</li>
</ul>
<p>调用的方法可以分为：</p>
<ul>
<li>通过stub静态调用</li>
<li>通过JaxWsProxyFactoryBean半动态调用</li>
<li>通过CXF动态调用：<ul>
<li>DynamicClientFactory方式（对于非JAX-WS标准）</li>
<li>JaxWsDynamicClientFactory方式（针对JAX-WS标准）</li>
</ul>
</li>
<li>通过Axis动态调用：<ul>
<li>Service.createCall()</li>
</ul>
</li>
<li>通过HTTPURLConnection的方式调用（手动组装SOAP报文）</li>
<li>通过JAX Dispatch API的方式构建SOAP报文并调用</li>
</ul>]]>
    
    </summary>
    
      <category term="webservice" scheme="http://paranoidq.github.io/tags/webservice/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Webservice实践（1）构建简单的Webservice服务]]></title>
    <link href="http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-1/"/>
    <id>http://paranoidq.github.io/2016/10/20/java-webservice-tutorial-1/</id>
    <published>2016-10-20T12:45:04.000Z</published>
    <updated>2016-10-25T11:32:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="JAX-WS"><a href="#JAX-WS" class="headerlink" title="JAX-WS"></a>JAX-WS</h3><p>JAX-WS(Java API for XML Web Services)，是SOAP协议的一个Java的实现规范，这个新规范是为了简化基于SOAP的Java开发。JAX-WS规范其实就是一组XMLweb services的JAVA API，JAX-WS允许开发者可以选择RPCoriented或者message-oriented来实现自己的web services。通过使用Java™ API for XMLWeb Services (JAX-WS) 技术设计和开发 Web服务，可以带来很多好处，能简化 Web 服务的开发和部署，并能加速 Web 服务的开发。</p>
<p>JAX-WS将本地的远程调用转换为XML协议（一般为SOAP格式），从而开发者不需要编写任何SOAP组装消息代码；同样，在服务端的JAX-WS会将SOAP消息解析为具体的函数调用，并返回结果。</p>
<p><img src="/img/webservice/jax-ws-tutorials.gif" alt="jax-runtime"></p>
<a id="more"></a>
<h3 id="u5B9E_u73B0_u4E00_u4E2Awebservice_u7684_u9700_u8981_u7684_u5927_u81F4_u6D41_u7A0B"><a href="#u5B9E_u73B0_u4E00_u4E2Awebservice_u7684_u9700_u8981_u7684_u5927_u81F4_u6D41_u7A0B" class="headerlink" title="实现一个webservice的需要的大致流程"></a>实现一个webservice的需要的大致流程</h3><ol>
<li>服务端，定义服务接口（SEI: service endpoint interface）,并提供相关的实现类（SIB: service implementation bean）</li>
<li>通过JAX-WS服务API接口发布为webservice服务，从而可以产生一个公开的?wsdl网页，能够访问到提供了哪些服务</li>
<li><p>客户端通过JAX-WS的API根据公开的wsdl生成本地的代理（Stub）来实现对于远程方法的调用，调用过程就像在调用本地方法一样，JAX-WS Runtime会处理SOAP报文组装和网络传输等底层细节</p>
<p>当然，JAX-WS 也提供了一组针对底层消息进行操作的API调用，你可以通过Dispatch 直接使用SOAP消息或XML消息发送请求或者使用Provider处理SOAP或XML消息。</p>
</li>
</ol>
<h3 id="u4E00_u4E2A_u7B80_u5355_u7684_u5B9E_u73B0"><a href="#u4E00_u4E2A_u7B80_u5355_u7684_u5B9E_u73B0" class="headerlink" title="一个简单的实现"></a>一个简单的实现</h3><h4 id="u9996_u5148_u5B9A_u4E49_u63A5_u53E3_uFF1A"><a href="#u9996_u5148_u5B9A_u4E49_u63A5_u53E3_uFF1A" class="headerlink" title="首先定义接口："></a>首先定义接口：</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com<span class="selector-class">.up</span><span class="selector-class">.ws</span><span class="selector-class">.server</span>;</span><br><span class="line"></span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.WebMethod</span>;</span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.WebParam</span>;</span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.WebResult</span>;</span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.WebService</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @author paranoidq</span><br><span class="line"> * @since 0.1</span><br><span class="line"> */</span></span><br><span class="line"><span class="variable">@WebService</span>(targetNamespace = <span class="string">"http://ws.wcg.unionpay.com"</span>)</span><br><span class="line">public interface WcgWsInterface &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@WebMethod</span>(operationName = <span class="string">"WsRequest"</span>)</span><br><span class="line">    <span class="variable">@WebResult</span>(name = <span class="string">"WsResponse"</span>)</span><br><span class="line">    String request(<span class="variable">@WebParam</span>(name = <span class="string">"service"</span>) String service, <span class="variable">@WebParam</span>(name = <span class="string">"requestMsg"</span>) String requestMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>这里定义了targetNamespace, 如果没有定义，则默认为该类的包名</li>
<li>用@WebMethod注解来指定了operationName，如果没有指定，则操作名默认为方法名</li>
<li>用@WebResult定义了返回值的名字，如果没有指定，默认为response</li>
<li>用@WebParamd定义了参数名字，如果没有指定，默认为param1（或arg1？）</li>
</ol>
<p>实际上，这些注解提高了wsdl的可读性。</p>
<h4 id="u5B9A_u4E49_u5B9E_u73B0_u7C7B"><a href="#u5B9A_u4E49_u5B9E_u73B0_u7C7B" class="headerlink" title="定义实现类"></a>定义实现类</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com<span class="selector-class">.up</span><span class="selector-class">.ws</span><span class="selector-class">.server</span>;</span><br><span class="line"></span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.WebService</span>;</span><br><span class="line">import javax<span class="selector-class">.jws</span><span class="selector-class">.soap</span><span class="selector-class">.SOAPBinding</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @author paranoidq</span><br><span class="line"> * @since 0.1</span><br><span class="line"> */</span></span><br><span class="line"><span class="variable">@WebService</span>(endpointInterface = <span class="string">"com.up.ws.server.WcgWsInterface"</span>, serviceName = <span class="string">"wcgWebService"</span>, targetNamespace = <span class="string">"http://ws.wcg.unionpay.com"</span>)</span><br><span class="line"><span class="variable">@SOAPBinding</span>(style = SOAPBinding.Style.DOCUMENT)</span><br><span class="line">public class WcgWsImpl implements WcgWsInterface &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public String request(String service, String requestMsg) &#123;</span><br><span class="line">        return "hello world";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里指定了实现类对应的接口，以及服务名。同时，指定了SOAPBinding的类型。<br>一般而言，SOAP消息的格式有两种：RPC和DOCUMENT。(<strong>后面再理解区别</strong>)</p>
<h4 id="u53D1_u5E03_u63A5_u53E3"><a href="#u53D1_u5E03_u63A5_u53E3" class="headerlink" title="发布接口"></a>发布接口</h4><p>这里我们采用两种简单的方式发布接口</p>
<ol>
<li><p>第一种方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IHelloServices impl = <span class="keyword">new</span> WcgWsImpl();  </span><br><span class="line"><span class="comment">// 创建WebServices服务接口  </span></span><br><span class="line">WcgWsInterface <span class="keyword">factory</span> = <span class="keyword">new</span> JaxWsServerFactoryBean();  </span><br><span class="line"><span class="comment">// 注册webservices接口  </span></span><br><span class="line"><span class="keyword">factory</span>.setServiceClass(WcgWsInterface.<span class="keyword">class</span>);  </span><br><span class="line"><span class="comment">// 发布接口  </span></span><br><span class="line"><span class="keyword">factory</span>.setAddress(<span class="string">"http://localhost:8090/webservice"</span>);  </span><br><span class="line"><span class="keyword">factory</span>.setServiceBean(impl);  </span><br><span class="line"><span class="comment">// 创建服务  </span></span><br><span class="line"><span class="keyword">factory</span>.create();</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种方式：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Endpoint<span class="selector-class">.publish</span>(<span class="string">"http://localhost:8090/webservice"</span>, new WcgWsImpl());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>发布之后，我们就可以通过<code>http://localhost:8090/webservice?wsdl</code>查看提供的服务了。<br>需要注意的是：CXF看上去没有在tomcat容器中运行，其实还是有容器的，而容器就是jetty。因此，需要我们在pom文件中包含相应的依赖。这里列出所有的依赖：(利用Endpoint的方式发布的时候，不需要<code>cxf-rt-frontend-jaxws</code>这个依赖)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-discovery<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>20040218.194635<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-transports-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-frontend-jaxws<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.cxf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cxf-rt-transports-http-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：<code>cxf-rt-transports-http-jetty</code>这个依赖一定要包含，否则会出现<code>CXF BusException No DestinationFactory for Namespace: http://cxf.apache.org/transport/http</code>的错误, 参考：<br><a href="http://stackoverflow.com/questions/24447280/cxf-busexception-no-destinationfactory-for-namespace-http-cxf-apache-org-trans" target="_blank" rel="external">http://stackoverflow.com/questions/24447280/cxf-busexception-no-destinationfactory-for-namespace-http-cxf-apache-org-trans</a></p>
<p>这样我们的一个webservice就构建好了。<br>下一篇将讲解如何构建客户端来访问我们的服务。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="JAX-WS"><a href="#JAX-WS" class="headerlink" title="JAX-WS"></a>JAX-WS</h3><p>JAX-WS(Java API for XML Web Services)，是SOAP协议的一个Java的实现规范，这个新规范是为了简化基于SOAP的Java开发。JAX-WS规范其实就是一组XMLweb services的JAVA API，JAX-WS允许开发者可以选择RPCoriented或者message-oriented来实现自己的web services。通过使用Java™ API for XMLWeb Services (JAX-WS) 技术设计和开发 Web服务，可以带来很多好处，能简化 Web 服务的开发和部署，并能加速 Web 服务的开发。</p>
<p>JAX-WS将本地的远程调用转换为XML协议（一般为SOAP格式），从而开发者不需要编写任何SOAP组装消息代码；同样，在服务端的JAX-WS会将SOAP消息解析为具体的函数调用，并返回结果。</p>
<p><img src="/img/webservice/jax-ws-tutorials.gif" alt="jax-runtime"></p>]]>
    
    </summary>
    
      <category term="webservice" scheme="http://paranoidq.github.io/tags/webservice/"/>
    
      <category term="webservice" scheme="http://paranoidq.github.io/categories/webservice/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NoHttpResponseException问题分析]]></title>
    <link href="http://paranoidq.github.io/2016/10/17/NoHttpResponseException-problem-analysis/"/>
    <id>http://paranoidq.github.io/2016/10/17/NoHttpResponseException-problem-analysis/</id>
    <published>2016-10-17T02:11:30.000Z</published>
    <updated>2016-10-17T02:21:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h3><p>在性能测试的时候，使用apache httpclient连续发送报文到server进行压测。压测的配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总数：10000</span><br><span class="line">并发：400</span><br><span class="line">每个发送线程的QPS限制：20</span><br></pre></td></tr></table></figure></p>
<p>出现的问题是： 大概1000左右的报文会出现 <code>NoHttpResponseException [server ip] failed to respond</code>。调低并发度到300一下时，不会出现这样的异常。<br><a id="more"></a></p>
<h3 id="u539F_u56E0_u5206_u6790"><a href="#u539F_u56E0_u5206_u6790" class="headerlink" title="原因分析"></a>原因分析</h3><p>查阅相关资料，官方对于<code>NoHttpResponseException</code>解释是：</p>
<blockquote>
<p>In some circumstances, usually when under heavy load, the web server may be able to receive requests but unable to process them. A lack of sufficient resources like worker threads is a good example. This may cause the server to drop the connection to the client without giving any response. HttpClient throws NoHttpResponseException when it encounters such a condition. In most cases it is safe to retry a method that failed with NoHttpResponseException.</p>
</blockquote>
<p>大致意思跟我之前构想的一样，在某些情况下，通常在重负载下时，Web服务器可能能够接收请求，但无法处理它们。缺乏足够的资源，比如工作线程，这可能会导致服务器断开客户端连接，并且没有给予任何回应。当它遇到这样的条件HttpClient会抛出NoHttpResponseException。此异常是由于服务器端过载而拒绝接受请求（不再响应）所致。<br>但是细想，为什么服务端会drop掉连接呢？首先贴一则查阅到的stackoverflow上的分析：</p>
<blockquote>
<p>Most likely persistent connections that are kept alive by the connection manager become stale. That is, the target server shuts down the connection on its end without HttpClient being able to react to that event, while the connection is being idle, thus rendering the connection half-closed or ‘stale’. Usually this is not a problem. HttpClient employs several techniques to verify connection validity upon its lease from the pool. Even if the stale connection check is disabled and a stale connection is used to transmit a request message the request execution usually fails in the write operation with SocketException and gets automatically retried. However under some circumstances the write operation can terminate without an exception and the subsequent read operation returns -1 (end of stream). In this case HttpClient has no other choice but to assume the request succeeded but the server failed to respond most likely due to an unexpected error on the server side.</p>
</blockquote>
<p>大致含义：httpclient的连接一般由一个poolConnectionManager管理，而往往会有keep-alive的设置，即保持这个连接多久。但是当server端主动关闭连接的时候，由于<strong>Connection可能处于idle状态，因此pool没有通知到HttpClient对应的connection，从而造成了connection处于半关闭的状态</strong>。<br>因此在这种状态下，之后connection从pool中被唤醒或取出，然后发送报文在某些情况下write会在没有报异常的情况下结束，然后httpclient尝试从connection中read应答时返回了-1（注意，不是没有返回，否则应该是WaitTimeoutException）。httpclient认为server返回了应答，但实际上没有，因此抛出了NoHttpResponseException异常。</p>
<p>进一步思考：为什么server会主动关闭Connection呢？如果是处理能力有限，那么应该更加利用connection才对，而不应该主动drop。我的思考如下：</p>
<blockquote>
<p>1.假设server的连接限制是10，那么显然，如果现在只有5个请求来了，那么会创建5个connection。<br>2.如果现在来了20个请求，那么显然server是处理不过来的</p>
</blockquote>
<h3 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-__u589E_u52A0_u670D_u52A1_u5668_u5904_u7406_u80FD_u529B"><a href="#1-__u589E_u52A0_u670D_u52A1_u5668_u5904_u7406_u80FD_u529B" class="headerlink" title="1. 增加服务器处理能力"></a>1. 增加服务器处理能力</h4><p>这种方法在我们的项目中有效，我们通过修改JBoss服务器的两个参数来达到增强服务器处理能力的效果：</p>
<ul>
<li>maxThreads 最大线程数</li>
<li>acceptCount 最大等待线程数</li>
</ul>
<p>Jboss的线程模型：（引用自<a href="http://blog.csdn.net/lengyuhong/article/details/6319069" target="_blank" rel="external">http://blog.csdn.net/lengyuhong/article/details/6319069
</a>）<br><img src="/img/jboss-thread-model.gif" alt="jboss-thread-model"></p>
<h4 id="2-_retry"><a href="#2-_retry" class="headerlink" title="2. retry"></a>2. retry</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClientBuilder.setRetryHandler(<span class="keyword">new</span> StandardHttpRequestRetryHandler(<span class="number">3</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<h4 id="3-__u9650_u5236keepAlive_u7684_u65F6_u95F4"><a href="#3-__u9650_u5236keepAlive_u7684_u65F6_u95F4" class="headerlink" title="3. 限制keepAlive的时间"></a>3. 限制keepAlive的时间</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ConnectionKeepAliveStrategy connectionKeepAliveStrategy = new ConnectionKeepAliveStrategy() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) &#123;</span><br><span class="line">            return <span class="number">20</span> * <span class="number">1000</span><span class="comment">; // tomcat默认keepAliveTimeout为20s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(<span class="number">20</span>, TimeUnit.SECONDS)<span class="comment">;</span></span><br><span class="line">connManager.setMaxTotal(<span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">connManager.setDefaultMaxPerRoute(<span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">    .setConnectTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .setSocketTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .setConnectionRequestTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .<span class="keyword">build();</span><br><span class="line"></span>HttpClientBuilder httpClientBuilder = HttpClientBuilder.create()<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setConnectionManager(connManager)<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setDefaultRequestConfig(requestConfig)<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler())<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setKeepAliveStrategy(connectionKeepAliveStrategy)<span class="comment">;</span></span><br><span class="line">HttpClient httpClient = httpClientBuilder.<span class="keyword">build();</span><br><span class="line"></span>ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient)<span class="comment">;</span></span><br><span class="line">restTemplate = new RestTemplate(requestFactory)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>主要是增加keepalive的策略，但这又带来一个问题，所有的连接只有20秒，无法使用长连接的性能优势</p>
<h4 id="4-_closeIdleConnections"><a href="#4-_closeIdleConnections" class="headerlink" title="4. closeIdleConnections"></a>4. closeIdleConnections</h4><p>PoolingHttpClientConnectionManager.closeIdleConnections 方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">closeIdleConnections</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> idleTimeout, <span class="keyword">final</span> TimeUnit tunit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.log.debug(<span class="string">"Closing connections idle longer than "</span> + idleTimeout + <span class="string">" "</span> + tunit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pool.closeIdle(idleTimeout, tunit);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三种方案暂且列出，准备实践一下效果，后续再更新到博客中来。相比而言，retry的方案比较sb，但是估计很好用；keepAlive限制需要考虑场景，某些需要长连接的场景下可能不是很合适，并且把统一把连接过期关掉，显然会带来不小的性能损失。最后一种方案，应该是keepAlive的折中优化，本质上是如果connection一直被pool拿出来使用，那我就不关闭你；如果connection一直idle，那么过了一段时间我就主动关闭你了。这样就避免了keepAlive统一限制的问题，同时如果一个connection被pool拿出来用了，那么显然他不可能被server关闭；而idle connection被关闭了，所以不会出现上述server端drop connection而pool又无法通知idle connection的问题。</p>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://my.oschina.net/sannychan/blog/485677" target="_blank" rel="external">https://my.oschina.net/sannychan/blog/485677</a></li>
<li><a href="http://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception" target="_blank" rel="external">http://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception</a></li>
<li><a href="http://stackoverflow.com/questions/10570672/get-nohttpresponseexception-for-load-testing/10680629#10680629" target="_blank" rel="external">http://stackoverflow.com/questions/10570672/get-nohttpresponseexception-for-load-testing/10680629#10680629</a></li>
<li><a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/" target="_blank" rel="external">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></li>
<li><a href="http://luan.iteye.com/blog/1820054" target="_blank" rel="external">http://luan.iteye.com/blog/1820054</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h3><p>在性能测试的时候，使用apache httpclient连续发送报文到server进行压测。压测的配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总数：10000</span><br><span class="line">并发：400</span><br><span class="line">每个发送线程的QPS限制：20</span><br></pre></td></tr></table></figure></p>
<p>出现的问题是： 大概1000左右的报文会出现 <code>NoHttpResponseException [server ip] failed to respond</code>。调低并发度到300一下时，不会出现这样的异常。<br>]]>
    
    </summary>
    
      <category term="httpclient" scheme="http://paranoidq.github.io/tags/httpclient/"/>
    
      <category term="tcp" scheme="http://paranoidq.github.io/tags/tcp/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[(翻译) Using HttpClient properly to avoid CLOSE_WAIT TCP connections]]></title>
    <link href="http://paranoidq.github.io/2016/10/11/Using-HttpClient-properly-to-avoid-CLOSE-WAIT-TCP-connections/"/>
    <id>http://paranoidq.github.io/2016/10/11/Using-HttpClient-properly-to-avoid-CLOSE-WAIT-TCP-connections/</id>
    <published>2016-10-11T12:46:41.000Z</published>
    <updated>2016-10-11T13:26:29.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/" target="_blank" rel="external">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></p>
<p>在我帮助我的客户debug一个TCP connection关于CLOSE_WAIT状态的问题时，我发现我们错误的使用了HttpClient。在这个问题上，如果你试图google <a href="http://www.google.com/search?q=HttpClient+CLOSE_WAIT" target="_blank" rel="external">HttpClient CLOSE_WAIT</a>，你会发现很多人跟我们一样存在疑惑。但是关于这个问题，很多的解答不够直观，甚至<a href="http://hc.apache.org/httpclient-legacy/tutorial.html" target="_blank" rel="external">官方文档</a>都是错误的。所以我在这篇文章中进行了分析。</p>
<p>Apache HttpClient的基本用法如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpMethod <span class="function"><span class="keyword">method</span> = <span class="title">new</span> <span class="title">GetMethod</span><span class="params">(uri)</span>;</span></span><br><span class="line"><span class="keyword">try</span> <span class="comment">&#123;</span><br><span class="line">    int statusCode = httpClient.executeMethod(method);</span><br><span class="line">    byte[] responseBody = method.getResponseBody();</span><br><span class="line">    // ...</span><br><span class="line">    return stuff;</span><br><span class="line">&#125;</span> <span class="keyword">finally</span> <span class="comment">&#123;</span><br><span class="line">    method.releaseConnection();</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>但事实上，这是不够的。问题在于释放connection使得connection对于HttpClient而言重新可用，而非真正的关闭该connection，原因在于使用了Http1.1协议，HttpClient可以在同一个connection中批量发送后续的请求(?)。</p>
<p>尽管，server端可能单向关闭了连接，但是客户端的connection还是打开的，并且一直持续到下一次尝试从connection中读报文时（此时，客户端才会意识到服务端已经关闭了这个连接）。TCP就是采用这种方式工作的。上面的情况我们称之为<code>半关闭的连接</code>，<strong>因为close()操作仅仅意味着我不会再往发送任何数据了，但是我还是可以从已经“closed”的连接中读取数据，只要另一端没有调用这个close()操作。</strong>[译注: 理解这一点非常重要]</p>
<p>因此，当HttpClient实例超过作用域的时候，它会被GC标记为可回收状态，但是GC并不会立即回收它。在GC真正回收它之前，HttpClient内部的connection仍然处于打开的状态，此时的TCP状态就处于CLOSE-WAIT。</p>
<p>为了解决这个问题，最简单的方法是在调用method之前设置如下代码：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">method</span>.<span class="title">setRequestHeader</span><span class="params">("Connection", "close")</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>这会导致HttpClient在接受完应答报文之后立即关闭connection。</p>
<p>另外一个方法是在finally块中添加如下代码：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient<span class="selector-class">.getHttpConnectionManager</span>()<span class="selector-class">.closeIdleConnections</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>效果应该跟上面的一样，都是让connection在idle之后立即销毁connection。</p>
<p>更好的方法是：不要每次都new HttpClient，而重用经过<code>MultiThreadedHttpConnectionManager</code>配置的一个client实例。当然，这种情况下，就需要最终记得清理MultiThreadedHttpConnectionManager。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MultiThreadedHttpConnectionManager connectionManager;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">HttpClient</span> httpClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> init() &#123;</span><br><span class="line">    connectionManager = <span class="keyword">new</span> MultiThreadedHttpConnectionManager()</span><br><span class="line">    <span class="comment">// ... configure connectionManager ...</span></span><br><span class="line">    httpClient = <span class="keyword">new</span> <span class="built_in">HttpClient</span>(connectionManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">shutdown</span>() &#123;</span><br><span class="line">    connectionManager.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">process</span>(<span class="keyword">String</span> uri) &#123;</span><br><span class="line">    HttpMethod method = <span class="keyword">new</span> GetMethod(uri);</span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> statusCode = httpClient.executeMethod(method);</span><br><span class="line">        <span class="keyword">byte</span>[] responseBody = method.getResponseBody();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">return</span> stuff;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        method.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></p>
<p>在我帮助我的客户debug一个TCP connection关于CLOSE_WAIT状态的问题时，我发现我们错误的使用了HttpClient。在这个问题上，如果你试图google <a href="http://www.google.com/search?q=HttpClient+CLOSE_WAIT">HttpClient CLOSE_WAIT</a>，你会发现很多人跟我们一样存在疑惑。但是关于这个问题，很多的解答不够直观，甚至<a href="http://hc.apache.org/httpclient-legacy/tutorial.html">官方文档</a>都是错误的。所以我在这篇文章中进行了分析。</p>
<p>Apache HttpClient的基本用法如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpMethod <span class="function"><span class="keyword">method</span> = <span class="title">new</span> <span class="title">GetMethod</span><span class="params">(uri)</span>;</span></span><br><span class="line"><span class="keyword">try</span> <span class="comment">&#123;</span><br><span class="line">    int statusCode = httpClient.executeMethod(method);</span><br><span class="line">    byte[] responseBody = method.getResponseBody();</span><br><span class="line">    // ...</span><br><span class="line">    return stuff;</span><br><span class="line">&#125;</span> <span class="keyword">finally</span> <span class="comment">&#123;</span><br><span class="line">    method.releaseConnection();</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="httpclient" scheme="http://paranoidq.github.io/tags/httpclient/"/>
    
      <category term="tcp" scheme="http://paranoidq.github.io/tags/tcp/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转载：大棋局与大智慧 —— 《时寒冰说》豆瓣书评]]></title>
    <link href="http://paranoidq.github.io/2016/08/26/%E6%97%B6%E5%AF%92%E5%86%B0%E8%AF%B4-%E8%B1%86%E7%93%A3%E8%AF%84%E8%AE%BA/"/>
    <id>http://paranoidq.github.io/2016/08/26/时寒冰说-豆瓣评论/</id>
    <published>2016-08-26T05:21:30.000Z</published>
    <updated>2016-10-21T02:17:54.000Z</updated>
    <content type="html"><![CDATA[<p>《时寒冰说：经济大棋局，我们怎么办》是一部窥透世界大棋局的智慧之作，也是一部还原真相，普及常识的启蒙之作，时寒冰在书中淋漓尽致的演绎了他的利益与趋势分析法。</p>
<p>赵汀阳说，思想的主体部分虽然是知识，但思想的奠基部分却是智慧，尽管我们无法保证那些代表智慧的观念是真理。① 全球化时代，智慧的稀缺使得信息爆炸与思想贫乏成为最具讽刺意义的矛盾，而中国的现状尤为突出。时下，主旋律的和谐之音，左派救亡图存的革命论调，右派改革体制的变法主张，由“左右之争”②衍生出的国家主义、民族主义、民粹主义意识形态以及专靠胡说八道混饭吃的砖家叫兽的大放厥词③,可谓“五色令人目盲，五音令人耳聋，五味令人口爽” ④。可见，比通货膨胀更可怕的是信息爆炸和思想贫乏导致的大脑膨胀，我们需要用智慧来稀释膨胀。<br><a id="more"></a></p>
<p>时寒冰说：经济大棋局，我们怎么办》透过政治、经济、金融、军事等纷繁复杂的乱象，紧扣全球范围内货币迅猛膨胀与资源日益减少所造成的“资源为王”和债务危机并存这一条主线，指出经济大棋局的本质就是主要经济体转嫁债务危机的博弈，这既是经济大棋局的结论，也是趋势分析的起点。在此基础上，作者给出了“我们怎么办”的答案。具体而言，对于国家，只有贯彻“资源为王”和“藏富于民”的战略才可化解危机，对于个人，只有“固化财富”才可避免财富的不断缩水。本书中，时寒冰将“良性的制度”纳入“资源为王”的战略之中，这样以来“资源为王”战略包括了保护现有资源，通过技术创新提高资源的附加值，通过优良的制度和环境确保资源最大限度发挥效用三个方面，依次涵盖了资源命脉、技术创新、制度保障三个层面，由此可见，时寒冰的思想体系已初具雏形。虽然该书尚算不上纯正的思想之作，但这种先融天地于一炉⑤，再抽丝剥茧，化繁为简，进而窥透大棋局的才华和境界，非大智慧者不能有。这种大智慧不仅体现在作者对各种知识和多家思想的驾驭上，更体现在作者用绝大多数人都能接受的常识完成了对大棋局的推理和演绎。</p>
<p>在经济大棋局中，货币战争、石油战争、粮食危机，中东危机、朝韩危机、人民币升值、汇率操纵、贸易战只是大棋局中居于不同节点的一个个棋子。美国不仅因为其经济军事势力，更因为深谙“资源为王”之道，因此在整个大棋局中，始终掌握着主动权。虽然，美国是世界上债务危机最严重的国家，但每当危机出现时，要么引爆欧元区某个主权国家的债务危机，要么制造中东危机，操纵国际油价，要么通过压迫人民币升值或汇率战，迫使中国政府送上采购订单，这些屡试不爽的招数，既转移了视线，也转移了危机，更重要的是为寻找新的经济增长点争取了时间，如金融危机后奥巴马政府的新能源战略，既是稀释美元泡沫的“海绵”，也是美国主导下一轮经济周期的货币之锚。相反，西班牙等“笨猪五国”自身经济的脆弱，日本巨额债务的内生性及社会的老龄化，中国的体制弊端和内需不足，都成为悬挂在各自债务危机头顶的达摩克利斯之剑，因此，未来的变数必然发生在这些国家。正因为大智慧窥透了大棋局的本质，因此，时寒冰在解读已经发生的事情时总是得心应手，在预测即将发生的事情时绝不模棱两可，这是智者和学者的区别，前者有卓越的智慧，后者只有渊博的知识。</p>
<p>在对经济大棋局分析论证的逻辑体系中，地缘政治学、意识形态、宗教信仰、国家主义、民族主义、体制改革、“阴谋论”则成为时寒冰演绎利益分析法的一个个“棋子”。近年来“阴谋论”甚嚣尘上，何新⑥、刘军洛⑦、郎咸平⑧等人从不同角度阐述华尔街和美国政府合谋控制全世界特别控制中国的阴谋，而布热津斯基早在10多年前就提出建立美国在世界范围内战略大棋局的构想⑨。但如果回归常识，战略和阴谋不过是一枚硬币的两面。大棋局中，掌握主动权者，棋局只是自己的战略，而被动承受者，棋局则是别人的阴谋。但无论阴谋还是战略，我们所能做的只有反省自身的不足并加以修正，唯有此才可能绝处逢生，这也是时寒冰贯穿全书的基本格调，正是这种超越利益，尊重常识的智者情怀，才有本书中对各种思想批判吸收后让其成为利益分析的一道道工具，也才有用常识还原真相的启蒙意义。比如，作者对“破窗理论”的批判，对美国在对外扩张中兼顾意识形态和国家利益的分析，对民主体制有利于促进财富创造的论断，都是超越意识形态和利益羁绊的常识启蒙。</p>
<p>智者总是独孤悲壮的，当抽丝剥茧后发现中国的经济问题并不在经济本身，而在经济之外，这对一个智者而言，是一种既尴尬又无奈的结果，或许只有在字里行间对民主制度不吝赞美，对领导人政治智慧满怀期望，对人应常怀爱心、公心大声呼唤。权力至上，蔑视常识与规则，缺乏信仰，投机盛行，这是中国国家性、国民性的基本“土壤”，我非常赞同乔良将军关于土壤的改造重于制度移植的观点⑩，但对制度的批判，对常识的启蒙本身就是对土壤的改造，所以，当时寒冰用他的智慧窥透经济大棋局，并告诉我们应该怎么办的时候，作为一名先知，他的使命就已经完成了，剩下的就是接受启蒙的每个人的行动。正如作者书中所言：“良性机制是大棋局中至关重要的保障。如果我们的制度也完善起来，中国将不惧怕任何挑战和博弈，而这，需要每个个体的努力。每个人都不应该简单的做一个等待者，而应该是一个推动者、行动者。”</p>
<h3 id="u6CE8_u91CA_uFF1A"><a href="#u6CE8_u91CA_uFF1A" class="headerlink" title="注释："></a>注释：</h3><p>①赵汀阳：《每个人的政治》，社会科学文献出版社。</p>
<p>②张宏良在《当前中国左派和右派的斗争》、《中华民族再次到了最危险的时候》等文章中，提出新“左派”、“右派”概念，并打出毛泽东思想的旗帜，反对资本主义和平演变的“颜色革命”。本文除有说明外，所引“左”“右”，仅是从革命与改良路径选择上的“左”“右”区分。</p>
<p>③“砖家叫兽”本是一个错别“词”，但用拼音输入后，第一个选项竟然就是“砖家叫兽”，不得不发出“时势造错字”的感叹。思考我们身边的现象，一条道路，今天建，明天拆，这竟然是砖家叫兽的“破冰理论”，岂不知这是在用消灭今天的财富来恢复本来就存在的财富。</p>
<p>④老子，《道德经·德经第十二章》。本文寓指今天中国思想界的混乱，这种混乱因本身的极端功利化，尚不等于思想的多元化。“五色”指种种丑恶离奇的乱像，“五音”指狭隘的民族主义、民粹主义、国家主义；被政治化的“左”“右”之争，以及被妖魔化的“阴谋论”等；“五味”指因为价值观与信仰迷失，人们行为的普遍功利化。</p>
<p>⑤《时寒冰说：经济大棋局，我们怎么办》一书中，政治、经济、金融、军事、历史、宗教等无所不包，地缘政治、阴谋论等或经典或流行的思想流派均有涉及。因此，本书被普遍认为是一本“小百科全书”。</p>
<p>⑥何新在《统治世界：神秘共济会揭秘》中分析指出，世界上存在一个集金融、政治和意识形态于一身，隐秘遥控着重大国际事件，并企图通过生物战争等方式消灭世界上“垃圾人口”的共济会。</p>
<p>⑦刘军洛在《被绑架的中国经济》、《高等文化的控制》等书中分析指出，美国对外经济扩展是由跨国公司、军火商、农场主、华尔街、美国政府组成的多维一体的立体作战模式，而最重要的手段就是培植利益代言人，让这些代言人给国民“洗脑”，从而达到通过文化控制实现战略利益的目标。</p>
<p>⑧郎咸平在《新帝国主义在中国》等书中分析指出，华尔街和国家机器默契配合，开始侵吞中国民族工业和优质企业。</p>
<p>⑨美国当代著名的战略思想家，美国总统前国家安全事务助理布热津斯基博士在20世纪90年代所著的《大棋局:美国的首要地位及其地缘战略》将欧亚大陆视为美国全球战略构想的关键区域。</p>
<p>⑩乔良在《时寒冰说：经济大棋局，我们怎么办》序言《悲壮的先知》结尾指出，国家性、国民性是构成制度和体制的土壤，不改变土壤结构去移植体制或制度，是本末倒置。</p>
<h3 id="u539F_u6587_u94FE_u63A5_uFF1A"><a href="#u539F_u6587_u94FE_u63A5_uFF1A" class="headerlink" title="原文链接："></a>原文链接：</h3><p><a href="https://book.douban.com/review/4980808/" target="_blank" rel="external">https://book.douban.com/review/4980808/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《时寒冰说：经济大棋局，我们怎么办》是一部窥透世界大棋局的智慧之作，也是一部还原真相，普及常识的启蒙之作，时寒冰在书中淋漓尽致的演绎了他的利益与趋势分析法。</p>
<p>赵汀阳说，思想的主体部分虽然是知识，但思想的奠基部分却是智慧，尽管我们无法保证那些代表智慧的观念是真理。① 全球化时代，智慧的稀缺使得信息爆炸与思想贫乏成为最具讽刺意义的矛盾，而中国的现状尤为突出。时下，主旋律的和谐之音，左派救亡图存的革命论调，右派改革体制的变法主张，由“左右之争”②衍生出的国家主义、民族主义、民粹主义意识形态以及专靠胡说八道混饭吃的砖家叫兽的大放厥词③,可谓“五色令人目盲，五音令人耳聋，五味令人口爽” ④。可见，比通货膨胀更可怕的是信息爆炸和思想贫乏导致的大脑膨胀，我们需要用智慧来稀释膨胀。<br>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="趋势" scheme="http://paranoidq.github.io/tags/%E8%B6%8B%E5%8A%BF/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux服务器性能调优常用工具及实例]]></title>
    <link href="http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/"/>
    <id>http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/</id>
    <published>2016-08-01T16:37:17.000Z</published>
    <updated>2016-08-01T17:00:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="u663E_u793A_u6307_u5B9A_u7528_u6237"><a href="#u663E_u793A_u6307_u5B9A_u7528_u6237" class="headerlink" title="显示指定用户"></a>显示指定用户</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ps -u root</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line"><span class="number">7</span> ?        00:<span class="number">00</span>:<span class="number">00</span> events/<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29"><a href="#ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29" class="headerlink" title="ps 与grep 组合使用，查找特定进程 (常用)"></a>ps 与grep 组合使用，查找特定进程 (常用)</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep ssh</span><br><span class="line">root      <span class="number">2720</span>     <span class="number">1</span>  <span class="number">0</span> Nov02 ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="regexp">/usr/</span>sbin/sshd</span><br><span class="line">root     <span class="number">17394</span>  <span class="number">2720</span>  <span class="number">0</span> <span class="number">14</span>:<span class="number">58</span> ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="string">sshd:</span> root<span class="meta">@pts</span>/<span class="number">0</span></span><br><span class="line">root     <span class="number">17465</span> <span class="number">17398</span>  <span class="number">0</span> <span class="number">15</span>:<span class="number">57</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep ssh</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09"><a href="#u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09" class="headerlink" title="列出目前所有的正在内存中的程序 (常用）"></a>列出目前所有的正在内存中的程序 (常用）</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line"><span class="symbol">USER</span>       <span class="symbol">PID</span> <span class="comment">%CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></span><br><span class="line">root         <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">10368</span>   <span class="number">676</span> ?        <span class="symbol">Ss</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> init [<span class="number">3</span>]</span><br><span class="line">root         <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">1</span>]</span><br><span class="line">root         <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>输出含义：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USER：该 <span class="keyword">process</span> 属于那个使用者账号的</span><br><span class="line">PID ：该 <span class="keyword">process</span> 的号码</span><br><span class="line">%CPU：该 <span class="keyword">process</span> 使用掉的 CPU 资源百分比</span><br><span class="line">%MEM：该 <span class="keyword">process</span> 所占用的物理内存百分比</span><br><span class="line">VSZ ：该 <span class="keyword">process</span> 使用掉的虚拟内存量 (Kbytes)</span><br><span class="line">RSS ：该 <span class="keyword">process</span> 占用的固定的内存量 (Kbytes)</span><br><span class="line">TTY ：该 <span class="keyword">process</span> 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/<span class="number">0</span> 等等的，则表示为由网络连接进主机的程序。</span><br><span class="line">STAT：该程序目前的状态，主要的状态有</span><br><span class="line">R ：该程序目前正在运作，或者是可被运作</span><br><span class="line">S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (<span class="keyword">signal</span>) 唤醒。</span><br><span class="line">T ：该程序目前正在侦测或者是停止了</span><br><span class="line">Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</span><br><span class="line">START：该 <span class="keyword">process</span> 被触发启动的时间</span><br><span class="line"><span class="built_in">TIME</span> ：该 <span class="keyword">process</span> 实际使用 CPU 运作的时间</span><br><span class="line">COMMAND：该程序的实际指令</span><br></pre></td></tr></table></figure></p>
<h4 id="ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B"><a href="#ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B" class="headerlink" title="ps -ef与 ps aux的区别"></a>ps -ef与 ps aux的区别</h4><p><code>ps aux</code>最初用到Unix Style中，而<code>ps -ef</code>被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。</p>
<p><code>ps aux</code>中与<code>ps -ef</code>不同的列有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER      <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">%CPU</span>      <span class="comment">//进程占用的CPU百分比</span></span><br><span class="line"><span class="built_in">%MEM</span>      <span class="comment">//占用内存的百分比</span></span><br><span class="line">VSZ       <span class="comment">//该进程使用的虚拟內存量（KB）</span></span><br><span class="line">RSS       <span class="comment">//该进程占用的固定內存量（KB）（驻留中页的数量）</span></span><br><span class="line">STAT      <span class="comment">//进程的状态</span></span><br><span class="line">START     <span class="comment">//该进程被触发启动时间</span></span><br><span class="line">TIME      <span class="comment">//该进程实际使用CPU运行的时间</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>STAT</code>状态为的常见字符有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">D</span>      <span class="comment">//无法中断的休眠状态（通常 IO 的进程）；</span></span><br><span class="line"><span class="keyword">R</span>      <span class="comment">//正在运行可中在队列中可过行的；</span></span><br><span class="line"><span class="keyword">S</span>      <span class="comment">//处于休眠状态；</span></span><br><span class="line">T      <span class="comment">//停止或被追踪；</span></span><br><span class="line"><span class="keyword">W</span>      <span class="comment">//进入内存交换 （从内核2.6开始无效）；</span></span><br><span class="line"><span class="keyword">X</span>      <span class="comment">//死掉的进程 （基本很少见）；</span></span><br><span class="line">Z      <span class="comment">//僵尸进程；</span></span><br><span class="line">&lt;      <span class="comment">//优先级高的进程</span></span><br><span class="line">N      <span class="comment">//优先级较低的进程</span></span><br><span class="line"><span class="keyword">L</span>      <span class="comment">//有些页被锁进内存；</span></span><br><span class="line"><span class="keyword">s</span>      <span class="comment">//进程的领导者（在它之下有子进程）；</span></span><br><span class="line"><span class="keyword">l</span>      <span class="comment">//多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；</span></span><br><span class="line">+      <span class="comment">//位于后台的进程组；</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat"><a href="#u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat" class="headerlink" title="查看端口情况 netstat"></a>查看端口情况 netstat</h3><h4 id="u5217_u51FA_u6240_u6709_u8FDE_u63A5"><a href="#u5217_u51FA_u6240_u6709_u8FDE_u63A5" class="headerlink" title="列出所有连接"></a>列出所有连接</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -a</span><br><span class="line">Active Internet connections (servers <span class="keyword">and</span> established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">enlightened:</span>domain      *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ipp           *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">54750</span> li24<span class="number">0</span>-<span class="number">5</span>.members.<span class="symbol">li:</span>http ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">49980</span> del01s07-<span class="keyword">in</span>-f14.<span class="number">1</span><span class="symbol">:https</span> ESTABLISHED</span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ip6-<span class="symbol">localhost:</span>ipp       [<span class="symbol">:</span><span class="symbol">:</span>]<span class="symbol">:*</span>                  LISTEN </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t"><a href="#u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t" class="headerlink" title="列出tcp/udp连接 <code>-u</code>和<code>-t</code>"></a>列出tcp/udp连接 <code>-u</code>和<code>-t</code></h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -at</span><br><span class="line"><span class="variable">$ </span>netstat -au</span><br></pre></td></tr></table></figure>
<h4 id="u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n"><a href="#u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n" class="headerlink" title="禁用反向域名解析，加快查询速度 <code>-n</code>"></a>禁用反向域名解析，加快查询速度 <code>-n</code></h4><p>没有必要知道主机名，就使用 -n 选项禁用域名解析功能<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -ant</span><br></pre></td></tr></table></figure></p>
<h4 id="u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l"><a href="#u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l" class="headerlink" title="只列出监听中的端口 <code>-l</code>"></a>只列出监听中的端口 <code>-l</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tnl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN</span><br></pre></td></tr></table></figure>
<p>不要使用<code>-a</code>，否则linux会列出所有端口，而不只是监听（LISTEN）端口</p>
<h4 id="u53EA_u5217_u51FAactive_u7AEF_u53E3"><a href="#u53EA_u5217_u51FAactive_u7AEF_u53E3" class="headerlink" title="只列出active端口"></a>只列出active端口</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -atnp | grep ESTA</span><br><span class="line">(<span class="keyword">Not</span> all processes could be identified, non-owned process info</span><br><span class="line"> will <span class="keyword">not</span> be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">49156</span>       <span class="number">173.255</span><span class="meta">.230</span><span class="meta">.5</span>:<span class="number">80</span>        ESTABLISHED <span class="number">1691</span>/chrome     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">33324</span>       <span class="number">173.194</span><span class="meta">.36</span><span class="meta">.117</span>:<span class="number">443</span>      ESTABLISHED <span class="number">1691</span>/chrome</span><br></pre></td></tr></table></figure>
<p>active 状态的套接字连接用 “ESTABLISHED” 字段表示</p>
<h4 id="u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p"><a href="#u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p" class="headerlink" title="列出进程名，进程号和用户ID <code>-p</code>"></a>列出进程名，进程号和用户ID <code>-p</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo netstat -nlpt</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">1144</span>/dnsmasq    </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">661</span>/cupsd       </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN      <span class="number">661</span>/cupsd</span><br></pre></td></tr></table></figure>
<p>必须要root权限才能显示！如果没有root需要查看端口对应的进程，请参考<code>lsof</code><br><code>-ep</code>选项可以同时查看进程名和用户名</p>
<h4 id="u5B9E_u6218"><a href="#u5B9E_u6218" class="headerlink" title="实战"></a>实战</h4><ol>
<li>查看服务是否运行<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo netstat -aple | grep ntp</span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span>ntp   *<span class="symbol">:*</span>     root       <span class="number">17430</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ntp           *<span class="symbol">:*</span>     root       <span class="number">17429</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:ntp</span>                   *<span class="symbol">:*</span>     root       <span class="number">17422</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp6       <span class="number">0</span>      <span class="number">0</span> <span class="symbol">fe80:</span><span class="symbol">:</span><span class="number">216</span><span class="symbol">:</span><span class="number">36</span><span class="symbol">ff:</span><span class="symbol">fef8:</span>ntp [<span class="symbol">:</span><span class="symbol">:</span>]    root       <span class="number">17432</span>       <span class="number">1789</span>/ntpd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<!--more-->
<ol>
<li><p>查看端口号的占用情况</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an <span class="string">| grep 12000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结合<code>watch</code>监控active状态的连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch <span class="_">-d</span> -n0 <span class="string">"netstat -atnp | grep ESTA"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="u9644_uFF1Awatch_u547D_u4EE4"><a href="#u9644_uFF1Awatch_u547D_u4EE4" class="headerlink" title="附：watch命令"></a>附：watch命令</h4><p>watch可以帮助使用者监测一个命令的运行结果，避免重复手动运行。watch命令会周期执行<br>参数：</p>
<ul>
<li>-n 时间间隔，缺省值为2s</li>
<li>-d 高亮显示变化区域</li>
<li>-t 关闭watch命令在顶部的时间间隔</li>
</ul>
<p>实例：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每隔一秒高亮显示http链接数的变化情况</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">1</span> -d <span class="string">'pstree|grep http'</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>秒一次输出系统的平均负载</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">10</span> <span class="string">'cat /proc/loadavg'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B"><a href="#u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B" class="headerlink" title="查看使用CPU\MEM最多的进程"></a>查看使用CPU\MEM最多的进程</h3><h3 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="external">ps</a><br><a href="https://linux.cn/article-2434-1.html" target="_blank" rel="external">netstat</a><br><a href="http://www.cnblogs.com/peida/archive/2012/12/31/2840241.html" target="_blank" rel="external">watch</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BASE64换行符的坑]]></title>
    <link href="http://paranoidq.github.io/2016/08/01/base64-newline-trap/"/>
    <id>http://paranoidq.github.io/2016/08/01/base64-newline-trap/</id>
    <published>2016-08-01T13:29:38.000Z</published>
    <updated>2016-10-25T12:47:26.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>
<a id="more"></a>
<h3 id="u95EE_u9898_u7684_u5206_u6790"><a href="#u95EE_u9898_u7684_u5206_u6790" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>问题在于为什么发送方的报文会多出来<code>/r/n</code>呢？</p>
<h4 id="Step_1"><a href="#Step_1" class="headerlink" title="Step 1"></a>Step 1</h4><p>首先看回车和换行符的区别：</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>     于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>      后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“ &lt;回车&gt;&lt;换 行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打 开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p>
</blockquote>
<p>所以导致的问题应该就是client端是windows系统，而我们这边处理的系统在linux下，因此就会有<code>/r/n</code>的问题。</p>
<h4 id="Step_2"><a href="#Step_2" class="headerlink" title="Step 2"></a>Step 2</h4><p>OK，让对方去掉报文中的换行之后，问题还是存在。而且还有新的发现：</p>
<blockquote>
<p>BASE64之后，当字符串过长（一般超过76）时会自动在中间加一个换行符。及时我们自己测试的报文完全没有任何换行存在。</p>
</blockquote>
<p>于是想办法去研究<code>sun.misc.BASE64Encoder</code>的源码，有了一些发现。</p>
<p>BASE64主要调用的方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"abcd"</span>.getBytes();</span><br><span class="line">BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">encoder.encodeBuffer(bytes);</span><br></pre></td></tr></table></figure></p>
<p>encodeBuffer源码的大致情况：(大部分源码位于<code>BASE64Encoder</code>的父类<code>CharacterEncoder</code>中)<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> encodeBuffer(<span class="built_in">byte</span> aBuffer[]) &#123;</span><br><span class="line">    ByteArrayOutputStream   outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ByteArrayInputStream    inStream = <span class="keyword">new</span> ByteArrayInputStream(aBuffer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        encodeBuffer(inStream, outStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception IOException) &#123;</span><br><span class="line">        <span class="comment">// This should never happen.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"CharacterEncoder.encodeBuffer internal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (outStream.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode bytes from the input stream, and write them as text characters</span><br><span class="line"> * to the output stream. This method will run until it exhausts the</span><br><span class="line"> * input stream, but does not print the line suffix for a final</span><br><span class="line"> * line that is shorter than bytesPerLine().</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> encode(InputStream inStream, OutputStream outStream)</span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">int</span>     j;</span><br><span class="line">    <span class="built_in">int</span>     numBytes;</span><br><span class="line">    <span class="built_in">byte</span>    tmpbuffer[] = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesPerLine()];</span><br><span class="line"></span><br><span class="line">    encodeBufferPrefix(outStream); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        numBytes = readFully(inStream, tmpbuffer);</span><br><span class="line">        <span class="keyword">if</span> (numBytes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeLinePrefix(outStream, numBytes); </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numBytes; j += bytesPerAtom()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((j + bytesPerAtom()) &lt;= numBytes) &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, bytesPerAtom());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, (numBytes)- j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numBytes &lt; bytesPerLine()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encodeLineSuffix(outStream); <span class="comment">// 这一行会输出换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    encodeBufferSuffix(outStream); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode the suffix that ends every output line. By default</span><br><span class="line"> * this method just prints a &lt;newline&gt; into the output stream.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> encodeLineSuffix(OutputStream aStream) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    pStream.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>encodeLineSuffix</code>会输出换行。也就是每次读满一个buffer大小的时候，都会输出一个换行。buffer的大小是由<code>bytesPerLine()</code>函数决定的，该函数是一个抽象函数，由子类实现。而在BASE64Encoder中，该函数的返回值为57.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * this class encodes 57 bytes per line. This results in a maximum</span><br><span class="line"> * of 57/3 * 4 or 76 characters per output line. Not counting the</span><br><span class="line"> * line termination.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bytesPerLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://stackoverflow.com/questions/9341047/carriage-return-issue-decoding-base64-from-java-and-sending-to-browser" target="_blank" rel="external">StackOverflow上有回答</a>这是做了一种<code>chunking</code>，在每一个<code>chunk</code>后面添加了<code>/n</code>。并且sun的库函数只存在于oracle的jvm下面，而不存在于其他jvm中。</p>
<h3 id="Step_3"><a href="#Step_3" class="headerlink" title="Step 3"></a>Step 3</h3><p><code>encode</code>与<code>encodeBuffer</code>有细微的区别：<code>encodeBuffer</code>会在最后一行不足<code>bytesPerline()</code>时添加一个换行符，而encode则不会做处理。</p>
<p>貌似很坑爹，做了如此多的隐含处理，让调用者想死的心都有了。</p>
<h3 id="u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5"><a href="#u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5" class="headerlink" title="一劳永逸的办法"></a>一劳永逸的办法</h3><p>建议使用<code>org.apache.commons.codec.binary.Base64</code>库：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base<span class="number">64.</span>e<span class="symbol">ncodeBase64</span><span class="comment">(..)</span>;</span><br><span class="line">Base<span class="number">64.</span>decodeBase<span class="number">64</span><span class="comment">(..)</span></span><br></pre></td></tr></table></figure></p>
<p>并且该库显示指明了，你是否需要<code>chunk</code>选项和<code>urlsafe</code>选项（避免输出<code>+</code>和<code>/</code>，而是输出<code>-</code>和<code>_</code>）：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeBase64Chunked(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData)</span><br><span class="line">encodeBase64(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData, <span class="keyword">final</span> <span class="keyword">boolean</span> isChunked)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="base64" scheme="http://paranoidq.github.io/tags/base64/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人已经破产，靠还没倒闭的行业活着（转载）]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/%E4%B8%AA%E4%BA%BA%E5%B7%B2%E7%BB%8F%E7%A0%B4%E4%BA%A7/"/>
    <id>http://paranoidq.github.io/2016/07/25/个人已经破产/</id>
    <published>2016-07-25T13:14:31.000Z</published>
    <updated>2016-10-21T02:10:59.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd" target="_blank" rel="external">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>
<a id="more"></a>
<h3 id="u4E8C"><a href="#u4E8C" class="headerlink" title="二"></a>二</h3><p>想起当年电视台如日中天炙手可热的时候，我领教过的一个台里员工。那位负责灯光的人被称为“灯爷”，对别人永远是颐指气使的口吻，对自己永远觉得含着天大的委屈，找他做最简单的事情都得陪着笑脸，而他做最分内的事情都觉得是别人在给他添麻烦。</p>
<p>更可怕的是，我们都对这样的大爷习以为常。他老人家稍微嘴脸好看点儿，手脚勤快点儿，便觉得是恩赐。</p>
<p>直到后来见识了一位香港“灯爷”：永远不用你操心、催促，在规定的时间内到位，黑着脸不许别人碰他的器材，手脚麻利地快速解决一切事情，工作成效之高、之专业，几乎都让你意识不到他的存在。</p>
<p>再看我们这位爷，遇到潜在的金主，想给自己捞点野活挣点外快，就倨傲又殷勤地给人家递名片：我是中央台的。</p>
<p>那时的我年轻气盛，看到这一幕，鄙夷地想：把你名片上“中央电视台”那几个字划掉，你什么也不是。</p>
<h3 id="u4E09"><a href="#u4E09" class="headerlink" title="三"></a>三</h3><p>这些年，中国房地产行业空前繁荣。建筑师这个职业，应该是机会大大的，挣钱多多的，心里美美的吧。</p>
<p>一位建筑界的老师却对我说，高歌猛进的房地产行业，还有那些地标式的公共建筑，不仅对城市、对环境造成破坏，对公众审美形成摧残，还把一代建筑师给毁了。</p>
<p>我吃惊地问为什么。他的要点是：因为活儿太多，素质不高的设计师也可以有干不完的单子应接不暇；因为钱太好挣，许多建筑师没有了自我提高的主动与自觉；因为工程太赶，缺乏原创、智慧含量和时间成本越少的设计成为首选，行业的水准线便越来越低。</p>
<p>一位做建筑图书的出版业同行，准备引进一套欧洲建筑丛书，全套有二三百本，囊括了当代建筑的各位大师，全面呈现其作品和建筑理念。我想当然地认为这套书会很好卖，因为它本来口碑就好，建筑装饰类图书又永远在书店里占据相当比重，中国的建筑设计行业人多，钱多，需求又大。</p>
<p>她说给我的发行量却低得惊人。这套书只引进了十几种，原来宏伟的出版计划看来会中途夭折。</p>
<p>她的观点也是：大家的学习动力没有了，因为钱太容易挣。一个建筑师不用看这些书，照样有挣不完的钱。</p>
<p>一个行业的繁荣，对个人来说是好事还是坏事？</p>
<h3 id="u56DB"><a href="#u56DB" class="headerlink" title="四"></a>四</h3><p>我们去年签下一套英文书的版权，写人类伟大的历史文化遗迹。因为它和建筑有很大关系，所以我想邀请建筑界的专家——外语又好、又懂建筑的人来翻译。</p>
<p>找到一位人脉广的老师求助，他说，你可能在建筑界找不到人。没人愿意接你的活儿。你看，能够胜任翻译的人，得是具备一定能力和资历的人。一本书的翻译至少要几个月的时间，稿费最多几万块钱，可人家用几个晚上时间画建筑图纸，就能挣几万块。</p>
<p>我说，这不正好吗？用几天时间画图，把几万块钱挣出来，那不就没有后顾之忧，更能踏踏实实、专心致志搞翻译了吗？</p>
<p>你这个逻辑太自作多情了，也把你的书看得太重要了。人家想的是，花几个月时间来翻译你这本书的话，就意味着耽误了画多少图、失去了挣多少钱的机会。并且这种活儿都还排着队等他来接呢，谁还稀罕为你翻译，谁算不明白这笔账呢？</p>
<p>一个人都温饱无忧了，何必还为挣钱，把自己搞得连翻译一本书这么有乐趣的事都不做呢？我兀自不甘心地咕哝。</p>
<p>有了小房子还要改善性住宅，有了大房子还要弄别墅。永远挣不完的钱，永远画不完的图。大家的时间，都用来赶这些行活了。</p>
<p>好吧，我之蜜糖，彼之砒霜。</p>
<h3 id="u4E94"><a href="#u4E94" class="headerlink" title="五"></a>五</h3><p>改革开放三十多年，破产的公司、机构不计其数，但中国几百家出版社，好像自始至终没有一家倒闭的。</p>
<p>行业的繁荣或依赖政策形成的稳定，会给一些鱼龙混杂、蜂拥而入的从业人员造成错觉，相信自己可以高枕无忧不思进取，甚至以为自己“亦有贡献”。可在危机来临之前，一个人的能力储备、职业素养、知识更新、自我成长，会自觉地被激发、强调出来么？</p>
<p>写到这里，我突然有一种担心：这些永不倒闭的出版社，已经把一些编辑养残，自我破产了。</p>
<p>我们有没有勇气和清醒，独立于外部环境和行业冷暖，明白自己要做些什么？</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="社会" scheme="http://paranoidq.github.io/categories/%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生新阶段随笔（1）]]></title>
    <link href="http://paranoidq.github.io/2016/07/15/%E4%BA%BA%E7%94%9F%E6%96%B0%E9%98%B6%E6%AE%B5%E9%9A%8F%E7%AC%94-1/"/>
    <id>http://paranoidq.github.io/2016/07/15/人生新阶段随笔-1/</id>
    <published>2016-07-15T12:02:53.000Z</published>
    <updated>2016-07-15T12:45:30.000Z</updated>
    <content type="html"><![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>
<a id="more"></a>
<p>说道知识和技能，这个其实是我不太满意的地方。虽说之前可能也有心理准备，但是进入到公司才发现，国企确实在技术上的发展不够好，或者说不够有技术的激情。当然，已经工作多年的前辈肯定是比我懂得多，但总感觉整个技术开发中心的氛围不够好，这点可能真的无法跟互联网公司相比。不过，其实互联网公司的技术其实也就集中于几个核心的部门，其他大部分也都是完成业务而已。这点上，在EMC这样的外企实习过的同事其实还蛮有发言权的。因此，<strong>公司可能只是一个平台，更多的还是要考自己去主动地学习和探索。问题其实天天都会有，就看你愿不愿意花时间去学了</strong>。</p>
<p>工作的同事其实还是蛮nice的，大家人都非常随和，没有传统国企那种等级森严的感觉。虽然有些师兄已经工作了近十年了，但是还是可以跟我们聊得很好。当然，我之前定下的目标就是要努力处理好自己的人事关系，目前看来还算不错，基本上跟组里的同事相处的很好，能够主动跟他们交流。搁过去的话，我估计还不会有这样的表现，所以算是步入社会之后强迫自己的一种改变吧。能够跟各种人正常的交往也算是一种极为重要的生活技能。</p>
<p>目前组里做的东西说白了就是适配，适配各种行业和机构的接口。本质上，这东西其实还是有一定技术含量的，不过就我目前研究的线上系统WCG的源码来看，写的确实不怎么样，感觉连我这个在校生都不如，各种magic number随便乱写，配置也随便乱写，系统模块和类设计不合理的地方很多。所以目前我的想法是能够重构这个系统，感觉如果能够进行下去的话，应该是一次难得的学习机会，毕竟无论是个人技术成长还是将来跳槽，这都是一个有利的加分项。而<strong>难点在于，如何设计一个好的系统架构，并且考虑到测试成本的问题，系统重构的过程需要尽量的step-by-step，类似于持续集成吧</strong>。这方面，在没有人带我的情况下，感觉是最困难的地方了。架构的问题，可能需要我上网查阅很多资料，如果能够有人请教的话就最好了。而关于重构成本的问题，这估计也是领导最为关心的问题，所以我接下来要做的工作应该是<strong>证明系统重构能够带来很大的好处，并且尽量减小重构对于目前运行的功能的稳定性影响</strong>。</p>
<p>跳槽的问题其实也是这两周困扰我的问题之一，虽然目前还算适应现在的工作环境，但是跳槽可能还是在我的计划中，毕竟我向往更加富有技术激情和技术发展空间的平台。因此，每天晚上我都会固定时间学习，但是总感觉时间不够用。觉得可能是效率不够高。反思一下，应该是学习的东西太过零散，然后每次看到比较复杂的东西，总是想往后拖，然后就不了了之了。所以，后续的改进方向应该是: <strong>大概每周确定一个学习的目标，围绕着这个主线学习。然后抽出一部分时间，解决工作中遇到的问题，每次解决一个问题的时候，就尽量深入弄懂，不要一知半解地结束。这样每接触到一个知识，就能解决一个了。然后每周的主线应该围绕将来自己想深入的方向去学习探索，主要的手段是看书+看系列博客+写demo相结合的方式。</strong><br>其实，做site project是个不错的选择，但是缺的是idea。比较好的方案是，写一些算法相关的project或者小游戏，这些花费的时间不多，并且应该能有一些帮助。这个后续需要再思考思考！！！毕竟，<strong>项目经验在未来的跳槽中估计有着很重要的作用，这点需要时刻提醒自己注意一下</strong>！！！</p>
<p>生活上，发现自己基本上没什么娱乐时间了，感觉回来学习一会儿，运动一会洗个澡，再视频半小时就睡觉了。唉，发现到了工作中真的是时间不够用了。之前计划好的，学日语、学上海话还有看电影写影评之类的通通没时间完成，估计应该调整一下思路，这些东西应该放到周末休息时间去做。这样比较合理。</p>
<p>另外就是去苏州看了一下房子，海胥澜庭地段确实好，也是个三学区的房子。不过价格超贵，感觉还是有点承受不起。前几日，考虑到我跳槽不一定能跳到苏州的问题，觉得可能园区还是比较适合。以来跳槽之后在园区的可能性比较大，上班方便；而来，如果不能跳，将来工作重新找到浦西的话，去上海上班还是比较方便的。而且园区房价的抗跌性还是很好的。如果想去杭州的话，房子卖了应该不成问题。另一个考虑就是学区房的问题，这个需要调查一下，到底学区房需要提前几年买的问题。目前我的估计是5年之内我应该用不上学区房了。所以可以不考虑学区房的问题暂时。目前是这样打算的。</p>
<p>恩，总结到这里，最后摘一句话自勉：<br>—— <em>其实学习是个慢功夫，讲究节奏，就像认真的模仿，看上去很慢很循规蹈矩，但一步步走下来，确是成长最快的途径。这在我们这个事事都追求效率的时代，显得弥足珍贵</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://paranoidq.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://paranoidq.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java局部类不能访问外围的非final局部变量的探索]]></title>
    <link href="http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/"/>
    <id>http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/</id>
    <published>2016-07-04T13:04:47.000Z</published>
    <updated>2016-07-15T12:43:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>
<a id="more"></a>
<p>为了清晰，首先用例子探索一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by paranoidq on 16/7/4.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        String str = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">        Date[] dates = <span class="keyword">new</span> Date[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dates.length; i++) &#123;</span><br><span class="line">            dates[i] = <span class="keyword">new</span> Date() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span> </span>&#123;</span><br><span class="line">                    System.out.println(counter);    <span class="comment">// case1: int不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(counter++);  <span class="comment">// case2: int修改 -&gt; compiler error</span></span><br><span class="line">                    System.out.println(str);        <span class="comment">// case3: string不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(str + <span class="string">"t"</span>);  <span class="comment">// case4: string为不可变对象 -&gt; 通过</span></span><br><span class="line"></span><br><span class="line">                    str = <span class="string">"aaa"</span>;</span><br><span class="line">                    System.out.println(str);        <span class="comment">// case5: 修改了string -&gt; 不通过</span></span><br><span class="line">                    <span class="comment">// Error:</span></span><br><span class="line">                    <span class="comment">// Variable str is accessed from within inner class,</span></span><br><span class="line">                    <span class="comment">// need to be final or effectively final</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.compareTo(anotherDate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>我们发现，其实编译器足够智能，对于case1和case3而言，虽然访问了非final局部变量，但是还是通过编译了，而只有在case2、case5中修改了局部变量时，才报错。而对于case4而言，涉及到string对象不可变的另一个知识点，这里略过。</p>
<p>分析报错的提示，可以知道，实际上对于局部类访问外部变量的规则，相对比较宽松，只要是<code>final or effectively final</code>即可，所谓<code>effectively final</code>其实也就是在局部类内没有做出实质性的修改动作，这一类情况编译器也是让过的。</p>
<h3 id="u539F_u56E0"><a href="#u539F_u56E0" class="headerlink" title="原因"></a>原因</h3><p>为什么在局部类内不能访问外部的非final局部变量呢？参考<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="external">这个帖子</a>，写的很到位。引用如下</p>
<p>这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;  </span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome();  </span><br><span class="line">  some.dosome();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是:</p>
<pre><code>class Outer$Dosome{  
    public Dosome(final String a,final int b){  
        this.Dosome$a=a;  
        this.Dosome$b=b;  
    }  
    public void dosome(){  
        System.out.println(this.Dosome$a+this.Dosome$b);  
    }  
}
</code></pre><p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。  </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>内部类的原理分析：<a href="http://android.blog.51cto.com/268543/384809" target="_blank" rel="external">http://android.blog.51cto.com/268543/384809</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="inner-class" scheme="http://paranoidq.github.io/tags/inner-class/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java动态代理与CgLib对比]]></title>
    <link href="http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/"/>
    <id>http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/</id>
    <published>2016-06-08T07:48:27.000Z</published>
    <updated>2016-06-08T03:59:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>
<a id="more"></a>
<h3 id="JDK_u52A8_u6001_u4EE3_u7406"><a href="#JDK_u52A8_u6001_u4EE3_u7406" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real object."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Jdk 动态代理必须代理接口,不能代理正常的类.</span><br><span class="line"> *</span><br><span class="line"> * 创建速度快于Cgi,但是运行速度大约比Cgi慢10倍.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> proxy The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.</span><br><span class="line">     *              Most often you don't need this object.</span><br><span class="line">     * <span class="doctag">@param</span> method</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     * <span class="doctag">@throws</span> Throwable</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">        System.out.println(<span class="string">"method: "</span> + method);</span><br><span class="line">        System.out.println(<span class="string">"args: "</span> + args);</span><br><span class="line">        <span class="keyword">if</span> (method.getName().contains(<span class="string">"do"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method contains do*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = proxy.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      equals</span><br><span class="line">         *      toString</span><br><span class="line">         *      hashCode</span><br><span class="line">         *      doSomething !!!</span><br><span class="line">         */</span></span><br><span class="line">        Class[] interfaces = proxy.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">            System.out.println(c);  <span class="comment">// interface me.util.proxy.jdkproxy.Subject</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      interface me.util.proxy.jdkproxy.Subject</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args); <span class="comment">// 在实际对象上invoke方法,同时传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxy = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                Subject.class.getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> JdkProxy(subject));</span><br><span class="line"></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"======="</span>);</span><br><span class="line">        System.out.println(proxy); <span class="comment">// toString的调用同样会dispatch到invoke,因此会被也"包装"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u603B_u7ED3_u51E0_u70B9_uFF1A"><a href="#u603B_u7ED3_u51E0_u70B9_uFF1A" class="headerlink" title="总结几点："></a>总结几点：</h4><ol>
<li>只能代理接口，不能代理类（原因在与newProxyInstane参数中需要被代理类的接口数组）。如果将newProxyInstance返回的Object转为RealSubject，则报异常：<code>java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to me.util.proxy.jdkproxy.RealSubject</code></li>
<li><code>java.lang.Object</code>的方法<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>也会被代理类拦截。（原因在代码最后的<code>toString(proxy)</code>也触发了代理类的输出）</li>
<li>代理实例本身会被传递给invoke，作为第一个参数，即proxy。可以通过这个获取代理实例及其类型信息（代码中，我们获得了代理实例实际上有doSomething()这个方法，因为代理实例也继承了接口Subject！<strong>所以说为什么要传入classloader，因为实际上是Java在用bytecode生成一个实现了Subject接口的动态代理类啊！这不就是隐式地在用反射构建一个类么？</strong>）</li>
</ol>
<p>JDK动态代理类的字节码是由Java在运行时通过反射动态生成的。</p>
<p>上面的例子基本已经显示了JDK代理的重要特性，下面整理说明一些重点：（主要参考Oracle JavaDoc）</p>
<ol>
<li>invoke()的返回值会传递给代理实例，从而返回给客户端，因此客户端的代理实例声明的返回值类型要注意匹配。</li>
<li></li>
<li>invoke代理的函数的参数列表以数组形式给出，对基本类型做了默认的boxing。另外，注意，在invoke内部可以任意修改这个参数数组，这里Java没有约束。（当然，一般来说修改函数的参数是很危险的，尤其还是这种经过代理的调用，会让调用方完全不知情！）</li>
</ol>
<h3 id="CGLib_u52A8_u6001_u4EE3_u7406"><a href="#CGLib_u52A8_u6001_u4EE3_u7406" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * cgi代理可以代理任何类,采用的方式是创建类的子类,然后在子类中调用父类的方法,并织入aop的逻辑</span><br><span class="line"> *</span><br><span class="line"> * 创建慢,但运行性能快于jdk.</span><br><span class="line"> * 适用于对象创建少,长期使用的情况,如singleton.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CgLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);  <span class="comment">// 设置被代理类, CgLib根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before method"</span>);</span><br><span class="line">        <span class="comment">// invoke()会造成循环调用, 因为调用的还是子类对象的方法, 而子类对象的方法还是会被拦截.</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After method"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CgLibProxy proxyHandler = <span class="keyword">new</span> CgLibProxy();</span><br><span class="line">        <span class="comment">// proxy normal class: RealSubject</span></span><br><span class="line">        RealSubject proxy = (RealSubject) proxyHandler.getProxy(RealSubject.class);</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类</li>
<li>可以代理没有接口的类(JDK动态代理则不行)</li>
<li>通过字节码技术为被代理的类创建子类，并在子类中采用方法<code>intercept</code>拦截所有父类方法的调用</li>
<li>显然，基于第三点，CGlib不能代理final类</li>
<li>pom包: cglib + asm (底层依赖于asm)</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="external">Java Doc</a><br><a href="http://blog.csdn.net/janice0529/article/details/42884019" target="_blank" rel="external">http://blog.csdn.net/janice0529/article/details/42884019</a><br><a href="http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html</a><br><a href="http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/" target="_blank" rel="external">http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="proxy" scheme="http://paranoidq.github.io/tags/proxy/"/>
    
      <category term="cglib" scheme="http://paranoidq.github.io/tags/cglib/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node.js安装express框架时出现command not found问题]]></title>
    <link href="http://paranoidq.github.io/2016/06/07/nodejs-express-install/"/>
    <id>http://paranoidq.github.io/2016/06/07/nodejs-express-install/</id>
    <published>2016-06-07T12:23:45.000Z</published>
    <updated>2016-06-07T12:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br><a id="more"></a></p>
<p>安装时在文件夹下输入：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express</span><br></pre></td></tr></table></figure></p>
<p>但是无法使用express命令，出现<code>express: command not found</code>。原因在于在express4.0中，cli需要单独安装才能使用，cli功能被包含在<code>express-generator</code> package中。</p>
<p>因此需要如下操作：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express-generator</span><br></pre></td></tr></table></figure></p>
<p>参考: <a href="http://stackoverflow.com/questions/23002448/express-command-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/23002448/express-command-not-found</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://paranoidq.github.io/tags/express/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyenv神器]]></title>
    <link href="http://paranoidq.github.io/2016/06/04/pyenv%E7%A5%9E%E5%99%A8/"/>
    <id>http://paranoidq.github.io/2016/06/04/pyenv神器/</id>
    <published>2016-06-04T09:23:24.000Z</published>
    <updated>2016-06-07T12:09:46.000Z</updated>
    <content type="html"><![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u8BBE_u7F6E_u56FD_u5185_u955C_u50CF"><a href="#u8BBE_u7F6E_u56FD_u5185_u955C_u50CF" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mirrors</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_BUILD_MIRROR_URL=<span class="string">"http://pyenv.qiniudn.com/pythons/"</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">version</span><span class="comment"> // 正在使用的版本</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="comment">--list</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv uninstall <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 全局设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">global</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 本地目录设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="keyword">system</span> <span class="comment"> // 直接使用系统自带版本</span></span><br></pre></td></tr></table></figure>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ol>
<li>如何删除已经安装的python版本: <a href="http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di" target="_blank" rel="external">http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di</a></li>
<li>一般而言，系统库放/System/Library，而应用程序依赖的放/Library，所以，苹果自带的python放在前者，而用户自己装的python（比如官方网站下载的）会自动装在后者。（homebrew安装的就在后者）</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">https://github.com/yyuu/pyenv</a><br><a href="http://v2in.com/pyenv-installation-and-usage.html" target="_blank" rel="external">http://v2in.com/pyenv-installation-and-usage.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="http://paranoidq.github.io/tags/pyenv/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近几年前端技术盘点以及2016年技术发展方向(好文，转)]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/front-end-trend/"/>
    <id>http://paranoidq.github.io/2016/05/27/front-end-trend/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barret]]>
    </summary>
    
      <category term="前端" scheme="http://paranoidq.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://paranoidq.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python parameters]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Python-parameters-explained/"/>
    <id>http://paranoidq.github.io/2016/05/27/Python-parameters-explained/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>
<a id="more"></a>
<h3 id="u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29"><a href="#u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29" class="headerlink" title="位置参数 positional parameter(固定参数)"></a>位置参数 positional parameter(固定参数)</h3><ol>
<li><p>函数定义时：其中的x,n 都是固定<strong>形参</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用时：如果不指定名字，则传入的两个<strong>实参</strong>按照位置顺序依次赋给<strong>形参</strong>x和n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于是位置参数，所以参数名在调用的时候是没有意义的，只有参数的顺序才有意义。因为形参会根据顺序依次匹配实参。</p>
<h3 id="u9ED8_u8BA4_u53C2_u6570_default_parameter"><a href="#u9ED8_u8BA4_u53C2_u6570_default_parameter" class="headerlink" title="默认参数 default parameter"></a>默认参数 default parameter</h3><p>如果不传递n的话，上面的调用会报错：缺少位置<strong>实参</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'n'</span></span><br></pre></td></tr></table></figure></p>
<p>这时候就可以靠默认参数来帮助我们省事，不用每次都给默认形参传递实参了</p>
<ol>
<li><p>函数定义时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>默认参数定义<strong>必须</strong>在所有的位置参数之后，并且默认参数的后面不能再有位置参数</li>
<li>默认参数的必须指向不变的对象，否则会掉坑<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，</span></span><br><span class="line"><span class="comment"># 它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</span></span><br><span class="line"><span class="comment"># 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的做法：通过None这个不变的默认参数来做</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数调用时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以不提供默认参数的实参，也可以提供</span></span><br><span class="line">func(<span class="string">'abc'</span>)  </span><br><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对于多个默认参数的情况，如果按顺序提供，可以不指定默认形参的名字；</span></span><br><span class="line"><span class="comment"># 否则需指定名字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x, n=<span class="number">1</span>, m=<span class="number">2</span>)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">func2(<span class="string">'abc'</span>, m=<span class="number">23</span>, n=<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>注意：不按顺序提供实参的情况仅仅适用于默认参数部分。也就是无论如何，必须先按顺序提供位置参数，之后提供的默认实参才有不按顺序一说。下面的调用是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(n=<span class="number">10</span>, <span class="string">'acb'</span>)</span><br><span class="line"><span class="comment"># output: SyntaxError: non-keyword arg after keyword arg</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53EF_u53D8_u53C2_u6570"><a href="#u53EF_u53D8_u53C2_u6570" class="headerlink" title="可变参数"></a>可变参数</h3><p>在定义函数的时候，传入的位置参数个数不确定的时候使用</p>
<p>不用可变参数怎么做？转化为list或tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">calc((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>利用可变参数就可以直接传入，不需要显示转化了<code>calc(1, 2, 3)</code></p>
<ol>
<li><p>函数定义<br>使用*表达式即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    <span class="comment"># the same with above</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：可以传入任意个数的实参，包括0个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于对已有的列表进行操作</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">calc(*nums)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：函数调用的时候，实参做了拷贝，原有的实参不变！</p>
<p>可变参数可以同时定义在位置参数后面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （2）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （3）</span></span><br><span class="line"><span class="comment"># output: 'abc', ('e', 'f', 'g')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x=<span class="string">'123'</span>, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （4）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （5）</span></span><br><span class="line"><span class="comment"># output: 'c', ('f', 'g')</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>优先匹配位置参数, 无论有没有默认值。有默认值覆盖默认值，没有默认值赋值。剩下来的部分才给可变参数！</li>
<li>注意(2)和(3)调用方式的不同</li>
<li>注意(4)和(5)结果的不同</li>
</ul>
<h3 id="u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09"><a href="#u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09" class="headerlink" title="关键字参数（keyword parameter）"></a>关键字参数（keyword parameter）</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">   print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：<br>可以只传入位置参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>也可以传入任意个数任意名字的关键字实参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>
<p>传入dict的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br></pre></td></tr></table></figure>
<p>注意：注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</p>
</li>
</ol>
<h3 id="u547D_u540D_u5173_u952E_u5B57_u53C2_u6570"><a href="#u547D_u540D_u5173_u952E_u5B57_u53C2_u6570" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>定义时可以有缺省值：由于指定名字，所以带缺省值的parameter不关心顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'beijing'</span>, job)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传入参数名(除非使用定义了的缺省值，连值也不传)，否则会报TypeError</span></span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53C2_u6570_u7684_u7EC4_u5408"><a href="#u53C2_u6570_u7684_u7EC4_u5408" class="headerlink" title="参数的组合"></a>参数的组合</h3><p>必须是如下顺序：<br><strong>必选参数、默认参数、可变参数/命名关键字参数和关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的</p>
<p>反之，接受任何参数的函数，可以定义为func(<em>args, *</em>kw)这种形式。这种定义并不好，实际上，没有通用的规则在一个接受任何参数的函数内部做处理。但是对于decorator等一些应用，接受任何参数的设定就非常有用，因为decorator不关心包装的函数参数是什么，它确实可能需要一个这样的机制来传参。</p>
<h3 id="u6CE8_u610F_u70B9_uFF1A"><a href="#u6CE8_u610F_u70B9_uFF1A" class="headerlink" title="注意点："></a>注意点：</h3><ol>
<li><p>关键字参数会覆盖位置参数的默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'a:%s, b:%s, c:%s'</span> % (a, b, c))</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)  <span class="comment"># 关键字参数会覆盖前面的默认值</span></span><br><span class="line"><span class="comment"># output: a:z, b:d, c:r</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数与默认参数不同</p>
<ul>
<li>在定义的适合，默认参数本质上还是给了默认值的位置参数，必须定义在关键字参数的前面；而关键字参数应该最后定义，并且需要<code>**</code>表达式</li>
<li>在调用时候，默认参数部分会优先匹配，匹配之后剩下来的才给关键字参数。所以在函数调用的时候谈论关键字参数实际上没有意义，它只是函数定义时的一个为了扩展用的占位符而已<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># output: a b c &#123;&#125;</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125; # 注意，全部先匹配了默认参数</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>, <span class="string">'d'</span>:<span class="string">'z'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;'d': 'z'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用kwargs为没有提供默认值的位置参数提供值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125;</span></span><br><span class="line"><span class="comment"># 如果kwargs里面没有为a提供值，那么就会报TypeError了</span></span><br><span class="line">func(**&#123;<span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'a'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Best_Practices_3A"><a href="#Best_Practices_3A" class="headerlink" title="Best Practices:"></a>Best Practices:</h3><ol>
<li><p><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP-3102</a>: 定义了keyworkd-only 参数（本质就是命名关键字参数），避免模糊不清地被位置参数匹配。（”keyword-only” arguments: arguments that can only be supplied by keyword and which will never be automatically filled in by a positional argument）</p>
<p>有时候使用者希望函数可以接受可变参数，同时接受一些以keword形式传递的实参。如果不允许在可变参数后面定义named-keyword参数的话，唯一的解决办法是同时定义<code>*args</code>和<code>**kwargs</code>，然后手动抽取其中的一些entry。<br>Why? 看实参传递的顺序，non-keyword实参 &gt; keyword实参。所以如果定义在可变参数前，可能会被位置参数匹配掉(也就是不是真正意义上的keyword参数，而可能被解释器认为是带默认值的位置参数)。</p>
<p>PEP3102允许在可变参数后面定义regular parameter,作为keyword-only arguments。永远不会被位置参数匹配，必须指定名字。</p>
<p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时有可变参数存在， 可变参数会suck up所有的non-keyword实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords</span><span class="params">(*wordlist, case_sensitive=False)</span>:</span></span><br><span class="line"><span class="comment"># 没有可变参数存在, * means不允许任何可变参数存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords2</span><span class="params">(*, case_sensitive)</span>:</span></span><br></pre></td></tr></table></figure>
<p>显然，case_sensitive只能以keyword的方式赋值，不会被位置参数匹配。</p>
</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="external">廖雪峰的Python教程</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP3102</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
</feed>
