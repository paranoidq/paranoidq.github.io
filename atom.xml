<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[钱唯の个人博客]]></title>
  <subtitle><![CDATA[佳思忽来，书能下酒；侠情一往，云可赠人。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://paranoidq.github.io/"/>
  <updated>2016-07-25T13:24:20.000Z</updated>
  <id>http://paranoidq.github.io/</id>
  
  <author>
    <name><![CDATA[Paranoid Qian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[个人已经破产，靠还没倒闭的行业活着（转载）]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/%E4%B8%AA%E4%BA%BA%E5%B7%B2%E7%BB%8F%E7%A0%B4%E4%BA%A7/"/>
    <id>http://paranoidq.github.io/2016/07/25/个人已经破产/</id>
    <published>2016-07-25T13:14:31.000Z</published>
    <updated>2016-07-25T13:24:20.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd" target="_blank" rel="external">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>
<a id="more"></a>
<h3 id="u4E8C"><a href="#u4E8C" class="headerlink" title="二"></a>二</h3><p>想起当年电视台如日中天炙手可热的时候，我领教过的一个台里员工。那位负责灯光的人被称为“灯爷”，对别人永远是颐指气使的口吻，对自己永远觉得含着天大的委屈，找他做最简单的事情都得陪着笑脸，而他做最分内的事情都觉得是别人在给他添麻烦。</p>
<p>更可怕的是，我们都对这样的大爷习以为常。他老人家稍微嘴脸好看点儿，手脚勤快点儿，便觉得是恩赐。</p>
<p>直到后来见识了一位香港“灯爷”：永远不用你操心、催促，在规定的时间内到位，黑着脸不许别人碰他的器材，手脚麻利地快速解决一切事情，工作成效之高、之专业，几乎都让你意识不到他的存在。</p>
<p>再看我们这位爷，遇到潜在的金主，想给自己捞点野活挣点外快，就倨傲又殷勤地给人家递名片：我是中央台的。</p>
<p>那时的我年轻气盛，看到这一幕，鄙夷地想：把你名片上“中央电视台”那几个字划掉，你什么也不是。</p>
<h3 id="u4E09"><a href="#u4E09" class="headerlink" title="三"></a>三</h3><p>这些年，中国房地产行业空前繁荣。建筑师这个职业，应该是机会大大的，挣钱多多的，心里美美的吧。</p>
<p>一位建筑界的老师却对我说，高歌猛进的房地产行业，还有那些地标式的公共建筑，不仅对城市、对环境造成破坏，对公众审美形成摧残，还把一代建筑师给毁了。</p>
<p>我吃惊地问为什么。他的要点是：因为活儿太多，素质不高的设计师也可以有干不完的单子应接不暇；因为钱太好挣，许多建筑师没有了自我提高的主动与自觉；因为工程太赶，缺乏原创、智慧含量和时间成本越少的设计成为首选，行业的水准线便越来越低。</p>
<p>一位做建筑图书的出版业同行，准备引进一套欧洲建筑丛书，全套有二三百本，囊括了当代建筑的各位大师，全面呈现其作品和建筑理念。我想当然地认为这套书会很好卖，因为它本来口碑就好，建筑装饰类图书又永远在书店里占据相当比重，中国的建筑设计行业人多，钱多，需求又大。</p>
<p>她说给我的发行量却低得惊人。这套书只引进了十几种，原来宏伟的出版计划看来会中途夭折。</p>
<p>她的观点也是：大家的学习动力没有了，因为钱太容易挣。一个建筑师不用看这些书，照样有挣不完的钱。</p>
<p>一个行业的繁荣，对个人来说是好事还是坏事？</p>
<h3 id="u56DB"><a href="#u56DB" class="headerlink" title="四"></a>四</h3><p>我们去年签下一套英文书的版权，写人类伟大的历史文化遗迹。因为它和建筑有很大关系，所以我想邀请建筑界的专家——外语又好、又懂建筑的人来翻译。</p>
<p>找到一位人脉广的老师求助，他说，你可能在建筑界找不到人。没人愿意接你的活儿。你看，能够胜任翻译的人，得是具备一定能力和资历的人。一本书的翻译至少要几个月的时间，稿费最多几万块钱，可人家用几个晚上时间画建筑图纸，就能挣几万块。</p>
<p>我说，这不正好吗？用几天时间画图，把几万块钱挣出来，那不就没有后顾之忧，更能踏踏实实、专心致志搞翻译了吗？</p>
<p>你这个逻辑太自作多情了，也把你的书看得太重要了。人家想的是，花几个月时间来翻译你这本书的话，就意味着耽误了画多少图、失去了挣多少钱的机会。并且这种活儿都还排着队等他来接呢，谁还稀罕为你翻译，谁算不明白这笔账呢？</p>
<p>一个人都温饱无忧了，何必还为挣钱，把自己搞得连翻译一本书这么有乐趣的事都不做呢？我兀自不甘心地咕哝。</p>
<p>有了小房子还要改善性住宅，有了大房子还要弄别墅。永远挣不完的钱，永远画不完的图。大家的时间，都用来赶这些行活了。</p>
<p>好吧，我之蜜糖，彼之砒霜。</p>
<h3 id="u4E94"><a href="#u4E94" class="headerlink" title="五"></a>五</h3><p>改革开放三十多年，破产的公司、机构不计其数，但中国几百家出版社，好像自始至终没有一家倒闭的。</p>
<p>行业的繁荣或依赖政策形成的稳定，会给一些鱼龙混杂、蜂拥而入的从业人员造成错觉，相信自己可以高枕无忧不思进取，甚至以为自己“亦有贡献”。可在危机来临之前，一个人的能力储备、职业素养、知识更新、自我成长，会自觉地被激发、强调出来么？</p>
<p>写到这里，我突然有一种担心：这些永不倒闭的出版社，已经把一些编辑养残，自我破产了。</p>
<p>我们有没有勇气和清醒，独立于外部环境和行业冷暖，明白自己要做些什么？</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="社会" scheme="http://paranoidq.github.io/categories/%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的书单]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/just-reading/"/>
    <id>http://paranoidq.github.io/2016/07/25/just-reading/</id>
    <published>2016-07-24T16:14:07.000Z</published>
    <updated>2016-07-24T16:26:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/" target="_blank" rel="external">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/" target="_blank" rel="external">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/" target="_blank" rel="external">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/" target="_blank" rel="external">创业维艰</a></p>
<a id="more"></a>
<h3 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h3><p><a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">浪潮之巅</a> (完成)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/">创业维艰</a></p>]]>
    
    </summary>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生新阶段随笔（1）]]></title>
    <link href="http://paranoidq.github.io/2016/07/15/%E4%BA%BA%E7%94%9F%E6%96%B0%E9%98%B6%E6%AE%B5%E9%9A%8F%E7%AC%94-1/"/>
    <id>http://paranoidq.github.io/2016/07/15/人生新阶段随笔-1/</id>
    <published>2016-07-15T12:02:53.000Z</published>
    <updated>2016-07-15T12:45:30.000Z</updated>
    <content type="html"><![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>
<a id="more"></a>
<p>说道知识和技能，这个其实是我不太满意的地方。虽说之前可能也有心理准备，但是进入到公司才发现，国企确实在技术上的发展不够好，或者说不够有技术的激情。当然，已经工作多年的前辈肯定是比我懂得多，但总感觉整个技术开发中心的氛围不够好，这点可能真的无法跟互联网公司相比。不过，其实互联网公司的技术其实也就集中于几个核心的部门，其他大部分也都是完成业务而已。这点上，在EMC这样的外企实习过的同事其实还蛮有发言权的。因此，<strong>公司可能只是一个平台，更多的还是要考自己去主动地学习和探索。问题其实天天都会有，就看你愿不愿意花时间去学了</strong>。</p>
<p>工作的同事其实还是蛮nice的，大家人都非常随和，没有传统国企那种等级森严的感觉。虽然有些师兄已经工作了近十年了，但是还是可以跟我们聊得很好。当然，我之前定下的目标就是要努力处理好自己的人事关系，目前看来还算不错，基本上跟组里的同事相处的很好，能够主动跟他们交流。搁过去的话，我估计还不会有这样的表现，所以算是步入社会之后强迫自己的一种改变吧。能够跟各种人正常的交往也算是一种极为重要的生活技能。</p>
<p>目前组里做的东西说白了就是适配，适配各种行业和机构的接口。本质上，这东西其实还是有一定技术含量的，不过就我目前研究的线上系统WCG的源码来看，写的确实不怎么样，感觉连我这个在校生都不如，各种magic number随便乱写，配置也随便乱写，系统模块和类设计不合理的地方很多。所以目前我的想法是能够重构这个系统，感觉如果能够进行下去的话，应该是一次难得的学习机会，毕竟无论是个人技术成长还是将来跳槽，这都是一个有利的加分项。而<strong>难点在于，如何设计一个好的系统架构，并且考虑到测试成本的问题，系统重构的过程需要尽量的step-by-step，类似于持续集成吧</strong>。这方面，在没有人带我的情况下，感觉是最困难的地方了。架构的问题，可能需要我上网查阅很多资料，如果能够有人请教的话就最好了。而关于重构成本的问题，这估计也是领导最为关心的问题，所以我接下来要做的工作应该是<strong>证明系统重构能够带来很大的好处，并且尽量减小重构对于目前运行的功能的稳定性影响</strong>。</p>
<p>跳槽的问题其实也是这两周困扰我的问题之一，虽然目前还算适应现在的工作环境，但是跳槽可能还是在我的计划中，毕竟我向往更加富有技术激情和技术发展空间的平台。因此，每天晚上我都会固定时间学习，但是总感觉时间不够用。觉得可能是效率不够高。反思一下，应该是学习的东西太过零散，然后每次看到比较复杂的东西，总是想往后拖，然后就不了了之了。所以，后续的改进方向应该是: <strong>大概每周确定一个学习的目标，围绕着这个主线学习。然后抽出一部分时间，解决工作中遇到的问题，每次解决一个问题的时候，就尽量深入弄懂，不要一知半解地结束。这样每接触到一个知识，就能解决一个了。然后每周的主线应该围绕将来自己想深入的方向去学习探索，主要的手段是看书+看系列博客+写demo相结合的方式。</strong><br>其实，做site project是个不错的选择，但是缺的是idea。比较好的方案是，写一些算法相关的project或者小游戏，这些花费的时间不多，并且应该能有一些帮助。这个后续需要再思考思考！！！毕竟，<strong>项目经验在未来的跳槽中估计有着很重要的作用，这点需要时刻提醒自己注意一下</strong>！！！</p>
<p>生活上，发现自己基本上没什么娱乐时间了，感觉回来学习一会儿，运动一会洗个澡，再视频半小时就睡觉了。唉，发现到了工作中真的是时间不够用了。之前计划好的，学日语、学上海话还有看电影写影评之类的通通没时间完成，估计应该调整一下思路，这些东西应该放到周末休息时间去做。这样比较合理。</p>
<p>另外就是去苏州看了一下房子，海胥澜庭地段确实好，也是个三学区的房子。不过价格超贵，感觉还是有点承受不起。前几日，考虑到我跳槽不一定能跳到苏州的问题，觉得可能园区还是比较适合。以来跳槽之后在园区的可能性比较大，上班方便；而来，如果不能跳，将来工作重新找到浦西的话，去上海上班还是比较方便的。而且园区房价的抗跌性还是很好的。如果想去杭州的话，房子卖了应该不成问题。另一个考虑就是学区房的问题，这个需要调查一下，到底学区房需要提前几年买的问题。目前我的估计是5年之内我应该用不上学区房了。所以可以不考虑学区房的问题暂时。目前是这样打算的。</p>
<p>恩，总结到这里，最后摘一句话自勉：<br>—— <em>其实学习是个慢功夫，讲究节奏，就像认真的模仿，看上去很慢很循规蹈矩，但一步步走下来，确是成长最快的途径。这在我们这个事事都追求效率的时代，显得弥足珍贵</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://paranoidq.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://paranoidq.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java局部类不能访问外围的非final局部变量的探索]]></title>
    <link href="http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/"/>
    <id>http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/</id>
    <published>2016-07-04T13:04:47.000Z</published>
    <updated>2016-07-15T12:43:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>
<a id="more"></a>
<p>为了清晰，首先用例子探索一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by paranoidq on 16/7/4.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        String str = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">        Date[] dates = <span class="keyword">new</span> Date[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dates.length; i++) &#123;</span><br><span class="line">            dates[i] = <span class="keyword">new</span> Date() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span> </span>&#123;</span><br><span class="line">                    System.out.println(counter);    <span class="comment">// case1: int不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(counter++);  <span class="comment">// case2: int修改 -&gt; compiler error</span></span><br><span class="line">                    System.out.println(str);        <span class="comment">// case3: string不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(str + <span class="string">"t"</span>);  <span class="comment">// case4: string为不可变对象 -&gt; 通过</span></span><br><span class="line"></span><br><span class="line">                    str = <span class="string">"aaa"</span>;</span><br><span class="line">                    System.out.println(str);        <span class="comment">// case5: 修改了string -&gt; 不通过</span></span><br><span class="line">                    <span class="comment">// Error:</span></span><br><span class="line">                    <span class="comment">// Variable str is accessed from within inner class,</span></span><br><span class="line">                    <span class="comment">// need to be final or effectively final</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.compareTo(anotherDate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>我们发现，其实编译器足够智能，对于case1和case3而言，虽然访问了非final局部变量，但是还是通过编译了，而只有在case2、case5中修改了局部变量时，才报错。而对于case4而言，涉及到string对象不可变的另一个知识点，这里略过。</p>
<p>分析报错的提示，可以知道，实际上对于局部类访问外部变量的规则，相对比较宽松，只要是<code>final or effectively final</code>即可，所谓<code>effectively final</code>其实也就是在局部类内没有做出实质性的修改动作，这一类情况编译器也是让过的。</p>
<h3 id="u539F_u56E0"><a href="#u539F_u56E0" class="headerlink" title="原因"></a>原因</h3><p>为什么在局部类内不能访问外部的非final局部变量呢？参考<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="external">这个帖子</a>，写的很到位。引用如下</p>
<p>这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;  </span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome();  </span><br><span class="line">  some.dosome();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是:</p>
<pre><code>class Outer$Dosome{  
    public Dosome(final String a,final int b){  
        this.Dosome$a=a;  
        this.Dosome$b=b;  
    }  
    public void dosome(){  
        System.out.println(this.Dosome$a+this.Dosome$b);  
    }  
}
</code></pre><p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。  </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>内部类的原理分析：<a href="http://android.blog.51cto.com/268543/384809" target="_blank" rel="external">http://android.blog.51cto.com/268543/384809</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="inner-class" scheme="http://paranoidq.github.io/tags/inner-class/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java动态代理与CgLib对比]]></title>
    <link href="http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/"/>
    <id>http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/</id>
    <published>2016-06-08T07:48:27.000Z</published>
    <updated>2016-06-08T03:59:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>
<a id="more"></a>
<h3 id="JDK_u52A8_u6001_u4EE3_u7406"><a href="#JDK_u52A8_u6001_u4EE3_u7406" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real object."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Jdk 动态代理必须代理接口,不能代理正常的类.</span><br><span class="line"> *</span><br><span class="line"> * 创建速度快于Cgi,但是运行速度大约比Cgi慢10倍.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> proxy The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.</span><br><span class="line">     *              Most often you don't need this object.</span><br><span class="line">     * <span class="doctag">@param</span> method</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     * <span class="doctag">@throws</span> Throwable</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">        System.out.println(<span class="string">"method: "</span> + method);</span><br><span class="line">        System.out.println(<span class="string">"args: "</span> + args);</span><br><span class="line">        <span class="keyword">if</span> (method.getName().contains(<span class="string">"do"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method contains do*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = proxy.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      equals</span><br><span class="line">         *      toString</span><br><span class="line">         *      hashCode</span><br><span class="line">         *      doSomething !!!</span><br><span class="line">         */</span></span><br><span class="line">        Class[] interfaces = proxy.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">            System.out.println(c);  <span class="comment">// interface me.util.proxy.jdkproxy.Subject</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      interface me.util.proxy.jdkproxy.Subject</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args); <span class="comment">// 在实际对象上invoke方法,同时传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxy = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                Subject.class.getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> JdkProxy(subject));</span><br><span class="line"></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"======="</span>);</span><br><span class="line">        System.out.println(proxy); <span class="comment">// toString的调用同样会dispatch到invoke,因此会被也"包装"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u603B_u7ED3_u51E0_u70B9_uFF1A"><a href="#u603B_u7ED3_u51E0_u70B9_uFF1A" class="headerlink" title="总结几点："></a>总结几点：</h4><ol>
<li>只能代理接口，不能代理类（原因在与newProxyInstane参数中需要被代理类的接口数组）。如果将newProxyInstance返回的Object转为RealSubject，则报异常：<code>java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to me.util.proxy.jdkproxy.RealSubject</code></li>
<li><code>java.lang.Object</code>的方法<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>也会被代理类拦截。（原因在代码最后的<code>toString(proxy)</code>也触发了代理类的输出）</li>
<li>代理实例本身会被传递给invoke，作为第一个参数，即proxy。可以通过这个获取代理实例及其类型信息（代码中，我们获得了代理实例实际上有doSomething()这个方法，因为代理实例也继承了接口Subject！<strong>所以说为什么要传入classloader，因为实际上是Java在用bytecode生成一个实现了Subject接口的动态代理类啊！这不就是隐式地在用反射构建一个类么？</strong>）</li>
</ol>
<p>JDK动态代理类的字节码是由Java在运行时通过反射动态生成的。</p>
<p>上面的例子基本已经显示了JDK代理的重要特性，下面整理说明一些重点：（主要参考Oracle JavaDoc）</p>
<ol>
<li>invoke()的返回值会传递给代理实例，从而返回给客户端，因此客户端的代理实例声明的返回值类型要注意匹配。</li>
<li></li>
<li>invoke代理的函数的参数列表以数组形式给出，对基本类型做了默认的boxing。另外，注意，在invoke内部可以任意修改这个参数数组，这里Java没有约束。（当然，一般来说修改函数的参数是很危险的，尤其还是这种经过代理的调用，会让调用方完全不知情！）</li>
</ol>
<h3 id="CGLib_u52A8_u6001_u4EE3_u7406"><a href="#CGLib_u52A8_u6001_u4EE3_u7406" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * cgi代理可以代理任何类,采用的方式是创建类的子类,然后在子类中调用父类的方法,并织入aop的逻辑</span><br><span class="line"> *</span><br><span class="line"> * 创建慢,但运行性能快于jdk.</span><br><span class="line"> * 适用于对象创建少,长期使用的情况,如singleton.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CgLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);  <span class="comment">// 设置被代理类, CgLib根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before method"</span>);</span><br><span class="line">        <span class="comment">// invoke()会造成循环调用, 因为调用的还是子类对象的方法, 而子类对象的方法还是会被拦截.</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After method"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CgLibProxy proxyHandler = <span class="keyword">new</span> CgLibProxy();</span><br><span class="line">        <span class="comment">// proxy normal class: RealSubject</span></span><br><span class="line">        RealSubject proxy = (RealSubject) proxyHandler.getProxy(RealSubject.class);</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类</li>
<li>可以代理没有接口的类(JDK动态代理则不行)</li>
<li>通过字节码技术为被代理的类创建子类，并在子类中采用方法<code>intercept</code>拦截所有父类方法的调用</li>
<li>显然，基于第三点，CGlib不能代理final类</li>
<li>pom包: cglib + asm (底层依赖于asm)</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="external">Java Doc</a><br><a href="http://blog.csdn.net/janice0529/article/details/42884019" target="_blank" rel="external">http://blog.csdn.net/janice0529/article/details/42884019</a><br><a href="http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html</a><br><a href="http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/" target="_blank" rel="external">http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="proxy" scheme="http://paranoidq.github.io/tags/proxy/"/>
    
      <category term="cglib" scheme="http://paranoidq.github.io/tags/cglib/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node.js安装express框架时出现command not found问题]]></title>
    <link href="http://paranoidq.github.io/2016/06/07/nodejs-express-install/"/>
    <id>http://paranoidq.github.io/2016/06/07/nodejs-express-install/</id>
    <published>2016-06-07T12:23:45.000Z</published>
    <updated>2016-06-07T12:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br><a id="more"></a></p>
<p>安装时在文件夹下输入：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express</span><br></pre></td></tr></table></figure></p>
<p>但是无法使用express命令，出现<code>express: command not found</code>。原因在于在express4.0中，cli需要单独安装才能使用，cli功能被包含在<code>express-generator</code> package中。</p>
<p>因此需要如下操作：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express-generator</span><br></pre></td></tr></table></figure></p>
<p>参考: <a href="http://stackoverflow.com/questions/23002448/express-command-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/23002448/express-command-not-found</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://paranoidq.github.io/tags/express/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyenv神器]]></title>
    <link href="http://paranoidq.github.io/2016/06/04/pyenv%E7%A5%9E%E5%99%A8/"/>
    <id>http://paranoidq.github.io/2016/06/04/pyenv神器/</id>
    <published>2016-06-04T09:23:24.000Z</published>
    <updated>2016-06-07T12:09:46.000Z</updated>
    <content type="html"><![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u8BBE_u7F6E_u56FD_u5185_u955C_u50CF"><a href="#u8BBE_u7F6E_u56FD_u5185_u955C_u50CF" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mirrors</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_BUILD_MIRROR_URL=<span class="string">"http://pyenv.qiniudn.com/pythons/"</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">version</span><span class="comment"> // 正在使用的版本</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="comment">--list</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv uninstall <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 全局设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">global</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 本地目录设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="keyword">system</span> <span class="comment"> // 直接使用系统自带版本</span></span><br></pre></td></tr></table></figure>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ol>
<li>如何删除已经安装的python版本: <a href="http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di" target="_blank" rel="external">http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di</a></li>
<li>一般而言，系统库放/System/Library，而应用程序依赖的放/Library，所以，苹果自带的python放在前者，而用户自己装的python（比如官方网站下载的）会自动装在后者。（homebrew安装的就在后者）</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">https://github.com/yyuu/pyenv</a><br><a href="http://v2in.com/pyenv-installation-and-usage.html" target="_blank" rel="external">http://v2in.com/pyenv-installation-and-usage.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="http://paranoidq.github.io/tags/pyenv/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python parameters]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Python-parameters-explained/"/>
    <id>http://paranoidq.github.io/2016/05/27/Python-parameters-explained/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>
<a id="more"></a>
<h3 id="u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29"><a href="#u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29" class="headerlink" title="位置参数 positional parameter(固定参数)"></a>位置参数 positional parameter(固定参数)</h3><ol>
<li><p>函数定义时：其中的x,n 都是固定<strong>形参</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用时：如果不指定名字，则传入的两个<strong>实参</strong>按照位置顺序依次赋给<strong>形参</strong>x和n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于是位置参数，所以参数名在调用的时候是没有意义的，只有参数的顺序才有意义。因为形参会根据顺序依次匹配实参。</p>
<h3 id="u9ED8_u8BA4_u53C2_u6570_default_parameter"><a href="#u9ED8_u8BA4_u53C2_u6570_default_parameter" class="headerlink" title="默认参数 default parameter"></a>默认参数 default parameter</h3><p>如果不传递n的话，上面的调用会报错：缺少位置<strong>实参</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'n'</span></span><br></pre></td></tr></table></figure></p>
<p>这时候就可以靠默认参数来帮助我们省事，不用每次都给默认形参传递实参了</p>
<ol>
<li><p>函数定义时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>默认参数定义<strong>必须</strong>在所有的位置参数之后，并且默认参数的后面不能再有位置参数</li>
<li>默认参数的必须指向不变的对象，否则会掉坑<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，</span></span><br><span class="line"><span class="comment"># 它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</span></span><br><span class="line"><span class="comment"># 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的做法：通过None这个不变的默认参数来做</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数调用时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以不提供默认参数的实参，也可以提供</span></span><br><span class="line">func(<span class="string">'abc'</span>)  </span><br><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对于多个默认参数的情况，如果按顺序提供，可以不指定默认形参的名字；</span></span><br><span class="line"><span class="comment"># 否则需指定名字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x, n=<span class="number">1</span>, m=<span class="number">2</span>)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">func2(<span class="string">'abc'</span>, m=<span class="number">23</span>, n=<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>注意：不按顺序提供实参的情况仅仅适用于默认参数部分。也就是无论如何，必须先按顺序提供位置参数，之后提供的默认实参才有不按顺序一说。下面的调用是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(n=<span class="number">10</span>, <span class="string">'acb'</span>)</span><br><span class="line"><span class="comment"># output: SyntaxError: non-keyword arg after keyword arg</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53EF_u53D8_u53C2_u6570"><a href="#u53EF_u53D8_u53C2_u6570" class="headerlink" title="可变参数"></a>可变参数</h3><p>在定义函数的时候，传入的位置参数个数不确定的时候使用</p>
<p>不用可变参数怎么做？转化为list或tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">calc((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>利用可变参数就可以直接传入，不需要显示转化了<code>calc(1, 2, 3)</code></p>
<ol>
<li><p>函数定义<br>使用*表达式即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    <span class="comment"># the same with above</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：可以传入任意个数的实参，包括0个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于对已有的列表进行操作</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">calc(*nums)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：函数调用的时候，实参做了拷贝，原有的实参不变！</p>
<p>可变参数可以同时定义在位置参数后面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （2）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （3）</span></span><br><span class="line"><span class="comment"># output: 'abc', ('e', 'f', 'g')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x=<span class="string">'123'</span>, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （4）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （5）</span></span><br><span class="line"><span class="comment"># output: 'c', ('f', 'g')</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>优先匹配位置参数, 无论有没有默认值。有默认值覆盖默认值，没有默认值赋值。剩下来的部分才给可变参数！</li>
<li>注意(2)和(3)调用方式的不同</li>
<li>注意(4)和(5)结果的不同</li>
</ul>
<h3 id="u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09"><a href="#u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09" class="headerlink" title="关键字参数（keyword parameter）"></a>关键字参数（keyword parameter）</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">   print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：<br>可以只传入位置参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>也可以传入任意个数任意名字的关键字实参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>
<p>传入dict的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br></pre></td></tr></table></figure>
<p>注意：注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</p>
</li>
</ol>
<h3 id="u547D_u540D_u5173_u952E_u5B57_u53C2_u6570"><a href="#u547D_u540D_u5173_u952E_u5B57_u53C2_u6570" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>定义时可以有缺省值：由于指定名字，所以带缺省值的parameter不关心顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'beijing'</span>, job)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传入参数名(除非使用定义了的缺省值，连值也不传)，否则会报TypeError</span></span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53C2_u6570_u7684_u7EC4_u5408"><a href="#u53C2_u6570_u7684_u7EC4_u5408" class="headerlink" title="参数的组合"></a>参数的组合</h3><p>必须是如下顺序：<br><strong>必选参数、默认参数、可变参数/命名关键字参数和关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的</p>
<p>反之，接受任何参数的函数，可以定义为func(<em>args, *</em>kw)这种形式。这种定义并不好，实际上，没有通用的规则在一个接受任何参数的函数内部做处理。但是对于decorator等一些应用，接受任何参数的设定就非常有用，因为decorator不关心包装的函数参数是什么，它确实可能需要一个这样的机制来传参。</p>
<h3 id="u6CE8_u610F_u70B9_uFF1A"><a href="#u6CE8_u610F_u70B9_uFF1A" class="headerlink" title="注意点："></a>注意点：</h3><ol>
<li><p>关键字参数会覆盖位置参数的默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'a:%s, b:%s, c:%s'</span> % (a, b, c))</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)  <span class="comment"># 关键字参数会覆盖前面的默认值</span></span><br><span class="line"><span class="comment"># output: a:z, b:d, c:r</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数与默认参数不同</p>
<ul>
<li>在定义的适合，默认参数本质上还是给了默认值的位置参数，必须定义在关键字参数的前面；而关键字参数应该最后定义，并且需要<code>**</code>表达式</li>
<li>在调用时候，默认参数部分会优先匹配，匹配之后剩下来的才给关键字参数。所以在函数调用的时候谈论关键字参数实际上没有意义，它只是函数定义时的一个为了扩展用的占位符而已<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># output: a b c &#123;&#125;</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125; # 注意，全部先匹配了默认参数</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>, <span class="string">'d'</span>:<span class="string">'z'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;'d': 'z'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用kwargs为没有提供默认值的位置参数提供值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125;</span></span><br><span class="line"><span class="comment"># 如果kwargs里面没有为a提供值，那么就会报TypeError了</span></span><br><span class="line">func(**&#123;<span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'a'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Best_Practices_3A"><a href="#Best_Practices_3A" class="headerlink" title="Best Practices:"></a>Best Practices:</h3><ol>
<li><p><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP-3102</a>: 定义了keyworkd-only 参数（本质就是命名关键字参数），避免模糊不清地被位置参数匹配。（”keyword-only” arguments: arguments that can only be supplied by keyword and which will never be automatically filled in by a positional argument）</p>
<p>有时候使用者希望函数可以接受可变参数，同时接受一些以keword形式传递的实参。如果不允许在可变参数后面定义named-keyword参数的话，唯一的解决办法是同时定义<code>*args</code>和<code>**kwargs</code>，然后手动抽取其中的一些entry。<br>Why? 看实参传递的顺序，non-keyword实参 &gt; keyword实参。所以如果定义在可变参数前，可能会被位置参数匹配掉(也就是不是真正意义上的keyword参数，而可能被解释器认为是带默认值的位置参数)。</p>
<p>PEP3102允许在可变参数后面定义regular parameter,作为keyword-only arguments。永远不会被位置参数匹配，必须指定名字。</p>
<p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时有可变参数存在， 可变参数会suck up所有的non-keyword实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords</span><span class="params">(*wordlist, case_sensitive=False)</span>:</span></span><br><span class="line"><span class="comment"># 没有可变参数存在, * means不允许任何可变参数存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords2</span><span class="params">(*, case_sensitive)</span>:</span></span><br></pre></td></tr></table></figure>
<p>显然，case_sensitive只能以keyword的方式赋值，不会被位置参数匹配。</p>
</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="external">廖雪峰的Python教程</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP3102</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大数据生态圈技术总结（持续补充）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/"/>
    <id>http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><ol>
<li><p>磁盘</p>
<ul>
<li>HDFS</li>
<li>S3</li>
<li>Ceph</li>
<li>NFS</li>
<li>Gluster FS</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li>Tachyon</li>
<li>Spark</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u6570_u636E_u5E93"><a href="#u5206_u5E03_u5F0F_u6570_u636E_u5E93" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><ol>
<li><p>磁盘</p>
<ul>
<li>Cassandra</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
</li>
<li><p>内存 </p>
<ul>
<li>Redis</li>
<li>Memcached</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u8BA1_u7B97"><a href="#u5206_u5E03_u5F0F_u8BA1_u7B97" class="headerlink" title="分布式计算"></a>分布式计算</h3><ol>
<li><p>批处理</p>
<ul>
<li>Hadoop MapReduce</li>
<li>Spark(支持迭代)</li>
<li>Flink(支持迭代)</li>
</ul>
</li>
<li><p>流式计算</p>
<ul>
<li>Storm</li>
<li>Samza</li>
<li>Spark Streaming</li>
<li>Flink</li>
</ul>
</li>
<li><p>即席查询(ad-hoc)</p>
<ul>
<li>Hive</li>
<li>SparkSQL</li>
<li>Presto(Facebook)</li>
<li>Impala</li>
<li>Drill(Google Dremel的开源实现)</li>
</ul>
</li>
</ol>
<h3 id="u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406"><a href="#u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406" class="headerlink" title="资源调度与管理"></a>资源调度与管理</h3><ul>
<li>ZooKeeper</li>
<li>YARN</li>
<li>Mesos</li>
</ul>
<h3 id="u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h3><ul>
<li>StormMQ</li>
<li>RabbitMQ</li>
<li>ZeroMQ</li>
<li>Apache ActiveMQ</li>
<li>Jafka(LinkedIn)</li>
<li>Kafka(LinkedIn)</li>
</ul>
<h3 id="RPC_u6846_u67B6"><a href="#RPC_u6846_u67B6" class="headerlink" title="RPC框架"></a>RPC框架</h3><ul>
<li>Apache Avro</li>
<li>Thrift(Facebook)</li>
<li>Kyro</li>
</ul>
<h3 id="u96C6_u7FA4_u76D1_u63A7"><a href="#u96C6_u7FA4_u76D1_u63A7" class="headerlink" title="集群监控"></a>集群监控</h3><ul>
<li>Zabbix</li>
<li>Ganglia</li>
<li>Nagios</li>
<li>Ambari()</li>
</ul>
<h3 id="u6570_u636E_u6536_u96C6"><a href="#u6570_u636E_u6536_u96C6" class="headerlink" title="数据收集"></a>数据收集</h3><ul>
<li>Flume</li>
<li>Scribe(Facebook)</li>
<li>Logstash</li>
<li>Kafka</li>
</ul>
<h3 id="u56FE_u8BA1_u7B97_u6846_u67B6"><a href="#u56FE_u8BA1_u7B97_u6846_u67B6" class="headerlink" title="图计算框架"></a>图计算框架</h3><ul>
<li>Spark Graphx</li>
<li>PowerGraph</li>
<li>Giraph</li>
<li>Neo4j</li>
</ul>
<h3 id="u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60"><a href="#u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h3><ul>
<li>Spark MLlib</li>
<li>Mahout</li>
<li>PredictionIO</li>
</ul>
<h3 id="u641C_u7D22_u5F15_u64CE"><a href="#u641C_u7D22_u5F15_u64CE" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul>
<li>Lucene</li>
<li>Solr</li>
<li>ElasticSearch</li>
<li>Sphinx</li>
<li>SenseiDB</li>
</ul>
<h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><ul>
<li>OpenStack</li>
<li>Docker </li>
<li>Kubernetes(容器调度管理)</li>
</ul>
<h3 id="u57FA_u7840_u7ED3_u6784"><a href="#u57FA_u7840_u7ED3_u6784" class="headerlink" title="基础结构"></a>基础结构</h3><ul>
<li>LevelDB</li>
<li>SSTable(BigTable基础)</li>
<li>RecordIO(文件格式)</li>
<li>Flat Buffer(Google, 高效、跨平台的序列化库)</li>
<li>ProtocolBuffers(Google, 数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面)</li>
<li>Consistent Hashing</li>
<li>Netty(提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序)</li>
<li>BloomFilter</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.36dsj.com/archives/25042" target="_blank" rel="external">http://www.36dsj.com/archives/25042</a><br><a href="http://www.csdn.net/article/2015-09-11/2825674" target="_blank" rel="external">http://www.csdn.net/article/2015-09-11/2825674</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"><]]>
    </summary>
    
      <category term="大数据" scheme="http://paranoidq.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="攻略" scheme="http://paranoidq.github.io/tags/%E6%94%BB%E7%95%A5/"/>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="大数据" scheme="http://paranoidq.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim Commands]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/vim-commands/"/>
    <id>http://paranoidq.github.io/2016/05/27/vim-commands/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><h4 id="u79FB_u52A8"><a href="#u79FB_u52A8" class="headerlink" title="移动"></a>移动</h4><ul>
<li>文首：<code>gg</code> / <code>:0</code></li>
<li>文末：<code>shift + g</code> / <code>:$</code></li>
<li>行首：<code>0</code></li>
<li>行末：<code>$</code></li>
<li>到第一个不是空字符的位置：<code>^</code></li>
<li>到最后一个不是空字符的位置：<code>g_</code></li>
</ul>
<a id="more"></a>
<p>按单词移动：</p>
<ul>
<li>到下一个单词的开头：<code>w</code></li>
<li>到下一个单词的结尾：<code>e</code></li>
</ul>
<p>按匹配的单词移动：</p>
<ul>
<li>匹配光标所在的单词，移动到下一个：<code>*</code></li>
<li>匹配光标所在的单词，移动到上一个: <code>#</code></li>
</ul>
<p>按页移动：</p>
<ul>
<li>向下一页：<code>ctrl + F</code></li>
<li>向上一页：<code>ctrl + B</code></li>
<li>向下半页：<code>ctrl + D</code></li>
<li>向上半页：<code>ctrl + U</code></li>
</ul>
<h4 id="u63D2_u5165"><a href="#u63D2_u5165" class="headerlink" title="插入"></a>插入</h4><p>切换到插入模式的几种方式:</p>
<ul>
<li>在光标之前插入：<code>i</code></li>
<li>在行开始前插入：<code>I</code></li>
<li>在光标后面插入：<code>a</code></li>
<li>在行结束后插入：<code>A</code></li>
</ul>
<p>插入行：</p>
<ul>
<li>在当前位置下面插入一行，并进入编辑状态：<code>o</code></li>
<li>在当前位置上面插入一行，并进入编辑状态：<code>O</code></li>
</ul>
<h3 id="u6587_u672C_u64CD_u4F5C"><a href="#u6587_u672C_u64CD_u4F5C" class="headerlink" title="文本操作"></a>文本操作</h3><h4 id="u57FA_u672C_u884C_u64CD_u4F5C"><a href="#u57FA_u672C_u884C_u64CD_u4F5C" class="headerlink" title="基本行操作"></a>基本行操作</h4><p>复制</p>
<ul>
<li>复制一行：<code>yy</code></li>
<li>复制光标到行尾的部分：<code>y$</code></li>
<li>复制多行(1)：<code>Nyy</code> + ‘p’ (粘贴)</li>
<li>复制多行(2)：<code>6, 9 co 12</code> (复制6行和9行中间的部分到12行后面)</li>
</ul>
<p>复制大量的行：</p>
<ol>
<li>光标移到起始行，输入ma</li>
<li>光标移到结束行，输入mb</li>
<li>光标移到粘贴行，输入mc</li>
<li>然后 :’a,’b co ‘c 把 co 改成 m 就成剪切了</li>
</ol>
<p>粘贴</p>
<ul>
<li>粘贴：<code>p</code></li>
</ul>
<p>删除</p>
<ul>
<li>删除光标后一个字符：<code>x</code></li>
<li>删除光标到行尾的部分：<code>d$</code></li>
<li>删除单行：<code>dd</code> / <code>1d</code></li>
<li>删除多行(1)：<code>1, Nd</code> / <code>Ndd</code>(删除包含光标所在行的下面N行)</li>
<li>删除多行(2)：<code>:1, 4 de</code></li>
</ul>
<p>替换</p>
<ul>
<li>替换从光标位置到后一个单词结尾的字符：<code>cw</code></li>
</ul>
<h4 id="u4EFB_u610F_u533A_u95F4_u7684_u6587_u672C_u64CD_u4F5C"><a href="#u4EFB_u610F_u533A_u95F4_u7684_u6587_u672C_u64CD_u4F5C" class="headerlink" title="任意区间的文本操作"></a>任意区间的文本操作</h4><p>首先进入visual模式，直接按v键进入visual模式，然后<code>v+ j/k/h/l</code>进行文本选择</p>
<ul>
<li>剪切：<code>d</code></li>
<li>复制：<code>y</code></li>
<li>粘贴：<code>p</code></li>
</ul>
<h4 id="u884C_u5757_u64CD_u4F5C"><a href="#u884C_u5757_u64CD_u4F5C" class="headerlink" title="行块操作"></a>行块操作</h4><h3 id="u64A4_u9500_u64CD_u4F5C"><a href="#u64A4_u9500_u64CD_u4F5C" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul>
<li>撤销上一个命令： <code>u</code></li>
<li>反撤销：<code>ctrl + r</code> </li>
</ul>
<h3 id="u641C_u7D22_u64CD_u4F5C"><a href="#u641C_u7D22_u64CD_u4F5C" class="headerlink" title="搜索操作"></a>搜索操作</h3><ul>
<li>搜索：<code>/pattern</code></li>
<li>下一个：<code>n</code></li>
<li>上一个：<code>N</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><h4 id="u79FB_u52A8"><a href="#u79FB_u52A8" class="headerlink" title="移动"></a>移动</h4><ul>
<li>文首：<code>gg</code> / <code>:0</code></li>
<li>文末：<code>shift + g</code> / <code>:$</code></li>
<li>行首：<code>0</code></li>
<li>行末：<code>$</code></li>
<li>到第一个不是空字符的位置：<code>^</code></li>
<li>到最后一个不是空字符的位置：<code>g_</code></li>
</ul>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://paranoidq.github.io/tags/vim/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SSH Principles（总结和笔记）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/SSH-Principles/"/>
    <id>http://paranoidq.github.io/2016/05/27/SSH-Principles/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T16:01:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="meta"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="meta"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><ol>
<li>基本流程：<ul>
<li>client请求登陆remote server</li>
<li>server发送公钥给client，并告知client发送自己的密码</li>
<li>client用公钥加密密码，发送给server</li>
<li>server用私钥解密密码，如果成功，就允许用户登陆</li>
</ul>
</li>
<li>为何安全：<ul>
<li>全程不传输私钥，及时截获报文，只要私钥不泄露，就不能获取密码</li>
<li>密码由随机的公钥加密，可换</li>
</ul>
</li>
<li>为何有风险：<ul>
<li>如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的</li>
<li>中间人攻击（Man-in-the-middle attack）：如果攻击者插在用户与远程主机之间（比如在公共的wifi区域）用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了</li>
</ul>
</li>
</ol>
<h3 id="u4E24_u79CD_u767B_u5F55_u65B9_u5F0F"><a href="#u4E24_u79CD_u767B_u5F55_u65B9_u5F0F" class="headerlink" title="两种登录方式"></a>两种登录方式</h3><h4 id="u53E3_u4EE4_u767B_u5F55"><a href="#u53E3_u4EE4_u767B_u5F55" class="headerlink" title="口令登录"></a>口令登录</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'host (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。然后要求用户输入密码<br>    <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'host,12.18.429.21'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts.</span><br><span class="line">Password: (enter password)</span><br></pre></td></tr></table></figure></p>
<p>保存远程主机的公钥在<code>$HOME/.ssh/known_hosts</code>中，以后连接主机时client能识别公钥已经保存在本地，跳过警告部分。（但是仍然需要输入密码）</p>
<p><code>/etc/ssh/ssh_known_hosts</code>保存对所有用户可信的远程主机公钥</p>
<h4 id="u516C_u94A5_u767B_u5F55"><a href="#u516C_u94A5_u767B_u5F55" class="headerlink" title="公钥登录"></a>公钥登录</h4><blockquote>
<p>原理：</p>
</blockquote>
<ol>
<li>用户将自己的公钥储存在远程主机上。</li>
<li>登录时，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。</li>
<li>远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码</li>
</ol>
<blockquote>
<p>操作：</p>
</blockquote>
<p>用户生成自己的公钥：在<code>$HOME/.ssh</code>下会生成<code>id_rsa.pub</code>和<code>id_rsa</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>拷贝公钥到server：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-copy-id user<span class="variable">@host</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="variable">$ </span>scp /Users/paranoidq/.ssh/id_rsa.pub paranoidq<span class="variable">@192</span>.<span class="number">168.235</span>.<span class="number">131</span><span class="symbol">:/home/paranoidq/</span>.ssh/authorized_keys </span><br><span class="line"><span class="comment"># 但是scp不能附加多个authorized_keys，所以貌似只能支持一个用户一个公钥！</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于ssh-copy-id的过程：</p>
</blockquote>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh user<span class="variable">@host</span> <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~<span class="regexp">/.ssh/id</span>_rsa.pub</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li><code>$ ssh user@host</code>表示登录远程主机；</li>
<li><code>mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>表示登录后在远程shell上执行的命令</li>
<li><code>mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个</li>
<li><code>cat &gt;&gt; .ssh/authorized_keys &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件<code>authorized_keys</code>的末尾</li>
</ol>
<p>注：有必要学习一下bash和shell的知识了，推荐Mendel Cooper的<a href="http://www.tldp.org/LDP/abs/html/" target="_blank" rel="external">《Advanced Bash: Scrpiting Guide》</a></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="external">廖雪峰的官方网站，ssh原理与运用</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u524D_u63D0"><a href="#u524D_u63D0" class="headerlink" title="前提"></a>前提</h3><p>服务器需要开启远程服务<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 针对fedora的检测方法</span></span><br><span class="line">service sshd status</span><br><span class="line"><span class="meta"># 通用检测方法：</span></span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line"><span class="meta"># 开启 in fedora</span></span><br><span class="line">service sshd start</span><br><span class="line"><span class="meta"># 开启 in ubuntu</span></span><br><span class="line">/etc/init.d/ssh start[/stop/restart]</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ssh" scheme="http://paranoidq.github.io/tags/ssh/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java.util.ResourceBundle 源码分析]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/ResourceBundle-source-code-inside/"/>
    <id>http://paranoidq.github.io/2016/05/27/ResourceBundle-source-code-inside/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="ResourceBundle_u7B80_u4ECB"><a href="#ResourceBundle_u7B80_u4ECB" class="headerlink" title="ResourceBundle简介"></a>ResourceBundle简介</h3><p>顾名思义，ResourceBundle主要就是管理Java程序的一些配置资源的工具类。但是这个管理与一般管理不同的地方在于:</p>
<ul>
<li><p>locale-independent, 即ResourceBundle封装了本地化的读取方法，并且根据Locale参数读对应的本地化配置，从而能够使程序自动在不同地区载入不同的配置文件(<code>name_CN.properties</code>, <code>name_US.properties</code>等)。JavaDoc说法:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">be </span>easily localized, <span class="keyword">or </span>translated, into <span class="keyword">different </span>languages</span><br><span class="line"><span class="number">2</span>. handle <span class="keyword">multiple </span>locales <span class="built_in">at</span> once</span><br><span class="line"><span class="number">3</span>. <span class="keyword">be </span>easily modified later to support even more locales</span><br></pre></td></tr></table></figure>
</li>
<li><p>在没有指定Locale的情况下，自动载入默认配置<code>name.properties</code></p>
</li>
<li>带有缓存功能</li>
<li>线程安全</li>
</ul>
<h3 id="ResourceBundle_u4F7F_u7528"><a href="#ResourceBundle_u4F7F_u7528" class="headerlink" title="ResourceBundle使用"></a>ResourceBundle使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceBundleUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourceBundleUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResourceBundle <span class="title">newResourceBundle</span><span class="params">(String resourcePath)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ResourceBundle.getBundle(resourcePath, Locale.ENGLISH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResourceBundle <span class="title">newResourceBundle</span><span class="params">(String resourcePath, Locale locale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceBundle.getBundle(resourcePath, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ResourceBundle rb = ResourceBundleUtil.newResourceBundle(<span class="string">"with_classpath"</span>);</span><br><span class="line">        String value1 = rb.getString(<span class="string">"key1"</span>);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，如果不在clsspath的root目录下，需要指定全名</span></span><br><span class="line">        ResourceBundle rb2 = ResourceBundleUtil.newResourceBundle(<span class="string">"i18n.within_folder"</span>);</span><br><span class="line">        value1 = rb2.getString(<span class="string">"key1"</span>);</span><br><span class="line">        System.out.println(value1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义ResourceBundle例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyResources</span> <span class="keyword">extends</span> <span class="title">ResourceBundle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handleGetObject</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(<span class="string">"okKey"</span>)) <span class="keyword">return</span> <span class="string">"Ok"</span>;</span><br><span class="line">        <span class="keyword">if</span> (key.equals(<span class="string">"cancelKey"</span>)) <span class="keyword">return</span> <span class="string">"Cancel"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// keySet() is inherted from super class</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title">getKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(keySet());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Overrides handleKeySet() so that the getKeys() implementation</span></span><br><span class="line">    <span class="comment">// can rely on the keySet() value.</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">handleKeySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(<span class="string">"okKey"</span>, <span class="string">"cancelKey"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceBundle_u7C7B_u7ED3_u6784"><a href="#ResourceBundle_u7C7B_u7ED3_u6784" class="headerlink" title="ResourceBundle类结构"></a>ResourceBundle类结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle</span><br><span class="line">    |__ ListResourceBundle</span><br><span class="line">    |__ PropertyResourceBundle</span><br></pre></td></tr></table></figure>
<h3 id="ResourceBundle_u6E90_u7801_u7279_u6027"><a href="#ResourceBundle_u6E90_u7801_u7279_u6027" class="headerlink" title="ResourceBundle源码特性"></a>ResourceBundle源码特性</h3><h4 id="u5DE5_u5382_u65B9_u6CD5"><a href="#u5DE5_u5382_u65B9_u6CD5" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>通过工厂方法<code>getBundle()</code>返回ResourceBundle的子类对象，处理不同的配置资源加载过程。</p>
<h4 id="u5B9E_u73B0_u7C7B"><a href="#u5B9E_u73B0_u7C7B" class="headerlink" title="实现类"></a>实现类</h4><p>ResourceBundle本身是abstract，实际使用的是两个实现类。<br>ListResourceBundle将配置资源看做key/value组成的列表，而PropertyResourceBundle使用properties来维护配置资源。</p>
<p>可以自己实现ResourceBundle，需要实现两个方法：<code>handleGetObject()</code> 和 <code>getKeys()</code>。另外需要注意的是，自己实现的ResourceBundle类要保证线程安全性，因为可能被多个线程同时使用。（ResourceBundle的非abstract方法和两个已知实现类的方法都是线程安全的）</p>
<h4 id="u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>ResourceBundle的非abstract方法和两个已知实现类的方法都是线程安全的。<br>另外，自己实现的ResourceBundle类的<code>handleGetObject()</code>和<code>getKeys()</code>要保证线程安全性，因为可能被多个线程同时使用。</p>
<h4 id="u8D44_u6E90_u52A0_u8F7D_u8FC7_u7A0B_u7684_u63A7_u5236_uFF1AResourceBundle-Control"><a href="#u8D44_u6E90_u52A0_u8F7D_u8FC7_u7A0B_u7684_u63A7_u5236_uFF1AResourceBundle-Control" class="headerlink" title="资源加载过程的控制：ResourceBundle.Control"></a>资源加载过程的控制：ResourceBundle.Control</h4><p>可以控制资源的搜索顺序、bundle的格式或缓存方式等。两种方式控制ResourceBundle加载配置资源的过程：</p>
<ol>
<li>在<code>getBundle()</code>的参数中指定Control实例</li>
<li>通过指定<code>ResourceBundleControlProvider</code>的实现类。这个实现类会在ResouceBundle类被加载的时候就检测到，如果实现类针对某一个base name提供了Control对象，那么加载这个base name时的默认行为就会被改变。如果有多个providers针对同一个base name，那么选择第一个provider。</li>
</ol>
<p>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle.getBundle(String, Locale, ClassLoader, Control);</span><br></pre></td></tr></table></figure>
<h4 id="Cache_management"><a href="#Cache_management" class="headerlink" title="Cache management"></a>Cache management</h4><p><code>getBundle()</code>返回的ResourceBundle会被默认缓存起来，从而下次请求同样的配置名时，会返回缓存过的ResourceBundle实例。<br>使用者可以选择不缓存、控制缓存时间（通过<code>time-to-live</code>变量），也可以清空cache。<br>相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResourceBundle.clearCache();</span><br><span class="line">ResourceBundle.Control.getTimeToLive();</span><br><span class="line">ResourceBundle.Control.needsReload();</span><br></pre></td></tr></table></figure>
<h3 id="ResourceBundle_u6E90_u7801_u5206_u6790"><a href="#ResourceBundle_u6E90_u7801_u5206_u6790" class="headerlink" title="ResourceBundle源码分析"></a>ResourceBundle源码分析</h3><h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>java.util.ResourceBundle源码(JDK1.8)<br><a href="http://blog.csdn.net/haiyan0106/article/details/2257725" target="_blank" rel="external">http://blog.csdn.net/haiyan0106/article/details/2257725</a><br><a href="http://san-yun.iteye.com/blog/1683558" target="_blank" rel="external">Java WeakReference与SoftReference</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="ResourceBundle_u7B80_u4ECB"><a href="#ResourceBundle_u7B80_u4ECB" class="headerlink" title="ResourceBundle简介"></a>ResourceBundle简介</]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="resourcebundle" scheme="http://paranoidq.github.io/tags/resourcebundle/"/>
    
      <category term="jdk" scheme="http://paranoidq.github.io/tags/jdk/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python super详解（译 + 进一步理解）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/python-super-considered-super/"/>
    <id>http://paranoidq.github.io/2016/05/27/python-super-considered-super/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21"><a href="#u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21" class="headerlink" title="翻译：Python’s super() considered super!"></a>翻译：Python’s super() considered super!</h2><h3 id="u57FA_u7840"><a href="#u57FA_u7840" class="headerlink" title="基础"></a>基础</h3><p>如果你没有惊讶于Python内置的super()，那么很可能你并没有真正知道它能做什么以及它如何有效的使用。本文章就主要在已有的python super()解释的基础上做出进一步的深入，主要包括：</p>
<ul>
<li>提供了实际的使用cases</li>
<li>给出了理论模型，演示它如何工作</li>
<li>展示如何使super()发挥它的作用</li>
<li>使用super()的建议</li>
<li>真实的例子</li>
</ul>
<p>本文的例子同时适用于python2和python3版本</p>
<p>首先，一个例子：子类继承内置的类，并且扩展了内置类的方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoingDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Setting to %r'</span> % (key, value))</span><br><span class="line">        super().__setitem__(key, value)</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中，LoggingDict完成了dict的同样的工作——update元素，只不过扩展了功能，在update元素之前先打log了，然后通过super()将实际update的工作<strong>代理</strong>给了dict对象</p>
<p>如果没有super()，我们可以这样做：<code>dict.__setitem__(self, key, value)</code>，但是问题在于：这种硬编码的方式不利于程序的扩展性。利用super()实际上是一种`<strong>间接引用</strong>（computed indirect reference）。</p>
<p>间接引用的好处之一：<strong>隔离</strong>。不用在是函数内部制定代理类的具体名字。如果要修改base class为另一个类，那么<code>super()</code>会自动切换给代理类，而硬编码的方式则要修改具体实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoingDict</span><span class="params">(SomeOtherMapping)</span>:</span>        <span class="comment"># new base class</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Setting to %r'</span> % (key, value))</span><br><span class="line">        super().__setitem__(key, value)     <span class="comment"># no change needed</span></span><br></pre></td></tr></table></figure></p>
<p>间接引用的另一个好处：<strong>动态</strong>。可以在运行时自由指定间接引用指向的类。引用指向的具体计算方式依赖两点：</p>
<ol>
<li>调用super的class</li>
<li>实例的基类的继承树</li>
</ol>
<p>第一点往往与源码有关，在例子中，super()的调用者是<code>LoggingDict.__setitem__()</code>，这是固定的。<br>第二点则是关键的动态性所在（我们可以创建具有复杂继承关系的子类）。一个logging ordered dictionary，不改变我们已有的类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingOD</span><span class="params">(LoggingDict, collections.OrderedDict)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>新类的继承树：<code>LoggingOD, LoggingDict, OrderedDict, dict, object</code>。注意：OrderedDict在dict的前面，因此，调用super()的<code>LoggingDict.__setitem__()</code>现在就把具体的upate任务代理给了OrderedDict，而不是上一个例子中的dict。</p>
<p>仔细考虑一下：在这个例子中，我们并没有改变LoggingDict的源码，而是新增了一个子类，这个新增子类的唯一逻辑就是组合了两个已有的类，并且控制他们的继承顺序。而super()则自动根据新类定义的继承顺序发挥了它的动态性能力！</p>
<h3 id="u57FA_u7C7B_u7684_u67E5_u627E_u987A_u5E8F"><a href="#u57FA_u7C7B_u7684_u67E5_u627E_u987A_u5E8F" class="headerlink" title="基类的查找顺序"></a>基类的查找顺序</h3><p>实际上，这里我称为检索顺序或继承树的说法，正式的叫法应该是：<strong>方法解析顺序(Method Resolution Order, MRO)</strong>。想要知道一个类的MRO可以用<code>__mro__</code>属性：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pprint(LoggingOD.__mro__)</span><br><span class="line">(&lt;class '__main__.LoggingOD'&gt;,</span><br><span class="line"> &lt;class '__main__.LoggingDict'&gt;,</span><br><span class="line"> &lt;class 'collections.OrderedDict'&gt;,</span><br><span class="line"> &lt;class 'dict'&gt;,</span><br><span class="line"> &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure></p>
<p>如果想按照我们想的MRO创建子类，那么首先需要了解MRO的计算机制：</p>
<blockquote>
<p>MRO的序列包括：本类，基类以及基类的基类们，直到object为止。一个类始终出现在它的基类前面，如果有多个同级基类，那么这些基类的顺序依照声明的顺序排列。</p>
</blockquote>
<p>上述例子遵从MRO的规范：</p>
<ul>
<li>LoggingOD在它的基类LogginDict和OrderedDict前面</li>
<li>LoggingDict在OrderedDict前面，因为<code>LoggingOD.__bases__</code>的声明顺序是(LoggingDict, OrderedDict)</li>
<li>LogginDict在它的基类dict前面</li>
<li>OrderedDict在它的基类dict前面</li>
<li>dict在它的基类object前面</li>
</ul>
<p>解析约束的过程被称作<code>线性化(linearizatoin)</code>。有很多论文研究这方面的内容，但是我们只需要知道两点即可：</p>
<ul>
<li>基类永远出现在派生类后面</li>
<li>如果有多个基类，基类的相对顺序保持不变。</li>
</ul>
<h3 id="u5B9E_u8DF5_u5EFA_u8BAE"><a href="#u5B9E_u8DF5_u5EFA_u8BAE" class="headerlink" title="实践建议"></a>实践建议</h3><p>super()的作用是将本类方法的调用代理给继承树中的某一个基类实例去完成。这里给出三个注意点：</p>
<ul>
<li>保证通过super()调用的基类方法必须存在</li>
<li>调用者和被调用者需要有匹配的函数签名</li>
<li>调用super()的方法，每次出现都同样必须使用super()</li>
</ul>
<p>1): 我们先看这一点：调用者的参数与被调用方法的参数一致。<br>这跟普通的方法调用不同，普通的方法调用在的时候被调用的方法是已知的，但是有了super()，在本类编码的时候被super()调用的方法是未知的。想象一下，我们可以之后定义一个subclass，从而在正在编写的class的MRO中引入新的类，改变MRO的顺序，从而可能改变super()实际调用的类！</p>
<p>我们的方法是：利用位置参数指定固定的签名。例如，在<code>__setitem__()</code>中，就保持了固定的两个位置参数：key和value。这种方法在LoggingDict也有体现，即<code>__setitem__()</code>与dict有同样的函数签名。</p>
<p>更灵活的方法：让继承树中的所有方法都接受这样的参数:<code>关键字参数 + 可变关键字参数</code>，并且每一层取走自己想要的参数，并通过<code>**kwargs</code>向上一层forward余下的参数，最终在调用链的最后一层使得可变关键字参数为空(<code>object.__init__()</code>不需要任何参数)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">classs Shape:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, shapename, **kwargs)</span>:</span></span><br><span class="line">        self.shapename = shapename</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColoredShape</span><span class="params">(Shape)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, color, **kwargs)</span>:</span></span><br><span class="line">        self.color = color</span><br><span class="line">        super().__init(**kwargs)</span><br><span class="line"></span><br><span class="line">cs = ColoredShape(color=<span class="string">'red'</span>, shapename=<span class="string">'circule'</span>)</span><br></pre></td></tr></table></figure></p>
<p>2): 如何确定目标函数存在？<br>上面的例子就是最简单的case，即object有我们调用的方法，因此无论什么样的继承树都会有我们的目标方法，不会出现AttributeError。</p>
<p>那么对于object不存在的方法，我们的处理方法是：编写一个root类包含我们的目标方法，并且在object前面被调用。这个root类的职责就是’吞掉’方法的调用，不让super()继续向上层类传递（因为上层类没有我们的目标方法了，再传递就会最终出现AttributeError）。</p>
<p>Root的draw方法还可以利用防御性编程的策略，即用assert来确保调用链的上层没有draw方法了。这是为了避免子类可能错误的继承了一个没有声明Root为基类的类。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Root：</span><br><span class="line">    def draw(self):</span><br><span class="line">        # the delegatioin chain stops here</span><br><span class="line">        assert not hasattr(super(), 'draw')</span><br><span class="line"></span><br><span class="line">class Shape(Root):</span><br><span class="line">    def __init__(self, shapename, **kwargs):</span><br><span class="line">        self.shapename = shapename</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    def draw(self):</span><br><span class="line">        print('Drawing. Setting shape to: ', self.shapename)</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line">class ColoredShape(Shape):</span><br><span class="line">    def __init__(self, color, **kwargs):</span><br><span class="line">        self.color = color</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    def draw(self):</span><br><span class="line">        print('Drawing. Setting color to: ', self.color)</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line">cs = ColoredShape(color='blue', shapename='square')</span><br><span class="line">cs.draw()</span><br></pre></td></tr></table></figure></p>
<p>如果一个子类希望在MRO中引入其他类，那么这些其他类也必须继承自Root，从而确保draw方法不会到达object，而无法被Root.draw阻止下来。这个约定必须写在文档中，就像pyhon中所有的自定义异常都必须继承自BaseException一样。</p>
<p>3): 调用链的每层函数的调用都加上super()方法即可，这是约定。</p>
<h3 id="u5982_u4F55_u5F15_u5165_u2019_u5F02_u7C7B_u2019_uFF08non-cooperative_class_uFF09"><a href="#u5982_u4F55_u5F15_u5165_u2019_u5F02_u7C7B_u2019_uFF08non-cooperative_class_uFF09" class="headerlink" title="如何引入’异类’（non-cooperative class）"></a>如何引入’异类’（non-cooperative class）</h3><p>有时候，我们也要想引入一些第三方的类，这些类并没有针对super设计或者没有遵循Root的约定。解决方法是：利用适配器包装一下。<br>例如下面的Moveable类并没有super()调用，并且它的<code>__init__()</code>方法函数签名与object不一致，并且它没有继承Root。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moveable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Drawing at position: '</span>, self.x, self.y)</span><br></pre></td></tr></table></figure></p>
<p>如果你希望把这个类引入ColoredShape的层次中，你需要做一个adapter：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoveableAdapter</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, **kwargs)</span>:</span></span><br><span class="line">        self.moveable = Moveable(x, y)</span><br><span class="line">        super().__init__(**kwargs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.moveable.draw()</span><br><span class="line">        super().draw()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovableColoredShape</span><span class="params">(ColoredShape, MoveableAdapter)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">MovableColoredShape(color=<span class="string">'red'</span>, shapename=<span class="string">'triangle'</span>,</span><br><span class="line">                    x=<span class="number">10</span>, y=<span class="number">20</span>).draw()</span><br></pre></td></tr></table></figure></p>
<h3 id="u539F_u6587"><a href="#u539F_u6587" class="headerlink" title="原文"></a>原文</h3><p><a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a></p>
<h2 id="u8FDB_u4E00_u6B65_u7406_u89E3"><a href="#u8FDB_u4E00_u6B65_u7406_u89E3" class="headerlink" title="进一步理解"></a>进一步理解</h2><h3 id="super_u7684_u672C_u8D28"><a href="#super_u7684_u672C_u8D28" class="headerlink" title="super的本质"></a>super的本质</h3><p>主要来自于<a href="http://zhihu.com/question/20040039/answer/57883315" target="_blank" rel="external">知乎-laike9m的回答</a>，少量删改。</p>
<p>不要一说到 super 就想到基类！super 指的是 MRO 中的下一个类！<br>super干的事情其实是这个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">super</span><span class="params">(cls, inst)</span>:</span></span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    <span class="keyword">return</span> mro[mro.index(cls) + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>两个参数分别作了两件事情:</p>
<ol>
<li>inst负责生成MRO的list</li>
<li>通过cls定位当前的MRO中的index,并返回mro[index+1]</li>
</ol>
<p>一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'this is root'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter B'</span>)</span><br><span class="line">        <span class="comment"># print(self)  # &lt;__main__.D object at 0x...&gt;</span></span><br><span class="line">        super().__init__()  <span class="comment"># python3中不用写成super(B, self).__init__()</span></span><br><span class="line">        print(<span class="string">'leave B'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(Root)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'enter C'</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">'leave c'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">print(D.__mro__)</span><br><span class="line">print(B.__mro__)</span><br><span class="line">print(C.__mro__)</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enter b</span><br><span class="line">enter c</span><br><span class="line">this is root</span><br><span class="line">leave c</span><br><span class="line">leave b</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.C'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br><span class="line">(<span class="name">&lt;class</span> '__main__.B'&gt;, &lt;class '__main__.Root'&gt;, &lt;class 'object'&gt;)</span><br></pre></td></tr></table></figure></p>
<p>因此，实际上super()调用的时MRO中的下一个类的对应方法，所以不难理解enter b之后是enter c而不是thi is root。因为C是B的下一个，至于为什么C是下一个，那就要看上文翻译中讲的MRO规范了。</p>
<p>需要注意的是，这里的MRO是self生成的，指的是self这个instance对应的类的MRO，self不同，MRO也不同。例如d的MRO就是第一行MRO，而如果instance是B，则MRO就是第二行了。而在上面的例子中，self一直是d。super().func是把实例的MRO中相对于当前类的下一个类的func执行，这个实例并非一定是当前类的，并且如果下一个类的func不再以super的方式调用，则调用终止（但是不建议，除非到了object或者Root）。</p>
<p>注意super继承只能用于新式类，用于经典类时就会报错。</p>
<ul>
<li>新式类：必须有继承的类，如果没什么想继承的，那就继承objcet</li>
<li>经典类：没有基类，如果此时调用super就会出现错误：“super() argument 1 must be type, not classobj”</li>
</ul>
<h3 id="super_u7528_u5728_u4F55_u5904_uFF1F"><a href="#super_u7528_u5728_u4F55_u5904_uFF1F" class="headerlink" title="super用在何处？"></a>super用在何处？</h3><p>主要来自于<a href="http://zhihu.com/question/20040039/answer/13772641" target="_blank" rel="external">知乎-松鼠奥利奥的的回答</a>，少量删改。</p>
<p>super主要用于解决多继承的问题，直接用类名调用基类的方法在单继承的时候没问题，但是如果使用多继承，则会涉及到查找顺序（MRO）、重复调用（钻石继承）等问题。</p>
<p>如果没有复杂的继承结构，super作用不大。而复杂的继承结构本身就是不良设计。对于多重继承的用法，现在比较推崇 Mixin 的方式，也就是</p>
<ul>
<li>普通类多重继承只能有一个普通父类和若干个 Mixin 类（保持主干单一）</li>
<li>Mixin 类不能继承普通类（避免钻石继承）</li>
<li>Mixin 类应该单一职责（参考 Java 的 interface 设计，Mixin 和此极其相似，只不过附带实现而已）<br>如果按照上述标准，只使用 Mixin形式的多继承，那么不会有钻石继承带来的重复方法调用，也不会有复杂的查找顺序 —— 此时 super 是可以有无的了，用不用全看个人喜好，只是记得千万别和类名调用的方式混用就好。</li>
</ul>
<p>Python的多继承类是通过mro的方式来保证各个基类的函数被逐一调用，而且保证每个基类函数只调用一次（如果每个类都使用super）</p>
<h3 id="u6E90_u7801_u7EA7_u522B_u7684_u89E3_u91CA"><a href="#u6E90_u7801_u7EA7_u522B_u7684_u89E3_u91CA" class="headerlink" title="源码级别的解释"></a>源码级别的解释</h3><p><a href="http://blog.csdn.net/johnsonguo/article/details/585193" target="_blank" rel="external">http://blog.csdn.net/johnsonguo/article/details/585193</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_super_21"><a href="#u7FFB_u8BD1_uFF1APython_u2019s_super_28_29_considered_supe]]>
    </summary>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="super" scheme="http://paranoidq.github.io/tags/super/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac中如何查找Java的路径]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Mac-java-config/"/>
    <id>http://paranoidq.github.io/2016/05/27/Mac-java-config/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u65B9_u6CD52_uFF1A"><a href="#u65B9_u6CD52_uFF1A" class="headerlink" title="方法2："></a>方法2：</h3><p>step-wise的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> java</span><br></pre></td></tr></table></figure>
<p>如果输出的时/usr/bin/java, 证明是链接，需要找到链接的source<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls <span class="_">-l</span> `<span class="built_in">which</span> java`</span><br></pre></td></tr></table></figure></p>
<p>输出为实际的java安装路径: <code>rwxr-xr-x  1 root  wheel  74 11 25 13:36 /usr/bin/java -&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</code></p>
<p>如果/usr/bin/java指向的仍然是一个symbolic link, 那么继续执行以下命令，直到找到source为止 </p>
<p>[注]</p>
<p>ls -l ` which java`</p>
<p>单引号把Linux命令视为字符集合。反引号会强迫执行Linux命令。和<code>$()</code>一样。在执行一条命令时，会先将其中或者是<code>$()</code> 中的语句当作命令执行一遍，再将结果加入到外层命令中执行</p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac" target="_blank" rel="external">http://stackoverflow.com/questions/18144660/what-is-path-of-jdk-on-mac</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u65B9_u6CD51_uFF1A"><a href="#u65B9_u6CD51_uFF1A" class="headerlink" title="方法1："></a>方法1：</h3><p>最直接的方法，运行以下命令可以列出系统的default java版本和所有备选的java版本<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/jav<span class="built_in">a_home</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="mac" scheme="http://paranoidq.github.io/tags/mac/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 插件NERDTree命令]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/NERDTree-commands/"/>
    <id>http://paranoidq.github.io/2016/05/27/NERDTree-commands/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">h</span>    光标 focus 左侧树形目录</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">l</span>    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">w</span>    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">r</span>    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line"><span class="keyword">s</span>       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line"><span class="keyword">x</span>       合拢选中结点的父目录</span><br><span class="line"><span class="keyword">X</span>       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line"></span><br><span class="line"># 双击    相当于 NERDTree-o (Mac下无效...)</span><br><span class="line"># 中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line"></span><br><span class="line"><span class="keyword">D</span>       删除当前书签</span><br><span class="line"></span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line"><span class="keyword">K</span>       跳到当前目录下同级的第一个结点</span><br><span class="line"><span class="keyword">J</span>       跳到当前目录下同级的最后一个结点</span><br><span class="line"><span class="keyword">k</span>       跳到当前目录下同级的前一个结点</span><br><span class="line"><span class="keyword">j</span>       跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line"><span class="keyword">r</span>       递归刷新选中目录</span><br><span class="line"><span class="keyword">R</span>       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单 #！！！然后根据提示进行文件的操作如新建，重命名等</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line"></span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line"></span><br><span class="line"><span class="keyword">q</span>       关闭 NerdTree 窗口</span><br><span class="line">?       切换是否显示 Quick Help</span><br></pre></td></tr></table></figure>
<p>操作tab<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">tabnew</span> [++<span class="keyword">opt</span>选项] ［＋cmd］ 文件      建立对指定文件新的<span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabc</span>   关闭当前的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabo</span>   关闭所有其他的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabs</span>   查看所有打开的 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabp</span>   前一个 <span class="keyword">tab</span></span><br><span class="line">:<span class="keyword">tabn</span>   后一个 <span class="keyword">tab</span></span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT      前一个 <span class="keyword">tab</span></span><br><span class="line">gt      后一个 <span class="keyword">tab</span></span><br><span class="line"></span><br><span class="line">MacVim 还可以借助快捷键来完成 <span class="keyword">tab</span> 的关闭、切换</span><br><span class="line">cmd+<span class="keyword">w</span>   关闭当前的 <span class="keyword">tab</span></span><br><span class="line">cmd+&#123;   前一个 <span class="keyword">tab</span></span><br><span class="line">cmd+&#125;   后一个 <span class="keyword">tab</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">h</span>    光标 focus 左侧树形目录</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">l</span>    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">w</span>    光标自动在左右侧窗口切换 #！！！</span><br><span class="line">ctrl + <span class="keyword">w</span> + <span class="keyword">r</span>    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://paranoidq.github.io/tags/vim/"/>
    
      <category term="nerdtree" scheme="http://paranoidq.github.io/tags/nerdtree/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近几年前端技术盘点以及2016年技术发展方向(好文，转)]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/front-end-trend/"/>
    <id>http://paranoidq.github.io/2016/05/27/front-end-trend/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barret]]>
    </summary>
    
      <category term="前端" scheme="http://paranoidq.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://paranoidq.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Producer and Consumer]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/java-producer-and-consumer/"/>
    <id>http://paranoidq.github.io/2016/05/27/java-producer-and-consumer/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29" class="headerlink" title="生产者消费者模式（以下简称PC)"></a>生产者消费者模式（以下简称PC)</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<code>阻塞队列就相当于一个缓冲区</code>，平衡了生产者和消费者的处理能力。</p>
<a id="more"></a>
<h4 id="u4E3A_u4EC0_u4E48_u4F7F_u7528PC_u6A21_u5F0F"><a href="#u4E3A_u4EC0_u4E48_u4F7F_u7528PC_u6A21_u5F0F" class="headerlink" title="为什么使用PC模式"></a>为什么使用PC模式</h4><ul>
<li>解耦</li>
<li>缓冲</li>
<li>兼容不同端的处理能力差异</li>
</ul>
<h3 id="Java_u5B9E_u73B0_u65B9_u5F0F"><a href="#Java_u5B9E_u73B0_u65B9_u5F0F" class="headerlink" title="Java实现方式"></a>Java实现方式</h3><h4 id="1-_wait_28_29/nofify_28_29"><a href="#1-_wait_28_29/nofify_28_29" class="headerlink" title="1. wait()/nofify()"></a>1. wait()/nofify()</h4><p>简单实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingWait</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Object[] items = <span class="keyword">new</span> Object[MAX_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// count total number of items</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(items) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 唤醒之后，可能还会被其他put线程抢占，从而导致full，因此需要用while判断</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">while</span>(count == items.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue is full, please wait for consumer to take"</span>);</span><br><span class="line">                items.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            items.notifyAll(); <span class="comment">// 对比PCQueueUsingLock,这里的实现没有区分full和empty的条件，因此需要notifyAll，否则会导致put之后唤醒的依旧是producer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(items) &#123;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 唤醒之后，可能还会被其他take线程抢占，从而导致empty，因此需要用while判断</span><br><span class="line">             */</span></span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue is empty, please wait for producer to put"</span>);</span><br><span class="line">                items.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            items.notifyAll(); <span class="comment">// 同理</span></span><br><span class="line">            <span class="keyword">return</span> (T)x;</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * 这里亮神提出一个问题：是否需要再finally中使用notifyAll？ —— NO</span><br><span class="line">             * 1. synchronized会自动释放锁（包括异常情况下），除非遇到blocked。yet，blocked这种情况，finally也没有办法啊~~</span><br><span class="line">             * 2. notifyAll之后只会让线程进入到获取锁的等待队列中，还需要等到syn块结束之后，其他线程才能竞争到锁，因此不会出现return之前其他线程就执行的情况</span><br><span class="line">             * 3. 对比：Lock需要手动去释放，因此为了保证异常情况下也能够正常释放，需要通过finally块来unLock</span><br><span class="line">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：(TODO==)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-_ReentrantLock_-_Condition"><a href="#2-_ReentrantLock_-_Condition" class="headerlink" title="2. ReentrantLock - Condition"></a>2. ReentrantLock - Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingLock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max capacity for queue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[MAX_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putptr, takeptr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// count total number of items</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"queue full, wait for consumer"</span>);</span><br><span class="line">                notFull.await(); <span class="comment">// condition not met, make the thread to await</span></span><br><span class="line">            &#125;</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) &#123;</span><br><span class="line">                putptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 唤醒所有的线程没有意义，因为最终只有一个能够执行</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// test </span></span><br><span class="line">            System.out.print(<span class="string">"after put: "</span>);</span><br><span class="line">            <span class="keyword">for</span>(Object obj : items) &#123;</span><br><span class="line">                System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// must in finally !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// test</span></span><br><span class="line">                System.out.println(<span class="string">"queue empty, wait for producer"</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            items[takeptr] = <span class="keyword">null</span>; <span class="comment">// set reference to null</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) &#123;</span><br><span class="line">                takeptr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// test </span></span><br><span class="line">            System.out.print(<span class="string">"after take: "</span>);</span><br><span class="line">            <span class="keyword">for</span>(Object obj : items) &#123;</span><br><span class="line">                System.out.print(obj + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> (T)x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// must use finally !!!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> round = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        PCQueueUsingLock&lt;Integer&gt; pcQueue = <span class="keyword">new</span> PCQueueUsingLock&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        Thread p = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();  <span class="comment">// wait </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;round; i++) &#123;</span><br><span class="line">                        pcQueue.put(rand.nextInt(<span class="number">10</span>));</span><br><span class="line">                        <span class="comment">//Thread.sleep((long) (3000*Math.random()));</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt(); <span class="comment">// best practice: reset interrupt flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    startGate.await();  <span class="comment">// wait </span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;round; i++) &#123;</span><br><span class="line">                        pcQueue.take();</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (<span class="number">3000</span>*Math.random()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt(); <span class="comment">// best practice: reset interrupt flag</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        p.start();</span><br><span class="line">        c.start();</span><br><span class="line">        </span><br><span class="line">        startGate.countDown();  <span class="comment">// start together</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">queue empty, wait <span class="keyword">for</span> producer</span><br><span class="line">after put: <span class="number">4</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="keyword">null</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="keyword">null</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="keyword">null</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">7</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="keyword">null</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="keyword">null</span> <span class="number">8</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> </span><br><span class="line">queue full, wait <span class="keyword">for</span> consumer</span><br><span class="line">after take: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="keyword">null</span> </span><br><span class="line">after put: <span class="number">4</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="number">1</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">8</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="number">5</span> </span><br><span class="line">after take: <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h4 id="3-_BlockingQueue"><a href="#3-_BlockingQueue" class="headerlink" title="3. BlockingQueue"></a>3. BlockingQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单封装即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingBlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; items = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(MAX_CAPACITY);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        items.put(x); <span class="comment">// offer() will not block, while put() will block if queue is full.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        T x = items.take(); <span class="comment">// poll() will not block, will take() will block if queue is empty.</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedBlockingQueue的put内部实现(采用了ReentrantLock的方式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   <span class="comment">// 空元素判断</span></span><br><span class="line">       <span class="comment">// <span class="doctag">Note:</span> convention in all put/take/etc is to preset local var</span></span><br><span class="line">       <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">       <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">       Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">       <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count; <span class="comment">// 使用atomic的方式计数，保证并发put+take下的count统计正确</span></span><br><span class="line">       putLock.lockInterruptibly(); <span class="comment">// 可以被中断的lock</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">/*</span><br><span class="line">            * Note that count is used in wait guard even though it is</span><br><span class="line">            * not protected by lock. This works because count can</span><br><span class="line">            * only decrease at this point (all other puts are shut</span><br><span class="line">            * out by lock), and we (or some other waiting put) are</span><br><span class="line">            * signalled if it ever changes from capacity. Similarly</span><br><span class="line">            * for all other uses of count in other wait guards.</span><br><span class="line">            */</span></span><br><span class="line">           <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">               notFull.await();</span><br><span class="line">           &#125;</span><br><span class="line">           enqueue(node);</span><br><span class="line">           c = count.getAndIncrement();</span><br><span class="line">           <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">               notFull.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>LinkedBlockingQueue的offer内部实现（非阻塞，立刻返回）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">       <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 立刻返回false</span></span><br><span class="line">       <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">       Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">       putLock.lock(); <span class="comment">// 不可中断，why？</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">               enqueue(node);</span><br><span class="line">               c = count.getAndIncrement();</span><br><span class="line">               <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                   notFull.signal();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">       <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-_Semaphore"><a href="#4-_Semaphore" class="headerlink" title="4. Semaphore"></a>4. Semaphore</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCQueueUsingSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; items = <span class="keyword">new</span> ArrayList&lt;Object&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * 1. mutex保证存取缓冲区时必须是线程互斥的</span><br><span class="line">     * 2. isFull保证缓冲区最多元素为initPermits，初始值代表缓冲区开始可以存放多少元素</span><br><span class="line">     * 3. isEmpty保证缓冲区为0是阻塞，初始值代表缓冲区开始有多少元素</span><br><span class="line">     * 4. = 也就是isFull和isEmpty的初始化值加起来等于缓冲区的大小</span><br><span class="line">     * </span><br><span class="line">     * 5. 注意不同的semaphore的顺序，否则会出现并发问题</span><br><span class="line">     *      - isFull的信号量可以并发获得</span><br><span class="line">     *      - 但take和put实际操作时，必须只能有一个线程，因此mutex的permit=1</span><br><span class="line">     * </span><br><span class="line">     * 6. 使用semaphore的好处：</span><br><span class="line">     *      - 避免采用wait\notify等底层机制，封装更完善</span><br><span class="line">     *      - 可以避免手动判断缓冲区的当前大小是否满或空，（Condition需要）</span><br><span class="line">     *      - 借助了AQS，似乎效率上得到了优化？？？？</span><br><span class="line">     */</span></span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">// mutex put or take</span></span><br><span class="line">    Semaphore isFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>); <span class="comment">// 缓冲区最多允许10个</span></span><br><span class="line">    Semaphore isEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>); <span class="comment">// 缓冲区初始值为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        isFull.acquire(); <span class="comment">// 大于0,意味着还有permit可以使用，缓冲区未满</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire(); <span class="comment">// acquire = ++</span></span><br><span class="line">            items.add(x);  <span class="comment">// release = --</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            isEmpty.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">        Object x = <span class="keyword">null</span>;</span><br><span class="line">        isEmpty.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            <span class="comment">/* 注意List的remove定义：</span><br><span class="line">             * Removes the element at the specified position in this list (optional operation). </span><br><span class="line">             * Shifts any subsequent elements to the left (subtracts one from their indices). </span><br><span class="line">             * Returns the element that was removed from the list.</span><br><span class="line">             */</span></span><br><span class="line">            x = items.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            isFull.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-_LockSupport"><a href="#5-_LockSupport" class="headerlink" title="5. LockSupport"></a>5. LockSupport</h4><p>LockSupport可以通过park(thread)和unpark(thread)，精确地指定阻塞和唤醒线程。但是貌似就欠缺了wait/notify能够让线程在一个object上等待的接口，因此我考虑要实现PC，需要自己维护一个thread的队列才可以。</p>
<h4 id="6-_PipedInputStream_/_PipedOutputStream"><a href="#6-_PipedInputStream_/_PipedOutputStream" class="headerlink" title="6. PipedInputStream / PipedOutputStream"></a>6. PipedInputStream / PipedOutputStream</h4><h3 id="u5E94_u7528_u573A_u666F"><a href="#u5E94_u7528_u573A_u666F" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要处理任务时间比较长的场景：<ul>
<li>附件上传</li>
<li>远程接口查询数据  </li>
<li>Java线程池</li>
</ul>
</li>
</ul>
<h3 id="u7EBF_u7A0B_u6C60_u4E2D_u5982_u4F55_u5B9E_u73B0PC_u6A21_u5F0F"><a href="#u7EBF_u7A0B_u6C60_u4E2D_u5982_u4F55_u5B9E_u73B0PC_u6A21_u5F0F" class="headerlink" title="线程池中如何实现PC模式"></a>线程池中如何实现PC模式</h3><h3 id="u66F4_u9AD8_u6548_u7684_u8003_u8651"><a href="#u66F4_u9AD8_u6548_u7684_u8003_u8651" class="headerlink" title="更高效的考虑"></a>更高效的考虑</h3><ol>
<li>putLock与takeLock分离（jdk LinkedBlockingQueue中的实现方式）</li>
<li>如果能够直接处理，则直接被consumer取走，不需要再存储到queue中，减少复制的开销</li>
</ol>
<h3 id="u961F_u5217_u7684_u5FAA_u73AF_u6570_u7EC4_u65B9_u5F0F_u5B9E_u73B0"><a href="#u961F_u5217_u7684_u5FAA_u73AF_u6570_u7EC4_u65B9_u5F0F_u5B9E_u73B0" class="headerlink" title="队列的循环数组方式实现"></a>队列的循环数组方式实现</h3><h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://www.infoq.com/cn/articles/producers-and-consumers-mode" target="_blank" rel="external">聊聊并发-生产者消费者模式</a></p>
<p>[2] <a href="http://java--hhf.iteye.com/blog/2064926" target="_blank" rel="external">生产者消费者问题的实现方式</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29"><a href="#u751F_u4EA7_u8005_u6D88_u8D39_u8005_u6A21_u5F0F_uFF08_u4EE5_u4E0B_u7B80_u79F0PC_29" class="headerlink" title="生产者消费者模式（以下简称PC)"></a>生产者消费者模式（以下简称PC)</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，<code>阻塞队列就相当于一个缓冲区</code>，平衡了生产者和消费者的处理能力。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="生产者消费者" scheme="http://paranoidq.github.io/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    
      <category term="设计模式" scheme="http://paranoidq.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是中间件？]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/"/>
    <id>http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料研究研究。</p>
<h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><p>维基百科定义：</p>
<blockquote>
<p>提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。如数据库、Apache的Tomcat，IBM公司的WebSphere,BEA公司的WebLogic[[应用服务器]，东方通公司的Tong系列中间件，以及Kingdee公司的等都属于中间件。</p>
</blockquote>
<p>简单归纳：<br>业务应用 - 中间件 - 基础资源</p>
<ul>
<li>中间件处于两者中间的的位置，封装基础资源，向上层提供更完善的功能。</li>
<li>基础资源包括硬的资源：如CPU、存储(分布式)、网络；我个人认为也包括进程、线程、消息队列、数据库这种软性资源，中间件对这些资源做了封装处理。</li>
</ul>
<h3 id="u4F5C_u7528"><a href="#u4F5C_u7528" class="headerlink" title="作用"></a>作用</h3><ul>
<li>封装</li>
<li>整合</li>
<li>屏蔽</li>
<li>容错</li>
</ul>
<p>我个人归纳为这四个主要功能。封装和整合的是基础资源，使得难用的基础资源更便于使用，而不用考虑细节。（调用顺序、分布式、配置、初始化属性等等）。屏蔽的是底层细节，同时也屏蔽底层的差异（例如，JVM这种本质意义上其实也可算作中间件，通过JVM屏蔽不同系统的差异，从而能够无差异运行Java程序）。容错，则是中间件的另一个重要作用，保证上层无论如何调用，都会得到相应的处理，而不会将错误传递到底层去或直接消失。</p>
<h3 id="u5E38_u89C1_u79CD_u7C7B_uFF1A"><a href="#u5E38_u89C1_u79CD_u7C7B_uFF1A" class="headerlink" title="常见种类："></a>常见种类：</h3><ul>
<li>分布式调用RPC：</li>
<li>消息队列</li>
<li>事务处理</li>
<li>数据库组件</li>
<li>安全组件</li>
<li>并发组件</li>
<li>应用容器组件</li>
<li>日志组件：Apache Kafaka</li>
<li>监控组件：Zookkeeper, Mesos, </li>
</ul>
<h3 id="u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29"><a href="#u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29" class="headerlink" title="阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)"></a>阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)</h3><p><img src="http://jm.taobao.org/wp-content/uploads/2013/07/jm.jpg" alt="阿里巴巴中间件支撑平台"></p>
<ul>
<li><strong>Diamond</strong>: 软负载配置中心，用于存储静态配置，并能够提供配置变更动态推送功能，结构简单，超高可用性。在全网被使用于存储不经常发生变化的配置信息。</li>
<li><strong>Notify</strong>, <strong>Meta</strong>: 消息中间件</li>
<li><strong>HSF</strong>: 阿里分布式服务框架，统一整个集团rpc的调用，包括服务方式的统一调用，软负载，服务治理等，提供一套简单方便，高性能的分布式服务框架。</li>
<li><strong>eagleeye</strong>: 淘宝分布式跟踪系统，该系统实现基于单链路的实时监控，系统依赖，性能调优，风险控制等</li>
<li><strong>Pandora</strong>: 淘宝隔离容器，该系统主要解决大规模富二方包升级，二方包隔离，二方包监控等问题。</li>
<li><strong>TDDL</strong>: 通用数据访问层，部署在客户端的jar包，用于将用户的SQL路由到指定的数据库中。目前有1000+应用在使用</li>
<li><strong>精卫</strong>: 通用数据总线，用于将数据从一个数据节点迁移到其他一个或多个数据节点中，目前支持mysql,oracle,hbase等。目前有100+应用在使用</li>
<li><strong>愚公</strong>: 数据自动迁移引擎，海量数据自动运维工具，可用于对用户无影响的自动扩容和缩容，数据平滑迁移，以及异构数据源迁移，目前已经完成了214次业务迁移或扩容。</li>
<li><strong>NewSQL</strong>: NewSQL系统，可以将SQL运行于传统MYSQL/Oracle关系数据库，也可以支持NoSQL数据库如bdb , hbase等。 可以实现其中的跨机合并和跨机交操作等复杂关系操作。</li>
<li><strong>CSP2.0</strong>: 持续稳定性平台帮助阿里系统保障高可用性，包含线上压测、容量规划、依赖治理、限流降级、监控报警、问题定位等模块。</li>
<li><strong>Hotspot</strong>: 性能分析平台通过对基础软件、服务端、前端加载、网络、CDN等方面的性能分析，来帮助阿里系统提升吞吐量、降低延迟时间、节约成本。</li>
<li><strong>TProfiler</strong>: TProfiler是可以在生产环境长期使用的性能分析工具，通过在Java层面记录代码执行热点、对象创建热点等数据，帮助系统定位性能瓶颈。</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6</a><br><a href="http://jm-blog.aliapp.com/?page_id=2449" target="_blank" rel="external">阿里巴巴中间件团队博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 分支管理与实践（hexo博客源文件管理）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Git-branch-management/"/>
    <id>http://paranoidq.github.io/2016/05/27/Git-branch-management/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br><code>git branch -a</code></p>
<p>查看本地分支和远程分支的push情况<br><code>git log &lt;local-branch&gt; ^origin/&lt;remote-branch&gt;</code>   # 可以查看本地有远程没有的提交。<br><code>git log &lt;remote-branch&gt; ^&lt;local-branch&gt;</code>       # 可以查看远程有本地没有的提交。</p>
<h3 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h3><p>创建本地分支<br><code>git checkout -b dev</code></p>
<h3 id="u5173_u8054"><a href="#u5173_u8054" class="headerlink" title="关联"></a>关联</h3><p>目的：避免每次都需要制定push的具体分支，可以关联后在本地分支下直接push即可</p>
<p>两种方案：</p>
<ol>
<li>在本地branch第一次push的时候就指定：<br> <code>git push -u origin &lt;remote-branch&gt;</code></li>
<li>以后指定：<br><code>git branch --set-upstream &lt;local-branch&gt; origin/&lt;remote-branch&gt;</code><br>或<br><code>git push --set-upstream origin &lt;remote-branch&gt;</code><br>你的repo下的git/config会多出类似这样的配置：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[branch "src"]</span></span><br><span class="line"><span class="attr">remote</span> = origin</span><br><span class="line"><span class="attr">merge</span> = refs/heads/src</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u63A8_u9001"><a href="#u63A8_u9001" class="headerlink" title="推送"></a>推送</h3><p><code>git push origin &lt;local-branch&gt;</code>  # 推送本地分支到对应的远程分支</p>
<p><code>git push</code> # 如果指定了远程关联，可以直接push</p>
<p>两种配置： (注意，这个配置是写在~/.gitconfig中的，对所有的repo生效)<br><code>git config --global push.default simple</code>(更好, 只push当前分支到你使用git pull拉取的远程代码)<br><code>git config --global push.default matching</code> （如果没有指定具体分支，会push所有名字对应的分支）</p>
<h3 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h3><p>删除本地分支<br><code>git branch -d dev (用-D强行删除)</code></p>
<p>删除远程分支<br><code>git push origin --delete dev</code></p>
<h3 id="u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F"><a href="#u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F" class="headerlink" title="实例： 管理hexo的src分支"></a>实例： 管理hexo的src分支</h3><p>说明：hexo的deployer本身在部署的时候只会生成static文件，并上传到github的master分支，而hexo的一些source和_config.yaml等配置文件则只在本地。因此需要将这些文件也管理到git中去，方便备份和多终端同步。</p>
<p>基本思路是在本地利用src分支，然后上传源文件到src分支，并push到远程的src分支，即可管理。</p>
<p>master分支由于是hexo的页面展示部分，所以其实是不能与origin/master保持同步的，也千万不能push，否则结果就是源文件覆盖了hexo-deployer push到master分支的静态文件，从而访问的时候404了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd &lt;repo&gt;</span><br><span class="line"><span class="variable">$ </span>git init (optional)</span><br><span class="line"><span class="variable">$ </span>git checkout -b src</span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"first commit for src branch"</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>&lt;username&gt;<span class="symbol">:&lt;username&gt;</span>.github.io.git (optional)</span><br><span class="line"><span class="variable">$ </span>git push origin src</span><br></pre></td></tr></table></figure>
<ol>
<li>optional部分，可能由于之前开始建立repo的时候已经做过了，所以不一定要在分支的过程中做了</li>
<li>checkout的时候，需要保证master分支全部commit。（这里其实我做的不够完善，一开始应该是整个本地的网站不要init，让master分支全部被hexo-deployer接管。然后在创建分支的时候，才init。这样可以保证本地只有一个src的分支需要我手动管理。</li>
<li>如果你手贱之前已经建立了master分支，那么有两个办法：<ul>
<li>忽略与origin/master不同步的本地master分支</li>
<li>删除本地的master分支 <code>git branch -D master</code></li>
</ul>
</li>
</ol>
<p><strong>另外一台电脑上如何使用：</strong><br>安装node环境和hexo-cli环境<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew update </span><br><span class="line">$ brew install <span class="keyword">node</span></span><br><span class="line"><span class="title">$</span> npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<p>不要执行hexo init了，而是clone远程的src仓库<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -<span class="selector-tag">b</span> src git@github<span class="selector-class">.com</span>:&lt;username&gt;:&lt;username&gt;<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span></span><br><span class="line">$ npm install <span class="comment">//根据package.json来下载依赖包</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以继续写博客了，整个过程，手动管理的只有src，master分支本地需要，由hexo-deployer负责push。</p>
<p>参考文献[1]中还提到了用git submodule解决第三方主题的同步问题，很不错。<br>参考文献[3]中修改hexo-deployer源码，添加了自动在deploy的时候提交src的功能，很nice。</p>
<p>具体方法：<br>修改<code>node_modules\hexo-deployer-git\lib\deployer.js</code>插件的代码，添加gitBaseDir函数。 注意gitBaseDir函数必须写在module块中，否则会出现错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: deployDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gitBaseDir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: baseDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在push函数中添加提交到src的功能<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(repo)</span>&#123;</span></span><br><span class="line">   <span class="keyword">return</span> git(<span class="string">'add'</span>, <span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'commit'</span>, <span class="string">'-m'</span>, message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">       <span class="comment">// Do nothing. It's OK if nothing to commit.</span></span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'push'</span>, <span class="string">'-u'</span>, repo.url, <span class="string">'master:'</span> + repo.branch, <span class="string">'--force'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> gitBaseDir(<span class="string">'checkout'</span>,<span class="string">'source'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'add'</span>,<span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> gitBaseDir(<span class="string">'commit'</span>,<span class="string">'-m'</span>,message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'push'</span>,<span class="string">'-u'</span>,repo.url,<span class="string">'source:source'</span>,<span class="string">'--force'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="http://devtian.me/2015/03/17/blog-sync-solution/" target="_blank" rel="external">如何管理hexo的源文件</a></li>
<li><a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-Master-%E5%88%86%E6%94%AF?locale=zh-CN" target="_blank" rel="external">为何以及如何删除master分支</a></li>
<li><a href="http://boenyang.github.io/2015/09/09/hello-world/" target="_blank" rel="external">自动化hexo的源文件提交-修改hexo-deployer源码部分</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br]]>
    </summary>
    
      <category term="git" scheme="http://paranoidq.github.io/tags/git/"/>
    
      <category term="git" scheme="http://paranoidq.github.io/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx与tomcat有什么区别]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/"/>
    <id>http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>
<a id="more"></a>
<p>Http Server的核心是Http协议层面的传输和访问控制，包括代理、负载均衡等。客户端通过Http协议访问Http Server上的文件资源(HTML文件、图片等)，然后Http Server如实将文件通过Http协议传输给客户端。当然，通过<code>CGI</code>技术也可以对Http Server传输的内容进行一些处理。<br>大多数时候，Nginx主要作为Tomcat前端的负载均衡器和代理，负责请求的转发和静态内容的直接返回。因为其高效的IO机制[2]，能够显著提高系统的吞吐率。</p>
<p>Web App Server，应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，<br>应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>Tomcat和Jetty，WebLogic同属一类。</p>
<p><hr></p>
<blockquote>
<p>“tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”</p>
</blockquote>
<p>—— 不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用，也就是说servlet容器必须由java或者基于jvm的语言实现。<br><strong>本质上，Servlet是J2EE规范的一部分，规定了容器和Web App必须遵循的接口规范。容器必须按照接口解析Java类，然后处理请求；同样Web App也只有按照规范来编写实现类，才能被容器所加载解析，从而完成特定的功能。</strong></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.zhihu.com/question/32212996" target="_blank" rel="external">https://www.zhihu.com/question/32212996</a></li>
<li><a href="http://90112526.blog.51cto.com/6013499/1059700" target="_blank" rel="external">http://90112526.blog.51cto.com/6013499/1059700</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="nginx" scheme="http://paranoidq.github.io/tags/nginx/"/>
    
      <category term="tomcat" scheme="http://paranoidq.github.io/tags/tomcat/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
