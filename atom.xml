<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[钱唯の个人博客]]></title>
  <subtitle><![CDATA[佳思忽来，书能下酒；侠情一往，云可赠人。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://paranoidq.github.io/"/>
  <updated>2016-10-11T13:26:29.000Z</updated>
  <id>http://paranoidq.github.io/</id>
  
  <author>
    <name><![CDATA[Paranoid Qian]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[(翻译) Using HttpClient properly to avoid CLOSE_WAIT TCP connections]]></title>
    <link href="http://paranoidq.github.io/2016/10/11/Using-HttpClient-properly-to-avoid-CLOSE-WAIT-TCP-connections/"/>
    <id>http://paranoidq.github.io/2016/10/11/Using-HttpClient-properly-to-avoid-CLOSE-WAIT-TCP-connections/</id>
    <published>2016-10-11T12:46:41.000Z</published>
    <updated>2016-10-11T13:26:29.000Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/" target="_blank" rel="external">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></p>
<p>在我帮助我的客户debug一个TCP connection关于CLOSE_WAIT状态的问题时，我发现我们错误的使用了HttpClient。在这个问题上，如果你试图google <a href="http://www.google.com/search?q=HttpClient+CLOSE_WAIT" target="_blank" rel="external">HttpClient CLOSE_WAIT</a>，你会发现很多人跟我们一样存在疑惑。但是关于这个问题，很多的解答不够直观，甚至<a href="http://hc.apache.org/httpclient-legacy/tutorial.html" target="_blank" rel="external">官方文档</a>都是错误的。所以我在这篇文章中进行了分析。</p>
<p>Apache HttpClient的基本用法如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpMethod <span class="function"><span class="keyword">method</span> = <span class="title">new</span> <span class="title">GetMethod</span><span class="params">(uri)</span>;</span></span><br><span class="line"><span class="keyword">try</span> <span class="comment">&#123;</span><br><span class="line">    int statusCode = httpClient.executeMethod(method);</span><br><span class="line">    byte[] responseBody = method.getResponseBody();</span><br><span class="line">    // ...</span><br><span class="line">    return stuff;</span><br><span class="line">&#125;</span> <span class="keyword">finally</span> <span class="comment">&#123;</span><br><span class="line">    method.releaseConnection();</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>但事实上，这是不够的。问题在于释放connection使得connection对于HttpClient而言重新可用，而非真正的关闭该connection，原因在于使用了Http1.1协议，HttpClient可以在同一个connection中批量发送后续的请求(?)。</p>
<p>尽管，server端可能单向关闭了连接，但是客户端的connection还是打开的，并且一直持续到下一次尝试从connection中读报文时（此时，客户端才会意识到服务端已经关闭了这个连接）。TCP就是采用这种方式工作的。上面的情况我们称之为<code>半关闭的连接</code>，<strong>因为close()操作仅仅意味着我不会再往发送任何数据了，但是我还是可以从已经“closed”的连接中读取数据，只要另一端没有调用这个close()操作。</strong>[译注: 理解这一点非常重要]</p>
<p>因此，当HttpClient实例超过作用域的时候，它会被GC标记为可回收状态，但是GC并不会立即回收它。在GC真正回收它之前，HttpClient内部的connection仍然处于打开的状态，此时的TCP状态就处于CLOSE-WAIT。</p>
<p>为了解决这个问题，最简单的方法是在调用method之前设置如下代码：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">method</span>.<span class="title">setRequestHeader</span><span class="params">("Connection", "close")</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>这会导致HttpClient在接受完应答报文之后立即关闭connection。</p>
<p>另外一个方法是在finally块中添加如下代码：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient<span class="selector-class">.getHttpConnectionManager</span>()<span class="selector-class">.closeIdleConnections</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>效果应该跟上面的一样，都是让connection在idle之后立即销毁connection。</p>
<p>更好的方法是：不要每次都new HttpClient，而重用经过<code>MultiThreadedHttpConnectionManager</code>配置的一个client实例。当然，这种情况下，就需要最终记得清理MultiThreadedHttpConnectionManager。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MultiThreadedHttpConnectionManager connectionManager;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">HttpClient</span> httpClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> init() &#123;</span><br><span class="line">    connectionManager = <span class="keyword">new</span> MultiThreadedHttpConnectionManager()</span><br><span class="line">    <span class="comment">// ... configure connectionManager ...</span></span><br><span class="line">    httpClient = <span class="keyword">new</span> <span class="built_in">HttpClient</span>(connectionManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">shutdown</span>() &#123;</span><br><span class="line">    connectionManager.<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> <span class="built_in">process</span>(<span class="keyword">String</span> uri) &#123;</span><br><span class="line">    HttpMethod method = <span class="keyword">new</span> GetMethod(uri);</span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> statusCode = httpClient.executeMethod(method);</span><br><span class="line">        <span class="keyword">byte</span>[] responseBody = method.getResponseBody();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="built_in">return</span> stuff;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        method.releaseConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></p>
<p>在我帮助我的客户debug一个TCP connection关于CLOSE_WAIT状态的问题时，我发现我们错误的使用了HttpClient。在这个问题上，如果你试图google <a href="http://www.google.com/search?q=HttpClient+CLOSE_WAIT">HttpClient CLOSE_WAIT</a>，你会发现很多人跟我们一样存在疑惑。但是关于这个问题，很多的解答不够直观，甚至<a href="http://hc.apache.org/httpclient-legacy/tutorial.html">官方文档</a>都是错误的。所以我在这篇文章中进行了分析。</p>
<p>Apache HttpClient的基本用法如下：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">HttpMethod <span class="function"><span class="keyword">method</span> = <span class="title">new</span> <span class="title">GetMethod</span><span class="params">(uri)</span>;</span></span><br><span class="line"><span class="keyword">try</span> <span class="comment">&#123;</span><br><span class="line">    int statusCode = httpClient.executeMethod(method);</span><br><span class="line">    byte[] responseBody = method.getResponseBody();</span><br><span class="line">    // ...</span><br><span class="line">    return stuff;</span><br><span class="line">&#125;</span> <span class="keyword">finally</span> <span class="comment">&#123;</span><br><span class="line">    method.releaseConnection();</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="httpclient" scheme="http://paranoidq.github.io/tags/httpclient/"/>
    
      <category term="tcp" scheme="http://paranoidq.github.io/tags/tcp/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NoHttpResponseException问题分析]]></title>
    <link href="http://paranoidq.github.io/2016/10/11/NoHttpResponseException-problem-analysis/"/>
    <id>http://paranoidq.github.io/2016/10/11/NoHttpResponseException-problem-analysis/</id>
    <published>2016-10-11T11:45:30.000Z</published>
    <updated>2016-10-11T12:45:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h3><p>在性能测试的时候，使用apache httpclient连续发送报文到server进行压测。压测的配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总数：10000</span><br><span class="line">并发：400</span><br><span class="line">每个发送线程的QPS限制：20</span><br></pre></td></tr></table></figure></p>
<p>出现的问题是： 大概1000左右的报文会出现 <code>NoHttpResponseException [server ip] failed to respond</code>。调低并发度到300一下时，不会出现这样的异常。<br><a id="more"></a></p>
<h3 id="u539F_u56E0_u5206_u6790"><a href="#u539F_u56E0_u5206_u6790" class="headerlink" title="原因分析"></a>原因分析</h3><p>查阅相关资料，官方对于<code>NoHttpResponseException</code>解释是：</p>
<blockquote>
<p>In some circumstances, usually when under heavy load, the web server may be able to receive requests but unable to process them. A lack of sufficient resources like worker threads is a good example. This may cause the server to drop the connection to the client without giving any response. HttpClient throws NoHttpResponseException when it encounters such a condition. In most cases it is safe to retry a method that failed with NoHttpResponseException.</p>
</blockquote>
<p>大致意思跟我之前构想的一样，在并发量比较大的情况下，server的处理线程有限，于是drop掉了来自客户端的Connection，并且没有给任何应答。但是细想，为什么服务端会drop掉连接呢？首先贴一则查阅到的stackoverflow上的分析：</p>
<blockquote>
<p>Most likely persistent connections that are kept alive by the connection manager become stale. That is, the target server shuts down the connection on its end without HttpClient being able to react to that event, while the connection is being idle, thus rendering the connection half-closed or ‘stale’. Usually this is not a problem. HttpClient employs several techniques to verify connection validity upon its lease from the pool. Even if the stale connection check is disabled and a stale connection is used to transmit a request message the request execution usually fails in the write operation with SocketException and gets automatically retried. However under some circumstances the write operation can terminate without an exception and the subsequent read operation returns -1 (end of stream). In this case HttpClient has no other choice but to assume the request succeeded but the server failed to respond most likely due to an unexpected error on the server side.</p>
</blockquote>
<p>大致含义：httpclient的连接一般由一个poolConnectionManager管理，而往往会有keep-alive的设置，即保持这个连接多久。但是当server端主动关闭连接的时候，由于<strong>Connection可能处于idle状态，因此pool没有通知到HttpClient对应的connection，从而造成了connection处于半关闭的状态</strong>。<br>因此在这种状态下，之后connection从pool中被唤醒或取出，然后发送报文在某些情况下write会在没有报异常的情况下结束，然后httpclient尝试从connection中read应答时返回了-1（注意，不是没有返回，否则应该是WaitTimeoutException）。httpclient认为server返回了应答，但实际上没有，因此抛出了NoHttpResponseException异常。</p>
<p>进一步思考：为什么server会主动关闭Connection呢？如果是处理能力有限，那么应该更加利用connection才对，而不应该主动drop。我的思考如下：</p>
<blockquote>
<p>1.假设server的连接限制是10，那么显然，如果现在只有5个请求来了，那么会创建5个connection。<br>2.如果现在来了20个请求，那么显然server是处理不过来的</p>
</blockquote>
<h3 id="u89E3_u51B3_u65B9_u6848"><a href="#u89E3_u51B3_u65B9_u6848" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="1-_retry"><a href="#1-_retry" class="headerlink" title="1. retry"></a>1. retry</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClientBuilder.setRetryHandler(<span class="keyword">new</span> StandardHttpRequestRetryHandler(<span class="number">3</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<h4 id="2-__u9650_u5236keepAlive_u7684_u65F6_u95F4"><a href="#2-__u9650_u5236keepAlive_u7684_u65F6_u95F4" class="headerlink" title="2. 限制keepAlive的时间"></a>2. 限制keepAlive的时间</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ConnectionKeepAliveStrategy connectionKeepAliveStrategy = new ConnectionKeepAliveStrategy() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public long getKeepAliveDuration(HttpResponse httpResponse, HttpContext httpContext) &#123;</span><br><span class="line">            return <span class="number">20</span> * <span class="number">1000</span><span class="comment">; // tomcat默认keepAliveTimeout为20s</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line">PoolingHttpClientConnectionManager connManager = new PoolingHttpClientConnectionManager(<span class="number">20</span>, TimeUnit.SECONDS)<span class="comment">;</span></span><br><span class="line">connManager.setMaxTotal(<span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">connManager.setDefaultMaxPerRoute(<span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">    .setConnectTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .setSocketTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .setConnectionRequestTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">    .<span class="keyword">build();</span><br><span class="line"></span>HttpClientBuilder httpClientBuilder = HttpClientBuilder.create()<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setConnectionManager(connManager)<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setDefaultRequestConfig(requestConfig)<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setRetryHandler(new DefaultHttpRequestRetryHandler())<span class="comment">;</span></span><br><span class="line">httpClientBuilder.setKeepAliveStrategy(connectionKeepAliveStrategy)<span class="comment">;</span></span><br><span class="line">HttpClient httpClient = httpClientBuilder.<span class="keyword">build();</span><br><span class="line"></span>ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient)<span class="comment">;</span></span><br><span class="line">restTemplate = new RestTemplate(requestFactory)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>主要是增加keepalive的策略，但这又带来一个问题，所有的连接只有20秒，无法使用长连接的性能优势</p>
<h4 id="3-_closeIdleConnections"><a href="#3-_closeIdleConnections" class="headerlink" title="3. closeIdleConnections"></a>3. closeIdleConnections</h4><p>PoolingHttpClientConnectionManager.closeIdleConnections 方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">closeIdleConnections</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> idleTimeout, <span class="keyword">final</span> TimeUnit tunit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.log.debug(<span class="string">"Closing connections idle longer than "</span> + idleTimeout + <span class="string">" "</span> + tunit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.pool.closeIdle(idleTimeout, tunit);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>三种方案暂且列出，准备实践一下效果，后续再更新到博客中来。相比而言，retry的方案比较sb，但是估计很好用；keepAlive限制需要考虑场景，某些需要长连接的场景下可能不是很合适，并且把统一把连接过期关掉，显然会带来不小的性能损失。最后一种方案，应该是keepAlive的折中优化，本质上是如果connection一直被pool拿出来使用，那我就不关闭你；如果connection一直idle，那么过了一段时间我就主动关闭你了。这样就避免了keepAlive统一限制的问题，同时如果一个connection被pool拿出来用了，那么显然他不可能被server关闭；而idle connection被关闭了，所以不会出现上述server端drop connection而pool又无法通知idle connection的问题。</p>
<h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://my.oschina.net/sannychan/blog/485677" target="_blank" rel="external">https://my.oschina.net/sannychan/blog/485677</a></li>
<li><a href="http://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception" target="_blank" rel="external">http://stackoverflow.com/questions/10558791/apache-httpclient-interim-error-nohttpresponseexception</a></li>
<li><a href="http://stackoverflow.com/questions/10570672/get-nohttpresponseexception-for-load-testing/10680629#10680629" target="_blank" rel="external">http://stackoverflow.com/questions/10570672/get-nohttpresponseexception-for-load-testing/10680629#10680629</a></li>
<li><a href="https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/" target="_blank" rel="external">https://www.nuxeo.com/blog/using-httpclient-properly-avoid-closewait-tcp-connections/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u573A_u666F"><a href="#u573A_u666F" class="headerlink" title="场景"></a>场景</h3><p>在性能测试的时候，使用apache httpclient连续发送报文到server进行压测。压测的配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总数：10000</span><br><span class="line">并发：400</span><br><span class="line">每个发送线程的QPS限制：20</span><br></pre></td></tr></table></figure></p>
<p>出现的问题是： 大概1000左右的报文会出现 <code>NoHttpResponseException [server ip] failed to respond</code>。调低并发度到300一下时，不会出现这样的异常。<br>]]>
    
    </summary>
    
      <category term="httpclient" scheme="http://paranoidq.github.io/tags/httpclient/"/>
    
      <category term="tcp" scheme="http://paranoidq.github.io/tags/tcp/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[转载：大棋局与大智慧 —— 《时寒冰说》豆瓣书评]]></title>
    <link href="http://paranoidq.github.io/2016/08/26/%E6%97%B6%E5%AF%92%E5%86%B0%E8%AF%B4-%E8%B1%86%E7%93%A3%E8%AF%84%E8%AE%BA/"/>
    <id>http://paranoidq.github.io/2016/08/26/时寒冰说-豆瓣评论/</id>
    <published>2016-08-26T05:21:30.000Z</published>
    <updated>2016-08-26T05:28:38.000Z</updated>
    <content type="html"><![CDATA[<p>《时寒冰说：经济大棋局，我们怎么办》是一部窥透世界大棋局的智慧之作，也是一部还原真相，普及常识的启蒙之作，时寒冰在书中淋漓尽致的演绎了他的利益与趋势分析法。</p>
<p>赵汀阳说，思想的主体部分虽然是知识，但思想的奠基部分却是智慧，尽管我们无法保证那些代表智慧的观念是真理。① 全球化时代，智慧的稀缺使得信息爆炸与思想贫乏成为最具讽刺意义的矛盾，而中国的现状尤为突出。时下，主旋律的和谐之音，左派救亡图存的革命论调，右派改革体制的变法主张，由“左右之争”②衍生出的国家主义、民族主义、民粹主义意识形态以及专靠胡说八道混饭吃的砖家叫兽的大放厥词③,可谓“五色令人目盲，五音令人耳聋，五味令人口爽” ④。可见，比通货膨胀更可怕的是信息爆炸和思想贫乏导致的大脑膨胀，我们需要用智慧来稀释膨胀。<br><a id="more"></a></p>
<p>时寒冰说：经济大棋局，我们怎么办》透过政治、经济、金融、军事等纷繁复杂的乱象，紧扣全球范围内货币迅猛膨胀与资源日益减少所造成的“资源为王”和债务危机并存这一条主线，指出经济大棋局的本质就是主要经济体转嫁债务危机的博弈，这既是经济大棋局的结论，也是趋势分析的起点。在此基础上，作者给出了“我们怎么办”的答案。具体而言，对于国家，只有贯彻“资源为王”和“藏富于民”的战略才可化解危机，对于个人，只有“固化财富”才可避免财富的不断缩水。本书中，时寒冰将“良性的制度”纳入“资源为王”的战略之中，这样以来“资源为王”战略包括了保护现有资源，通过技术创新提高资源的附加值，通过优良的制度和环境确保资源最大限度发挥效用三个方面，依次涵盖了资源命脉、技术创新、制度保障三个层面，由此可见，时寒冰的思想体系已初具雏形。虽然该书尚算不上纯正的思想之作，但这种先融天地于一炉⑤，再抽丝剥茧，化繁为简，进而窥透大棋局的才华和境界，非大智慧者不能有。这种大智慧不仅体现在作者对各种知识和多家思想的驾驭上，更体现在作者用绝大多数人都能接受的常识完成了对大棋局的推理和演绎。</p>
<p>在经济大棋局中，货币战争、石油战争、粮食危机，中东危机、朝韩危机、人民币升值、汇率操纵、贸易战只是大棋局中居于不同节点的一个个棋子。美国不仅因为其经济军事势力，更因为深谙“资源为王”之道，因此在整个大棋局中，始终掌握着主动权。虽然，美国是世界上债务危机最严重的国家，但每当危机出现时，要么引爆欧元区某个主权国家的债务危机，要么制造中东危机，操纵国际油价，要么通过压迫人民币升值或汇率战，迫使中国政府送上采购订单，这些屡试不爽的招数，既转移了视线，也转移了危机，更重要的是为寻找新的经济增长点争取了时间，如金融危机后奥巴马政府的新能源战略，既是稀释美元泡沫的“海绵”，也是美国主导下一轮经济周期的货币之锚。相反，西班牙等“笨猪五国”自身经济的脆弱，日本巨额债务的内生性及社会的老龄化，中国的体制弊端和内需不足，都成为悬挂在各自债务危机头顶的达摩克利斯之剑，因此，未来的变数必然发生在这些国家。正因为大智慧窥透了大棋局的本质，因此，时寒冰在解读已经发生的事情时总是得心应手，在预测即将发生的事情时绝不模棱两可，这是智者和学者的区别，前者有卓越的智慧，后者只有渊博的知识。</p>
<p>在对经济大棋局分析论证的逻辑体系中，地缘政治学、意识形态、宗教信仰、国家主义、民族主义、体制改革、“阴谋论”则成为时寒冰演绎利益分析法的一个个“棋子”。近年来“阴谋论”甚嚣尘上，何新⑥、刘军洛⑦、郎咸平⑧等人从不同角度阐述华尔街和美国政府合谋控制全世界特别控制中国的阴谋，而布热津斯基早在10多年前就提出建立美国在世界范围内战略大棋局的构想⑨。但如果回归常识，战略和阴谋不过是一枚硬币的两面。大棋局中，掌握主动权者，棋局只是自己的战略，而被动承受者，棋局则是别人的阴谋。但无论阴谋还是战略，我们所能做的只有反省自身的不足并加以修正，唯有此才可能绝处逢生，这也是时寒冰贯穿全书的基本格调，正是这种超越利益，尊重常识的智者情怀，才有本书中对各种思想批判吸收后让其成为利益分析的一道道工具，也才有用常识还原真相的启蒙意义。比如，作者对“破窗理论”的批判，对美国在对外扩张中兼顾意识形态和国家利益的分析，对民主体制有利于促进财富创造的论断，都是超越意识形态和利益羁绊的常识启蒙。</p>
<p>智者总是独孤悲壮的，当抽丝剥茧后发现中国的经济问题并不在经济本身，而在经济之外，这对一个智者而言，是一种既尴尬又无奈的结果，或许只有在字里行间对民主制度不吝赞美，对领导人政治智慧满怀期望，对人应常怀爱心、公心大声呼唤。权力至上，蔑视常识与规则，缺乏信仰，投机盛行，这是中国国家性、国民性的基本“土壤”，我非常赞同乔良将军关于土壤的改造重于制度移植的观点⑩，但对制度的批判，对常识的启蒙本身就是对土壤的改造，所以，当时寒冰用他的智慧窥透经济大棋局，并告诉我们应该怎么办的时候，作为一名先知，他的使命就已经完成了，剩下的就是接受启蒙的每个人的行动。正如作者书中所言：“良性机制是大棋局中至关重要的保障。如果我们的制度也完善起来，中国将不惧怕任何挑战和博弈，而这，需要每个个体的努力。每个人都不应该简单的做一个等待者，而应该是一个推动者、行动者。”</p>
<h3 id="u6CE8_u91CA_uFF1A"><a href="#u6CE8_u91CA_uFF1A" class="headerlink" title="注释："></a>注释：</h3><p>①赵汀阳：《每个人的政治》，社会科学文献出版社。</p>
<p>②张宏良在《当前中国左派和右派的斗争》、《中华民族再次到了最危险的时候》等文章中，提出新“左派”、“右派”概念，并打出毛泽东思想的旗帜，反对资本主义和平演变的“颜色革命”。本文除有说明外，所引“左”“右”，仅是从革命与改良路径选择上的“左”“右”区分。</p>
<p>③“砖家叫兽”本是一个错别“词”，但用拼音输入后，第一个选项竟然就是“砖家叫兽”，不得不发出“时势造错字”的感叹。思考我们身边的现象，一条道路，今天建，明天拆，这竟然是砖家叫兽的“破冰理论”，岂不知这是在用消灭今天的财富来恢复本来就存在的财富。</p>
<p>④老子，《道德经·德经第十二章》。本文寓指今天中国思想界的混乱，这种混乱因本身的极端功利化，尚不等于思想的多元化。“五色”指种种丑恶离奇的乱像，“五音”指狭隘的民族主义、民粹主义、国家主义；被政治化的“左”“右”之争，以及被妖魔化的“阴谋论”等；“五味”指因为价值观与信仰迷失，人们行为的普遍功利化。</p>
<p>⑤《时寒冰说：经济大棋局，我们怎么办》一书中，政治、经济、金融、军事、历史、宗教等无所不包，地缘政治、阴谋论等或经典或流行的思想流派均有涉及。因此，本书被普遍认为是一本“小百科全书”。</p>
<p>⑥何新在《统治世界：神秘共济会揭秘》中分析指出，世界上存在一个集金融、政治和意识形态于一身，隐秘遥控着重大国际事件，并企图通过生物战争等方式消灭世界上“垃圾人口”的共济会。</p>
<p>⑦刘军洛在《被绑架的中国经济》、《高等文化的控制》等书中分析指出，美国对外经济扩展是由跨国公司、军火商、农场主、华尔街、美国政府组成的多维一体的立体作战模式，而最重要的手段就是培植利益代言人，让这些代言人给国民“洗脑”，从而达到通过文化控制实现战略利益的目标。</p>
<p>⑧郎咸平在《新帝国主义在中国》等书中分析指出，华尔街和国家机器默契配合，开始侵吞中国民族工业和优质企业。</p>
<p>⑨美国当代著名的战略思想家，美国总统前国家安全事务助理布热津斯基博士在20世纪90年代所著的《大棋局:美国的首要地位及其地缘战略》将欧亚大陆视为美国全球战略构想的关键区域。</p>
<p>⑩乔良在《时寒冰说：经济大棋局，我们怎么办》序言《悲壮的先知》结尾指出，国家性、国民性是构成制度和体制的土壤，不改变土壤结构去移植体制或制度，是本末倒置。</p>
<h3 id="u539F_u6587_u94FE_u63A5_uFF1A"><a href="#u539F_u6587_u94FE_u63A5_uFF1A" class="headerlink" title="原文链接："></a>原文链接：</h3><p><a href="https://book.douban.com/review/4980808/" target="_blank" rel="external">https://book.douban.com/review/4980808/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>《时寒冰说：经济大棋局，我们怎么办》是一部窥透世界大棋局的智慧之作，也是一部还原真相，普及常识的启蒙之作，时寒冰在书中淋漓尽致的演绎了他的利益与趋势分析法。</p>
<p>赵汀阳说，思想的主体部分虽然是知识，但思想的奠基部分却是智慧，尽管我们无法保证那些代表智慧的观念是真理。① 全球化时代，智慧的稀缺使得信息爆炸与思想贫乏成为最具讽刺意义的矛盾，而中国的现状尤为突出。时下，主旋律的和谐之音，左派救亡图存的革命论调，右派改革体制的变法主张，由“左右之争”②衍生出的国家主义、民族主义、民粹主义意识形态以及专靠胡说八道混饭吃的砖家叫兽的大放厥词③,可谓“五色令人目盲，五音令人耳聋，五味令人口爽” ④。可见，比通货膨胀更可怕的是信息爆炸和思想贫乏导致的大脑膨胀，我们需要用智慧来稀释膨胀。<br>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="趋势" scheme="http://paranoidq.github.io/tags/%E8%B6%8B%E5%8A%BF/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅的在多线程环境中log]]></title>
    <link href="http://paranoidq.github.io/2016/08/25/graceful-logging-in-concurrent-context/"/>
    <id>http://paranoidq.github.io/2016/08/25/graceful-logging-in-concurrent-context/</id>
    <published>2016-08-25T08:16:39.000Z</published>
    <updated>2016-08-26T05:24:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><h3 id="u65B9_u6848_u8BBE_u8BA1"><a href="#u65B9_u6848_u8BBE_u8BA1" class="headerlink" title="方案设计"></a>方案设计</h3><h3 id="u7F3A_u9677_u548C_u74F6_u9888"><a href="#u7F3A_u9677_u548C_u74F6_u9888" class="headerlink" title="缺陷和瓶颈"></a>缺陷和瓶颈</h3><h3 id="u4E3A_u4EC0_u4E48_u4E0D_u4F7F_u7528ELK"><a href="#u4E3A_u4EC0_u4E48_u4E0D_u4F7F_u7528ELK" class="headerlink" title="为什么不使用ELK"></a>为什么不使用ELK</h3><h3 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h3>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><h3 id="u65B9_u6848_u8BBE_u]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="log" scheme="http://paranoidq.github.io/tags/log/"/>
    
      <category term="系统设计" scheme="http://paranoidq.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux服务器性能调优常用工具及实例]]></title>
    <link href="http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/"/>
    <id>http://paranoidq.github.io/2016/08/02/linux-server-optimization-tools/</id>
    <published>2016-08-01T16:37:17.000Z</published>
    <updated>2016-08-01T17:00:58.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="u663E_u793A_u6307_u5B9A_u7528_u6237"><a href="#u663E_u793A_u6307_u5B9A_u7528_u6237" class="headerlink" title="显示指定用户"></a>显示指定用户</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ps -u root</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line"><span class="number">7</span> ?        00:<span class="number">00</span>:<span class="number">00</span> events/<span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29"><a href="#ps__u4E0Egrep__u7EC4_u5408_u4F7F_u7528_uFF0C_u67E5_u627E_u7279_u5B9A_u8FDB_u7A0B__28_u5E38_u7528_29" class="headerlink" title="ps 与grep 组合使用，查找特定进程 (常用)"></a>ps 与grep 组合使用，查找特定进程 (常用)</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep ssh</span><br><span class="line">root      <span class="number">2720</span>     <span class="number">1</span>  <span class="number">0</span> Nov02 ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="regexp">/usr/</span>sbin/sshd</span><br><span class="line">root     <span class="number">17394</span>  <span class="number">2720</span>  <span class="number">0</span> <span class="number">14</span>:<span class="number">58</span> ?        00:<span class="number">00</span>:<span class="number">00</span> <span class="string">sshd:</span> root<span class="meta">@pts</span>/<span class="number">0</span></span><br><span class="line">root     <span class="number">17465</span> <span class="number">17398</span>  <span class="number">0</span> <span class="number">15</span>:<span class="number">57</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep ssh</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09"><a href="#u5217_u51FA_u76EE_u524D_u6240_u6709_u7684_u6B63_u5728_u5185_u5B58_u4E2D_u7684_u7A0B_u5E8F__28_u5E38_u7528_uFF09" class="headerlink" title="列出目前所有的正在内存中的程序 (常用）"></a>列出目前所有的正在内存中的程序 (常用）</h4><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line"><span class="symbol">USER</span>       <span class="symbol">PID</span> <span class="comment">%CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span></span><br><span class="line">root         <span class="number">1</span>  <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">10368</span>   <span class="number">676</span> ?        <span class="symbol">Ss</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> init [<span class="number">3</span>]</span><br><span class="line">root         <span class="number">2</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">3</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">0</span>]</span><br><span class="line">root         <span class="number">4</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">S</span>&lt;   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">01</span> [migration/<span class="number">1</span>]</span><br><span class="line">root         <span class="number">5</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        <span class="symbol">SN</span>   <span class="symbol">Nov02</span>   <span class="number">0</span>:<span class="number">00</span> [ksoftirqd/<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>输出含义：<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USER：该 <span class="keyword">process</span> 属于那个使用者账号的</span><br><span class="line">PID ：该 <span class="keyword">process</span> 的号码</span><br><span class="line">%CPU：该 <span class="keyword">process</span> 使用掉的 CPU 资源百分比</span><br><span class="line">%MEM：该 <span class="keyword">process</span> 所占用的物理内存百分比</span><br><span class="line">VSZ ：该 <span class="keyword">process</span> 使用掉的虚拟内存量 (Kbytes)</span><br><span class="line">RSS ：该 <span class="keyword">process</span> 占用的固定的内存量 (Kbytes)</span><br><span class="line">TTY ：该 <span class="keyword">process</span> 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/<span class="number">0</span> 等等的，则表示为由网络连接进主机的程序。</span><br><span class="line">STAT：该程序目前的状态，主要的状态有</span><br><span class="line">R ：该程序目前正在运作，或者是可被运作</span><br><span class="line">S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (<span class="keyword">signal</span>) 唤醒。</span><br><span class="line">T ：该程序目前正在侦测或者是停止了</span><br><span class="line">Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</span><br><span class="line">START：该 <span class="keyword">process</span> 被触发启动的时间</span><br><span class="line"><span class="built_in">TIME</span> ：该 <span class="keyword">process</span> 实际使用 CPU 运作的时间</span><br><span class="line">COMMAND：该程序的实际指令</span><br></pre></td></tr></table></figure></p>
<h4 id="ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B"><a href="#ps_-ef_u4E0E_ps_aux_u7684_u533A_u522B" class="headerlink" title="ps -ef与 ps aux的区别"></a>ps -ef与 ps aux的区别</h4><p><code>ps aux</code>最初用到Unix Style中，而<code>ps -ef</code>被用在System V Style中，两者输出略有不同。现在的大部分Linux系统都是可以同时使用这两种方式的。</p>
<p><code>ps aux</code>中与<code>ps -ef</code>不同的列有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER      <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">%CPU</span>      <span class="comment">//进程占用的CPU百分比</span></span><br><span class="line"><span class="built_in">%MEM</span>      <span class="comment">//占用内存的百分比</span></span><br><span class="line">VSZ       <span class="comment">//该进程使用的虚拟內存量（KB）</span></span><br><span class="line">RSS       <span class="comment">//该进程占用的固定內存量（KB）（驻留中页的数量）</span></span><br><span class="line">STAT      <span class="comment">//进程的状态</span></span><br><span class="line">START     <span class="comment">//该进程被触发启动时间</span></span><br><span class="line">TIME      <span class="comment">//该进程实际使用CPU运行的时间</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>STAT</code>状态为的常见字符有：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">D</span>      <span class="comment">//无法中断的休眠状态（通常 IO 的进程）；</span></span><br><span class="line"><span class="keyword">R</span>      <span class="comment">//正在运行可中在队列中可过行的；</span></span><br><span class="line"><span class="keyword">S</span>      <span class="comment">//处于休眠状态；</span></span><br><span class="line">T      <span class="comment">//停止或被追踪；</span></span><br><span class="line"><span class="keyword">W</span>      <span class="comment">//进入内存交换 （从内核2.6开始无效）；</span></span><br><span class="line"><span class="keyword">X</span>      <span class="comment">//死掉的进程 （基本很少见）；</span></span><br><span class="line">Z      <span class="comment">//僵尸进程；</span></span><br><span class="line">&lt;      <span class="comment">//优先级高的进程</span></span><br><span class="line">N      <span class="comment">//优先级较低的进程</span></span><br><span class="line"><span class="keyword">L</span>      <span class="comment">//有些页被锁进内存；</span></span><br><span class="line"><span class="keyword">s</span>      <span class="comment">//进程的领导者（在它之下有子进程）；</span></span><br><span class="line"><span class="keyword">l</span>      <span class="comment">//多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；</span></span><br><span class="line">+      <span class="comment">//位于后台的进程组；</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat"><a href="#u67E5_u770B_u7AEF_u53E3_u60C5_u51B5_netstat" class="headerlink" title="查看端口情况 netstat"></a>查看端口情况 netstat</h3><h4 id="u5217_u51FA_u6240_u6709_u8FDE_u63A5"><a href="#u5217_u51FA_u6240_u6709_u8FDE_u63A5" class="headerlink" title="列出所有连接"></a>列出所有连接</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -a</span><br><span class="line">Active Internet connections (servers <span class="keyword">and</span> established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">enlightened:</span>domain      *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ipp           *<span class="symbol">:*</span>                     LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">54750</span> li24<span class="number">0</span>-<span class="number">5</span>.members.<span class="symbol">li:</span>http ESTABLISHED</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span><span class="number">49980</span> del01s07-<span class="keyword">in</span>-f14.<span class="number">1</span><span class="symbol">:https</span> ESTABLISHED</span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ip6-<span class="symbol">localhost:</span>ipp       [<span class="symbol">:</span><span class="symbol">:</span>]<span class="symbol">:*</span>                  LISTEN </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t"><a href="#u5217_u51FAtcp/udp_u8FDE_u63A5_-u_u548C-t" class="headerlink" title="列出tcp/udp连接 <code>-u</code>和<code>-t</code>"></a>列出tcp/udp连接 <code>-u</code>和<code>-t</code></h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -at</span><br><span class="line"><span class="variable">$ </span>netstat -au</span><br></pre></td></tr></table></figure>
<h4 id="u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n"><a href="#u7981_u7528_u53CD_u5411_u57DF_u540D_u89E3_u6790_uFF0C_u52A0_u5FEB_u67E5_u8BE2_u901F_u5EA6_-n" class="headerlink" title="禁用反向域名解析，加快查询速度 <code>-n</code>"></a>禁用反向域名解析，加快查询速度 <code>-n</code></h4><p>没有必要知道主机名，就使用 -n 选项禁用域名解析功能<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>netstat -ant</span><br></pre></td></tr></table></figure></p>
<h4 id="u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l"><a href="#u53EA_u5217_u51FA_u76D1_u542C_u4E2D_u7684_u7AEF_u53E3_-l" class="headerlink" title="只列出监听中的端口 <code>-l</code>"></a>只列出监听中的端口 <code>-l</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -tnl</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN     </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN</span><br></pre></td></tr></table></figure>
<p>不要使用<code>-a</code>，否则linux会列出所有端口，而不只是监听（LISTEN）端口</p>
<h4 id="u53EA_u5217_u51FAactive_u7AEF_u53E3"><a href="#u53EA_u5217_u51FAactive_u7AEF_u53E3" class="headerlink" title="只列出active端口"></a>只列出active端口</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -atnp | grep ESTA</span><br><span class="line">(<span class="keyword">Not</span> all processes could be identified, non-owned process info</span><br><span class="line"> will <span class="keyword">not</span> be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">49156</span>       <span class="number">173.255</span><span class="meta">.230</span><span class="meta">.5</span>:<span class="number">80</span>        ESTABLISHED <span class="number">1691</span>/chrome     </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span><span class="meta">.1</span><span class="meta">.2</span>:<span class="number">33324</span>       <span class="number">173.194</span><span class="meta">.36</span><span class="meta">.117</span>:<span class="number">443</span>      ESTABLISHED <span class="number">1691</span>/chrome</span><br></pre></td></tr></table></figure>
<p>active 状态的套接字连接用 “ESTABLISHED” 字段表示</p>
<h4 id="u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p"><a href="#u5217_u51FA_u8FDB_u7A0B_u540D_uFF0C_u8FDB_u7A0B_u53F7_u548C_u7528_u6237ID_-p" class="headerlink" title="列出进程名，进程号和用户ID <code>-p</code>"></a>列出进程名，进程号和用户ID <code>-p</code></h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo netstat -nlpt</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.1</span><span class="meta">.1</span>:<span class="number">53</span>            <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">1144</span>/dnsmasq    </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">631</span>           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:*               LISTEN      <span class="number">661</span>/cupsd       </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> ::<span class="number">1</span>:<span class="number">631</span>                 :::*                    LISTEN      <span class="number">661</span>/cupsd</span><br></pre></td></tr></table></figure>
<p>必须要root权限才能显示！如果没有root需要查看端口对应的进程，请参考<code>lsof</code><br><code>-ep</code>选项可以同时查看进程名和用户名</p>
<h4 id="u5B9E_u6218"><a href="#u5B9E_u6218" class="headerlink" title="实战"></a>实战</h4><ol>
<li>查看服务是否运行<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo netstat -aple | grep ntp</span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> enlightened.<span class="symbol">local:</span>ntp   *<span class="symbol">:*</span>     root       <span class="number">17430</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> <span class="symbol">localhost:</span>ntp           *<span class="symbol">:*</span>     root       <span class="number">17429</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> *<span class="symbol">:ntp</span>                   *<span class="symbol">:*</span>     root       <span class="number">17422</span>       <span class="number">1789</span>/ntpd       </span><br><span class="line">udp6       <span class="number">0</span>      <span class="number">0</span> <span class="symbol">fe80:</span><span class="symbol">:</span><span class="number">216</span><span class="symbol">:</span><span class="number">36</span><span class="symbol">ff:</span><span class="symbol">fef8:</span>ntp [<span class="symbol">:</span><span class="symbol">:</span>]    root       <span class="number">17432</span>       <span class="number">1789</span>/ntpd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<!--more-->
<ol>
<li><p>查看端口号的占用情况</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -an <span class="string">| grep 12000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结合<code>watch</code>监控active状态的连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ watch <span class="_">-d</span> -n0 <span class="string">"netstat -atnp | grep ESTA"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="u9644_uFF1Awatch_u547D_u4EE4"><a href="#u9644_uFF1Awatch_u547D_u4EE4" class="headerlink" title="附：watch命令"></a>附：watch命令</h4><p>watch可以帮助使用者监测一个命令的运行结果，避免重复手动运行。watch命令会周期执行<br>参数：</p>
<ul>
<li>-n 时间间隔，缺省值为2s</li>
<li>-d 高亮显示变化区域</li>
<li>-t 关闭watch命令在顶部的时间间隔</li>
</ul>
<p>实例：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">每隔一秒高亮显示http链接数的变化情况</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">1</span> -d <span class="string">'pstree|grep http'</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>秒一次输出系统的平均负载</span><br><span class="line"><span class="variable">$ </span>watch -n <span class="number">10</span> <span class="string">'cat /proc/loadavg'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B"><a href="#u67E5_u770B_u4F7F_u7528CPU_5CMEM_u6700_u591A_u7684_u8FDB_u7A0B" class="headerlink" title="查看使用CPU\MEM最多的进程"></a>查看使用CPU\MEM最多的进程</h3><h3 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ps.html" target="_blank" rel="external">ps</a><br><a href="https://linux.cn/article-2434-1.html" target="_blank" rel="external">netstat</a><br><a href="http://www.cnblogs.com/peida/archive/2012/12/31/2840241.html" target="_blank" rel="external">watch</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps"><a href="#u67E5_u770B_u8FDB_u7A0B_u60C5_u51B5_3A_ps" class="headerlink" title="查看进程情况: ps"></a>查看进程情况: ps</h3><h4 id="u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F"><a href="#u663E_u793A_u6240_u6709_u8FDB_u7A0B_u4FE1_u606F" class="headerlink" title="显示所有进程信息"></a>显示所有进程信息</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ps -A</span><br><span class="line">PID TTY      TIME   CMD</span><br><span class="line"><span class="number">1</span> ?        00:<span class="number">00</span>:<span class="number">00</span> init</span><br><span class="line"><span class="number">2</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">0</span></span><br><span class="line"><span class="number">3</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">4</span> ?        00:<span class="number">00</span>:<span class="number">01</span> migration/<span class="number">1</span></span><br><span class="line"><span class="number">5</span> ?        00:<span class="number">00</span>:<span class="number">00</span> ksoftirqd/<span class="number">1</span></span><br><span class="line"><span class="number">6</span> ?        00:<span class="number">29</span>:<span class="number">57</span> events/<span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[BASE64换行符的坑]]></title>
    <link href="http://paranoidq.github.io/2016/08/01/base64-newline-trap/"/>
    <id>http://paranoidq.github.io/2016/08/01/base64-newline-trap/</id>
    <published>2016-08-01T13:29:38.000Z</published>
    <updated>2016-10-11T12:15:05.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>
<a id="more"></a>
<h3 id="u95EE_u9898_u7684_u5206_u6790"><a href="#u95EE_u9898_u7684_u5206_u6790" class="headerlink" title="问题的分析"></a>问题的分析</h3><p>问题在于为什么发送方的报文会多出来<code>/r/n</code>呢？</p>
<h4 id="Step_1"><a href="#Step_1" class="headerlink" title="Step 1"></a>Step 1</h4><p>首先看回车和换行符的区别：</p>
<blockquote>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。<br>     于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。<br>这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。<br>      后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。<br>Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“ &lt;回车&gt;&lt;换 行&gt;”，即“\r\n”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打 开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p>
</blockquote>
<p>所以导致的问题应该就是client端是windows系统，而我们这边处理的系统在linux下，因此就会有<code>/r/n</code>的问题。</p>
<h4 id="Step_2"><a href="#Step_2" class="headerlink" title="Step 2"></a>Step 2</h4><p>OK，让对方去掉报文中的换行之后，问题还是存在。而且还有新的发现：</p>
<blockquote>
<p>BASE64之后，当字符串过长（一般超过76）时会自动在中间加一个换行符。及时我们自己测试的报文完全没有任何换行存在。</p>
</blockquote>
<p>于是想办法去研究<code>sun.misc.BASE64Encoder</code>的源码，有了一些发现。</p>
<p>BASE64主要调用的方法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"abcd"</span>.getBytes();</span><br><span class="line">BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">encoder.encodeBuffer(bytes);</span><br></pre></td></tr></table></figure></p>
<p>encodeBuffer源码的大致情况：(大部分源码位于<code>BASE64Encoder</code>的父类<code>CharacterEncoder</code>中)<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> encodeBuffer(<span class="built_in">byte</span> aBuffer[]) &#123;</span><br><span class="line">    ByteArrayOutputStream   outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ByteArrayInputStream    inStream = <span class="keyword">new</span> ByteArrayInputStream(aBuffer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        encodeBuffer(inStream, outStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception IOException) &#123;</span><br><span class="line">        <span class="comment">// This should never happen.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"CharacterEncoder.encodeBuffer internal error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (outStream.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode bytes from the input stream, and write them as text characters</span><br><span class="line"> * to the output stream. This method will run until it exhausts the</span><br><span class="line"> * input stream, but does not print the line suffix for a final</span><br><span class="line"> * line that is shorter than bytesPerLine().</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> encode(InputStream inStream, OutputStream outStream)</span><br><span class="line">    <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">int</span>     j;</span><br><span class="line">    <span class="built_in">int</span>     numBytes;</span><br><span class="line">    <span class="built_in">byte</span>    tmpbuffer[] = <span class="keyword">new</span> <span class="built_in">byte</span>[bytesPerLine()];</span><br><span class="line"></span><br><span class="line">    encodeBufferPrefix(outStream); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        numBytes = readFully(inStream, tmpbuffer);</span><br><span class="line">        <span class="keyword">if</span> (numBytes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encodeLinePrefix(outStream, numBytes); </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numBytes; j += bytesPerAtom()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((j + bytesPerAtom()) &lt;= numBytes) &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, bytesPerAtom());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                encodeAtom(outStream, tmpbuffer, j, (numBytes)- j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numBytes &lt; bytesPerLine()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encodeLineSuffix(outStream); <span class="comment">// 这一行会输出换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    encodeBufferSuffix(outStream); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Encode the suffix that ends every output line. By default</span><br><span class="line"> * this method just prints a &lt;newline&gt; into the output stream.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> encodeLineSuffix(OutputStream aStream) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    pStream.<span class="built_in">println</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>encodeLineSuffix</code>会输出换行。也就是每次读满一个buffer大小的时候，都会输出一个换行。buffer的大小是由<code>bytesPerLine()</code>函数决定的，该函数是一个抽象函数，由子类实现。而在BASE64Encoder中，该函数的返回值为57.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * this class encodes 57 bytes per line. This results in a maximum</span><br><span class="line"> * of 57/3 * 4 or 76 characters per output line. Not counting the</span><br><span class="line"> * line termination.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">bytesPerLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">57</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://stackoverflow.com/questions/9341047/carriage-return-issue-decoding-base64-from-java-and-sending-to-browser" target="_blank" rel="external">StackOverflow上有回答</a>这是做了一种<code>chunking</code>，在每一个<code>chunk</code>后面添加了<code>/n</code>。并且sun的库函数只存在于oracle的jvm下面，而不存在于其他jvm中。</p>
<h3 id="Step_3"><a href="#Step_3" class="headerlink" title="Step 3"></a>Step 3</h3><p><code>encode</code>与<code>encodeBuffer</code>有细微的区别：<code>encodeBuffer</code>会在最后一行不足<code>bytesPerline()</code>时添加一个换行符，而encode则不会做处理。</p>
<p>貌似很坑爹，做了如此多的隐含处理，让调用者想死的心都有了。</p>
<h3 id="u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5"><a href="#u4E00_u52B3_u6C38_u9038_u7684_u529E_u6CD5" class="headerlink" title="一劳永逸的办法"></a>一劳永逸的办法</h3><p>建议使用<code>org.apache.commons.codec.binary.Base64</code>库：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base<span class="number">64.</span>e<span class="symbol">ncodeBase64</span><span class="comment">(..)</span>;</span><br><span class="line">Base<span class="number">64.</span>decodeBase<span class="number">64</span><span class="comment">(..)</span></span><br></pre></td></tr></table></figure></p>
<p>并且该库显示指明了，你是否需要<code>chunk</code>选项和<code>urlsafe</code>选项（避免输出<code>+</code>和<code>/</code>，而是输出<code>-</code>和<code>_</code>）：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeBase64Chunked(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData)</span><br><span class="line">encodeBase64(<span class="keyword">final</span> <span class="keyword">byte</span>[] binaryData, <span class="keyword">final</span> <span class="keyword">boolean</span> isChunked)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u95EE_u9898_u63CF_u8FF0"><a href="#u95EE_u9898_u63CF_u8FF0" class="headerlink" title="问题描述"></a>问题描述</h3><p>client发报文给server，server端接收到http post发来的报文之后做base64解码，然后通过消息中间件传给核心系统进行处理。然后发现，client端发过来的报文会多出很多<code>/r/n</code>这样的字符，导致核心系统base64解码后也多出了<code>/r/n</code>，而核心系统之前没有考虑到这些问题，从而报错。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="base64" scheme="http://paranoidq.github.io/tags/base64/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人已经破产，靠还没倒闭的行业活着（转载）]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/%E4%B8%AA%E4%BA%BA%E5%B7%B2%E7%BB%8F%E7%A0%B4%E4%BA%A7/"/>
    <id>http://paranoidq.github.io/2016/07/25/个人已经破产/</id>
    <published>2016-07-25T13:14:31.000Z</published>
    <updated>2016-07-25T13:24:20.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd" target="_blank" rel="external">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>
<a id="more"></a>
<h3 id="u4E8C"><a href="#u4E8C" class="headerlink" title="二"></a>二</h3><p>想起当年电视台如日中天炙手可热的时候，我领教过的一个台里员工。那位负责灯光的人被称为“灯爷”，对别人永远是颐指气使的口吻，对自己永远觉得含着天大的委屈，找他做最简单的事情都得陪着笑脸，而他做最分内的事情都觉得是别人在给他添麻烦。</p>
<p>更可怕的是，我们都对这样的大爷习以为常。他老人家稍微嘴脸好看点儿，手脚勤快点儿，便觉得是恩赐。</p>
<p>直到后来见识了一位香港“灯爷”：永远不用你操心、催促，在规定的时间内到位，黑着脸不许别人碰他的器材，手脚麻利地快速解决一切事情，工作成效之高、之专业，几乎都让你意识不到他的存在。</p>
<p>再看我们这位爷，遇到潜在的金主，想给自己捞点野活挣点外快，就倨傲又殷勤地给人家递名片：我是中央台的。</p>
<p>那时的我年轻气盛，看到这一幕，鄙夷地想：把你名片上“中央电视台”那几个字划掉，你什么也不是。</p>
<h3 id="u4E09"><a href="#u4E09" class="headerlink" title="三"></a>三</h3><p>这些年，中国房地产行业空前繁荣。建筑师这个职业，应该是机会大大的，挣钱多多的，心里美美的吧。</p>
<p>一位建筑界的老师却对我说，高歌猛进的房地产行业，还有那些地标式的公共建筑，不仅对城市、对环境造成破坏，对公众审美形成摧残，还把一代建筑师给毁了。</p>
<p>我吃惊地问为什么。他的要点是：因为活儿太多，素质不高的设计师也可以有干不完的单子应接不暇；因为钱太好挣，许多建筑师没有了自我提高的主动与自觉；因为工程太赶，缺乏原创、智慧含量和时间成本越少的设计成为首选，行业的水准线便越来越低。</p>
<p>一位做建筑图书的出版业同行，准备引进一套欧洲建筑丛书，全套有二三百本，囊括了当代建筑的各位大师，全面呈现其作品和建筑理念。我想当然地认为这套书会很好卖，因为它本来口碑就好，建筑装饰类图书又永远在书店里占据相当比重，中国的建筑设计行业人多，钱多，需求又大。</p>
<p>她说给我的发行量却低得惊人。这套书只引进了十几种，原来宏伟的出版计划看来会中途夭折。</p>
<p>她的观点也是：大家的学习动力没有了，因为钱太容易挣。一个建筑师不用看这些书，照样有挣不完的钱。</p>
<p>一个行业的繁荣，对个人来说是好事还是坏事？</p>
<h3 id="u56DB"><a href="#u56DB" class="headerlink" title="四"></a>四</h3><p>我们去年签下一套英文书的版权，写人类伟大的历史文化遗迹。因为它和建筑有很大关系，所以我想邀请建筑界的专家——外语又好、又懂建筑的人来翻译。</p>
<p>找到一位人脉广的老师求助，他说，你可能在建筑界找不到人。没人愿意接你的活儿。你看，能够胜任翻译的人，得是具备一定能力和资历的人。一本书的翻译至少要几个月的时间，稿费最多几万块钱，可人家用几个晚上时间画建筑图纸，就能挣几万块。</p>
<p>我说，这不正好吗？用几天时间画图，把几万块钱挣出来，那不就没有后顾之忧，更能踏踏实实、专心致志搞翻译了吗？</p>
<p>你这个逻辑太自作多情了，也把你的书看得太重要了。人家想的是，花几个月时间来翻译你这本书的话，就意味着耽误了画多少图、失去了挣多少钱的机会。并且这种活儿都还排着队等他来接呢，谁还稀罕为你翻译，谁算不明白这笔账呢？</p>
<p>一个人都温饱无忧了，何必还为挣钱，把自己搞得连翻译一本书这么有乐趣的事都不做呢？我兀自不甘心地咕哝。</p>
<p>有了小房子还要改善性住宅，有了大房子还要弄别墅。永远挣不完的钱，永远画不完的图。大家的时间，都用来赶这些行活了。</p>
<p>好吧，我之蜜糖，彼之砒霜。</p>
<h3 id="u4E94"><a href="#u4E94" class="headerlink" title="五"></a>五</h3><p>改革开放三十多年，破产的公司、机构不计其数，但中国几百家出版社，好像自始至终没有一家倒闭的。</p>
<p>行业的繁荣或依赖政策形成的稳定，会给一些鱼龙混杂、蜂拥而入的从业人员造成错觉，相信自己可以高枕无忧不思进取，甚至以为自己“亦有贡献”。可在危机来临之前，一个人的能力储备、职业素养、知识更新、自我成长，会自觉地被激发、强调出来么？</p>
<p>写到这里，我突然有一种担心：这些永不倒闭的出版社，已经把一些编辑养残，自我破产了。</p>
<p>我们有没有勇气和清醒，独立于外部环境和行业冷暖，明白自己要做些什么？</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文转载自: <a href="http://mp.weixin.qq.com/s?__biz=MjM5OTM4MDY4MQ==&amp;mid=2650101881&amp;idx=1&amp;sn=19f426423f01f34015685ab146119469&amp;scene=23&amp;srcid=0725foRg46546T20CysgOR9b#rd">读库-张立宪</a></p>
</blockquote>
<p>遇到几件职场上的事情，引发一些感触，在这里一并写出来，与大家一起怀疑下人生。</p>
<h3 id="u4E00"><a href="#u4E00" class="headerlink" title="一"></a>一</h3><p>我属于那种乐观型选手，相信在现在这个世道，不管是来自家人扶助、社会救济，或者有基本社会能力的成年人随便找个工作，温饱都不会有问题，至少饿不死。有了这个底气，再去做什么，就看自己的能力、志趣和因缘了。去年在上海，有位杂志编辑，说他们的杂志快不行了。我便与他共勉：只有破产的公司，没有倒闭的个人。</p>
<p>两个月前又见到一位同行，他本是一家颇有名望的杂志社老总，如今再创业，风生水起。我问他用人之道，他说很重要的一条心得是：尽量不用媒体人，尤其是那些老部下。</p>
<p>这种说法让我很是意外。听他一一道来：当年纸媒红火的时候，那些以“名记”身份行走传媒江湖的人，既眼高手低，又好吃懒做，真真徒有虚名，名不副实。整天乐于听人恭维，忙于开发布会拿红包，急于炫耀自己社会关系之广，却连篇软文也写不好。我不由得表示赞同，听他接着说：这样的名记，是被他所在的媒体赋予的名声，并且也被惯坏了，我要真把他招过来，既不好用，也用不起。</p>
<p>这位仁兄的偏见实在是颇有道理：有的人实际上已经个人破产，只是在靠所供职的还没倒闭的机构活着。</p>
<p>冷静想一下，我们是否已经让自己处于这种境地？</p>]]>
    
    </summary>
    
      <category term="社会" scheme="http://paranoidq.github.io/tags/%E7%A4%BE%E4%BC%9A/"/>
    
      <category term="思考" scheme="http://paranoidq.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="社会" scheme="http://paranoidq.github.io/categories/%E7%A4%BE%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的书单]]></title>
    <link href="http://paranoidq.github.io/2016/07/25/just-reading/"/>
    <id>http://paranoidq.github.io/2016/07/25/just-reading/</id>
    <published>2016-07-24T16:14:07.000Z</published>
    <updated>2016-07-24T16:26:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/" target="_blank" rel="external">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/" target="_blank" rel="external">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/" target="_blank" rel="external">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/" target="_blank" rel="external">创业维艰</a></p>
<a id="more"></a>
<h3 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h3><p><a href="https://book.douban.com/subject/6709783/" target="_blank" rel="external">浪潮之巅</a> (完成)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u4EBA_u6587"><a href="#u4EBA_u6587" class="headerlink" title="人文"></a>人文</h3><p><a href="http://book.douban.com/subject/1059336/">往事并不如烟</a> (完成)<br><a href="http://book.douban.com/subject/1438394/">更多的人死于心碎</a></p>
<h3 id="u793E_u4F1A"><a href="#u793E_u4F1A" class="headerlink" title="社会"></a>社会</h3><p><a href="https://book.douban.com/subject/1472854/">山坳上的中国</a><br><a href="http://book.douban.com/subject/26306686/">创业维艰</a></p>]]>
    
    </summary>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="todo" scheme="http://paranoidq.github.io/tags/todo/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="阅读" scheme="http://paranoidq.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生新阶段随笔（1）]]></title>
    <link href="http://paranoidq.github.io/2016/07/15/%E4%BA%BA%E7%94%9F%E6%96%B0%E9%98%B6%E6%AE%B5%E9%9A%8F%E7%AC%94-1/"/>
    <id>http://paranoidq.github.io/2016/07/15/人生新阶段随笔-1/</id>
    <published>2016-07-15T12:02:53.000Z</published>
    <updated>2016-07-15T12:45:30.000Z</updated>
    <content type="html"><![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>
<a id="more"></a>
<p>说道知识和技能，这个其实是我不太满意的地方。虽说之前可能也有心理准备，但是进入到公司才发现，国企确实在技术上的发展不够好，或者说不够有技术的激情。当然，已经工作多年的前辈肯定是比我懂得多，但总感觉整个技术开发中心的氛围不够好，这点可能真的无法跟互联网公司相比。不过，其实互联网公司的技术其实也就集中于几个核心的部门，其他大部分也都是完成业务而已。这点上，在EMC这样的外企实习过的同事其实还蛮有发言权的。因此，<strong>公司可能只是一个平台，更多的还是要考自己去主动地学习和探索。问题其实天天都会有，就看你愿不愿意花时间去学了</strong>。</p>
<p>工作的同事其实还是蛮nice的，大家人都非常随和，没有传统国企那种等级森严的感觉。虽然有些师兄已经工作了近十年了，但是还是可以跟我们聊得很好。当然，我之前定下的目标就是要努力处理好自己的人事关系，目前看来还算不错，基本上跟组里的同事相处的很好，能够主动跟他们交流。搁过去的话，我估计还不会有这样的表现，所以算是步入社会之后强迫自己的一种改变吧。能够跟各种人正常的交往也算是一种极为重要的生活技能。</p>
<p>目前组里做的东西说白了就是适配，适配各种行业和机构的接口。本质上，这东西其实还是有一定技术含量的，不过就我目前研究的线上系统WCG的源码来看，写的确实不怎么样，感觉连我这个在校生都不如，各种magic number随便乱写，配置也随便乱写，系统模块和类设计不合理的地方很多。所以目前我的想法是能够重构这个系统，感觉如果能够进行下去的话，应该是一次难得的学习机会，毕竟无论是个人技术成长还是将来跳槽，这都是一个有利的加分项。而<strong>难点在于，如何设计一个好的系统架构，并且考虑到测试成本的问题，系统重构的过程需要尽量的step-by-step，类似于持续集成吧</strong>。这方面，在没有人带我的情况下，感觉是最困难的地方了。架构的问题，可能需要我上网查阅很多资料，如果能够有人请教的话就最好了。而关于重构成本的问题，这估计也是领导最为关心的问题，所以我接下来要做的工作应该是<strong>证明系统重构能够带来很大的好处，并且尽量减小重构对于目前运行的功能的稳定性影响</strong>。</p>
<p>跳槽的问题其实也是这两周困扰我的问题之一，虽然目前还算适应现在的工作环境，但是跳槽可能还是在我的计划中，毕竟我向往更加富有技术激情和技术发展空间的平台。因此，每天晚上我都会固定时间学习，但是总感觉时间不够用。觉得可能是效率不够高。反思一下，应该是学习的东西太过零散，然后每次看到比较复杂的东西，总是想往后拖，然后就不了了之了。所以，后续的改进方向应该是: <strong>大概每周确定一个学习的目标，围绕着这个主线学习。然后抽出一部分时间，解决工作中遇到的问题，每次解决一个问题的时候，就尽量深入弄懂，不要一知半解地结束。这样每接触到一个知识，就能解决一个了。然后每周的主线应该围绕将来自己想深入的方向去学习探索，主要的手段是看书+看系列博客+写demo相结合的方式。</strong><br>其实，做site project是个不错的选择，但是缺的是idea。比较好的方案是，写一些算法相关的project或者小游戏，这些花费的时间不多，并且应该能有一些帮助。这个后续需要再思考思考！！！毕竟，<strong>项目经验在未来的跳槽中估计有着很重要的作用，这点需要时刻提醒自己注意一下</strong>！！！</p>
<p>生活上，发现自己基本上没什么娱乐时间了，感觉回来学习一会儿，运动一会洗个澡，再视频半小时就睡觉了。唉，发现到了工作中真的是时间不够用了。之前计划好的，学日语、学上海话还有看电影写影评之类的通通没时间完成，估计应该调整一下思路，这些东西应该放到周末休息时间去做。这样比较合理。</p>
<p>另外就是去苏州看了一下房子，海胥澜庭地段确实好，也是个三学区的房子。不过价格超贵，感觉还是有点承受不起。前几日，考虑到我跳槽不一定能跳到苏州的问题，觉得可能园区还是比较适合。以来跳槽之后在园区的可能性比较大，上班方便；而来，如果不能跳，将来工作重新找到浦西的话，去上海上班还是比较方便的。而且园区房价的抗跌性还是很好的。如果想去杭州的话，房子卖了应该不成问题。另一个考虑就是学区房的问题，这个需要调查一下，到底学区房需要提前几年买的问题。目前我的估计是5年之内我应该用不上学区房了。所以可以不考虑学区房的问题暂时。目前是这样打算的。</p>
<p>恩，总结到这里，最后摘一句话自勉：<br>—— <em>其实学习是个慢功夫，讲究节奏，就像认真的模仿，看上去很慢很循规蹈矩，但一步步走下来，确是成长最快的途径。这在我们这个事事都追求效率的时代，显得弥足珍贵</em>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始工作接近两周时间，算是成功从一个天真的在校学生变成了半个社会人士。<br>两周的时间虽然工作上没写什么代码，每天也没怎么需要加班加点，但感觉还是挺忙碌的。上周去苏州陪女友玩了两天，这周也算得空了，自己可以好好想想这两周以来的生活和工作。</p>
<p>工作上的变化确实是蛮大的，跟学校里那种轻松自由的节奏完全不同。倒不是主管push你，反而是自己觉得如果没事情做，就会很着急。所以总是想方设法让自己忙碌起来，找事情做。感觉这样的想法还是挺好的，毕竟作为一个刚毕业的学生，最重要的还是能尽快学到知识和技能吧。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://paranoidq.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="随笔" scheme="http://paranoidq.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Java局部类不能访问外围的非final局部变量的探索]]></title>
    <link href="http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/"/>
    <id>http://paranoidq.github.io/2016/07/04/java-inner-class-final-problem/</id>
    <published>2016-07-04T13:04:47.000Z</published>
    <updated>2016-07-15T12:43:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>
<a id="more"></a>
<p>为了清晰，首先用例子探索一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by paranoidq on 16/7/4.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        String str = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">        Date[] dates = <span class="keyword">new</span> Date[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dates.length; i++) &#123;</span><br><span class="line">            dates[i] = <span class="keyword">new</span> Date() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span> </span>&#123;</span><br><span class="line">                    System.out.println(counter);    <span class="comment">// case1: int不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(counter++);  <span class="comment">// case2: int修改 -&gt; compiler error</span></span><br><span class="line">                    System.out.println(str);        <span class="comment">// case3: string不修改 -&gt; 通过</span></span><br><span class="line">                    System.out.println(str + <span class="string">"t"</span>);  <span class="comment">// case4: string为不可变对象 -&gt; 通过</span></span><br><span class="line"></span><br><span class="line">                    str = <span class="string">"aaa"</span>;</span><br><span class="line">                    System.out.println(str);        <span class="comment">// case5: 修改了string -&gt; 不通过</span></span><br><span class="line">                    <span class="comment">// Error:</span></span><br><span class="line">                    <span class="comment">// Variable str is accessed from within inner class,</span></span><br><span class="line">                    <span class="comment">// need to be final or effectively final</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.compareTo(anotherDate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u5206_u6790"><a href="#u5206_u6790" class="headerlink" title="分析"></a>分析</h3><p>我们发现，其实编译器足够智能，对于case1和case3而言，虽然访问了非final局部变量，但是还是通过编译了，而只有在case2、case5中修改了局部变量时，才报错。而对于case4而言，涉及到string对象不可变的另一个知识点，这里略过。</p>
<p>分析报错的提示，可以知道，实际上对于局部类访问外部变量的规则，相对比较宽松，只要是<code>final or effectively final</code>即可，所谓<code>effectively final</code>其实也就是在局部类内没有做出实质性的修改动作，这一类情况编译器也是让过的。</p>
<h3 id="u539F_u56E0"><a href="#u539F_u56E0" class="headerlink" title="原因"></a>原因</h3><p>为什么在局部类内不能访问外部的非final局部变量呢？参考<a href="http://android.blog.51cto.com/268543/384844" target="_blank" rel="external">这个帖子</a>，写的很到位。引用如下</p>
<p>这是一个编译器设计的问题，如果你了解java的编译原理的话很容易理解。<br>首先，内部类被编译的时候会生成一个单独的内部类的.class文件，这个文件并不与外部类在同一class文件中。<br>当外部类传的参数被内部类调用时，从java程序的角度来看是直接的调用例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(<span class="keyword">final</span> String a,<span class="keyword">final</span> <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Dosome</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">()</span></span>&#123;System.out.println(a+b)&#125;&#125;;  </span><br><span class="line">  Dosome some=<span class="keyword">new</span> Dosome();  </span><br><span class="line">  some.dosome();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码来看好像是那个内部类直接调用的a参数和b参数，但是实际上不是，在java编译器编译以后实际的操作代码是:</p>
<pre><code>class Outer$Dosome{  
    public Dosome(final String a,final int b){  
        this.Dosome$a=a;  
        this.Dosome$b=b;  
    }  
    public void dosome(){  
        System.out.println(this.Dosome$a+this.Dosome$b);  
    }  
}
</code></pre><p>从以上代码看来，内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，自己内部的方法调用的实际是自己的属性而不是外部类方法的参数。  </p>
<p>这样理解就很容易得出为什么要用final了，因为两者从外表看起来是同一个东西，实际上却不是这样，如果内部类改掉了这些参数的值也不可能影响到原参数，然而这样却失去了参数的一致性，因为从编程人员的角度来看他们是同一个东西，如果编程人员在程序设计的时候在内部类中改掉参数的值，但是外部调用的时候又发现值其实没有被改掉，这就让人非常的难以理解和接受，为了避免这种尴尬的问题存在，所以编译器设计人员把内部类能够使用的参数设定为必须是final来规避这种莫名其妙错误的存在。”</p>
<p>(简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变)</p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p>内部类的原理分析：<a href="http://android.blog.51cto.com/268543/384809" target="_blank" rel="external">http://android.blog.51cto.com/268543/384809</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5B9E_u9A8C"><a href="#u5B9E_u9A8C" class="headerlink" title="实验"></a>实验</h3><p>关于java中的内部类，有很多坑，其中条就是：</p>
<blockquote>
<p>对于定义在函数中的内部类而言，在内部类中可以访问外部函数的局部变量，但这些局部变量必须被申明为final。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="inner-class" scheme="http://paranoidq.github.io/tags/inner-class/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java动态代理与CgLib对比]]></title>
    <link href="http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/"/>
    <id>http://paranoidq.github.io/2016/06/08/java-dynamic-proxy-implementations/</id>
    <published>2016-06-08T07:48:27.000Z</published>
    <updated>2016-06-08T03:59:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>
<a id="more"></a>
<h3 id="JDK_u52A8_u6001_u4EE3_u7406"><a href="#JDK_u52A8_u6001_u4EE3_u7406" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is real object."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Jdk 动态代理必须代理接口,不能代理正常的类.</span><br><span class="line"> *</span><br><span class="line"> * 创建速度快于Cgi,但是运行速度大约比Cgi慢10倍.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxy</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> proxy The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.</span><br><span class="line">     *              Most often you don't need this object.</span><br><span class="line">     * <span class="doctag">@param</span> method</span><br><span class="line">     * <span class="doctag">@param</span> args</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     * <span class="doctag">@throws</span> Throwable</span><br><span class="line">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy: "</span> + proxy.getClass());</span><br><span class="line">        System.out.println(<span class="string">"method: "</span> + method);</span><br><span class="line">        System.out.println(<span class="string">"args: "</span> + args);</span><br><span class="line">        <span class="keyword">if</span> (method.getName().contains(<span class="string">"do"</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"method contains do*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = proxy.getClass().getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            System.out.println(m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      equals</span><br><span class="line">         *      toString</span><br><span class="line">         *      hashCode</span><br><span class="line">         *      doSomething !!!</span><br><span class="line">         */</span></span><br><span class="line">        Class[] interfaces = proxy.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class c : interfaces) &#123;</span><br><span class="line">            System.out.println(c);  <span class="comment">// interface me.util.proxy.jdkproxy.Subject</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * output:</span><br><span class="line">         *      interface me.util.proxy.jdkproxy.Subject</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(proxied, args); <span class="comment">// 在实际对象上invoke方法,同时传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Subject proxy = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                Subject.class.getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> JdkProxy(subject));</span><br><span class="line"></span><br><span class="line">        proxy.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"======="</span>);</span><br><span class="line">        System.out.println(proxy); <span class="comment">// toString的调用同样会dispatch到invoke,因此会被也"包装"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u603B_u7ED3_u51E0_u70B9_uFF1A"><a href="#u603B_u7ED3_u51E0_u70B9_uFF1A" class="headerlink" title="总结几点："></a>总结几点：</h4><ol>
<li>只能代理接口，不能代理类（原因在与newProxyInstane参数中需要被代理类的接口数组）。如果将newProxyInstance返回的Object转为RealSubject，则报异常：<code>java.lang.ClassCastException: com.sun.proxy.$Proxy0 cannot be cast to me.util.proxy.jdkproxy.RealSubject</code></li>
<li><code>java.lang.Object</code>的方法<code>hashCode()</code>、<code>equals()</code>和<code>toString()</code>也会被代理类拦截。（原因在代码最后的<code>toString(proxy)</code>也触发了代理类的输出）</li>
<li>代理实例本身会被传递给invoke，作为第一个参数，即proxy。可以通过这个获取代理实例及其类型信息（代码中，我们获得了代理实例实际上有doSomething()这个方法，因为代理实例也继承了接口Subject！<strong>所以说为什么要传入classloader，因为实际上是Java在用bytecode生成一个实现了Subject接口的动态代理类啊！这不就是隐式地在用反射构建一个类么？</strong>）</li>
</ol>
<p>JDK动态代理类的字节码是由Java在运行时通过反射动态生成的。</p>
<p>上面的例子基本已经显示了JDK代理的重要特性，下面整理说明一些重点：（主要参考Oracle JavaDoc）</p>
<ol>
<li>invoke()的返回值会传递给代理实例，从而返回给客户端，因此客户端的代理实例声明的返回值类型要注意匹配。</li>
<li></li>
<li>invoke代理的函数的参数列表以数组形式给出，对基本类型做了默认的boxing。另外，注意，在invoke内部可以任意修改这个参数数组，这里Java没有约束。（当然，一般来说修改函数的参数是很危险的，尤其还是这种经过代理的调用，会让调用方完全不知情！）</li>
</ol>
<h3 id="CGLib_u52A8_u6001_u4EE3_u7406"><a href="#CGLib_u52A8_u6001_u4EE3_u7406" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * cgi代理可以代理任何类,采用的方式是创建类的子类,然后在子类中调用父类的方法,并织入aop的逻辑</span><br><span class="line"> *</span><br><span class="line"> * 创建慢,但运行性能快于jdk.</span><br><span class="line"> * 适用于对象创建少,长期使用的情况,如singleton.</span><br><span class="line"> *</span><br><span class="line"> * Created by paranoidq on 16/1/18.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CgLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(clazz);  <span class="comment">// 设置被代理类, CgLib根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Before method"</span>);</span><br><span class="line">        <span class="comment">// invoke()会造成循环调用, 因为调用的还是子类对象的方法, 而子类对象的方法还是会被拦截.</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"After method"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CgLibProxy proxyHandler = <span class="keyword">new</span> CgLibProxy();</span><br><span class="line">        <span class="comment">// proxy normal class: RealSubject</span></span><br><span class="line">        RealSubject proxy = (RealSubject) proxyHandler.getProxy(RealSubject.class);</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类</li>
<li>可以代理没有接口的类(JDK动态代理则不行)</li>
<li>通过字节码技术为被代理的类创建子类，并在子类中采用方法<code>intercept</code>拦截所有父类方法的调用</li>
<li>显然，基于第三点，CGlib不能代理final类</li>
<li>pom包: cglib + asm (底层依赖于asm)</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html" target="_blank" rel="external">Java Doc</a><br><a href="http://blog.csdn.net/janice0529/article/details/42884019" target="_blank" rel="external">http://blog.csdn.net/janice0529/article/details/42884019</a><br><a href="http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-reflection/dynamic-proxies.html</a><br><a href="http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/" target="_blank" rel="external">http://www.techavalanche.com/2011/08/24/understanding-java-dynamic-proxy/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898"><a href="#u9759_u6001_u4EE3_u7406_u7684_u95EE_u9898" class="headerlink" title="静态代理的问题"></a>静态代理的问题</h3><p><img src="http://images.techhive.com/images/idge/imported/article/jvw/2000/11/jw-1110-proxy-100157716-orig.gif" alt="proxy pattern"></p>
<ol>
<li>紧耦合：代理类必须实现被代理对象的接口</li>
<li>硬编码：项目中大量充斥着类似**proxy这样的类</li>
<li>无法动态添加方法的拦截，会导致代码侵入</li>
</ol>
<p>如何解决问题？实际上也就是解决依赖的问题，代理类的创建不依赖于硬编码，想什么时候创建就什么时候创建，本质上也就是动态构建类和实例吧。JDK动态代理就是利用了Java的反射机制动态构建代理类和实例的。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="proxy" scheme="http://paranoidq.github.io/tags/proxy/"/>
    
      <category term="cglib" scheme="http://paranoidq.github.io/tags/cglib/"/>
    
      <category term="java" scheme="http://paranoidq.github.io/categories/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[node.js安装express框架时出现command not found问题]]></title>
    <link href="http://paranoidq.github.io/2016/06/07/nodejs-express-install/"/>
    <id>http://paranoidq.github.io/2016/06/07/nodejs-express-install/</id>
    <published>2016-06-07T12:23:45.000Z</published>
    <updated>2016-06-07T12:37:47.000Z</updated>
    <content type="html"><![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br><a id="more"></a></p>
<p>安装时在文件夹下输入：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express</span><br></pre></td></tr></table></figure></p>
<p>但是无法使用express命令，出现<code>express: command not found</code>。原因在于在express4.0中，cli需要单独安装才能使用，cli功能被包含在<code>express-generator</code> package中。</p>
<p>因此需要如下操作：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g express-generator</span><br></pre></td></tr></table></figure></p>
<p>参考: <a href="http://stackoverflow.com/questions/23002448/express-command-not-found" target="_blank" rel="external">http://stackoverflow.com/questions/23002448/express-command-not-found</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在安装nodejs的web框架express时遇到的问题及解决方案。<br>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/tags/nodejs/"/>
    
      <category term="express" scheme="http://paranoidq.github.io/tags/express/"/>
    
      <category term="nodejs" scheme="http://paranoidq.github.io/categories/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pyenv神器]]></title>
    <link href="http://paranoidq.github.io/2016/06/04/pyenv%E7%A5%9E%E5%99%A8/"/>
    <id>http://paranoidq.github.io/2016/06/04/pyenv神器/</id>
    <published>2016-06-04T09:23:24.000Z</published>
    <updated>2016-06-07T12:09:46.000Z</updated>
    <content type="html"><![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="u8BBE_u7F6E_u56FD_u5185_u955C_u50CF"><a href="#u8BBE_u7F6E_u56FD_u5185_u955C_u50CF" class="headerlink" title="设置国内镜像"></a>设置国内镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mirrors</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_BUILD_MIRROR_URL=<span class="string">"http://pyenv.qiniudn.com/pythons/"</span></span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">version</span><span class="comment"> // 正在使用的版本</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="comment">--list</span></span><br><span class="line"></span><br><span class="line">pyenv install <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv uninstall <span class="number">3.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 全局设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">global</span> <span class="number">3.5</span><span class="number">.0</span> <span class="comment"> // 本地目录设置</span></span><br><span class="line"></span><br><span class="line">pyenv <span class="built_in">local</span> <span class="keyword">system</span> <span class="comment"> // 直接使用系统自带版本</span></span><br></pre></td></tr></table></figure>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><ol>
<li>如何删除已经安装的python版本: <a href="http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di" target="_blank" rel="external">http://stackoverflow.com/questions/22774529/what-is-the-safest-way-to-removing-python-framework-files-that-are-located-in-di</a></li>
<li>一般而言，系统库放/System/Library，而应用程序依赖的放/Library，所以，苹果自带的python放在前者，而用户自己装的python（比如官方网站下载的）会自动装在后者。（homebrew安装的就在后者）</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/yyuu/pyenv" target="_blank" rel="external">https://github.com/yyuu/pyenv</a><br><a href="http://v2in.com/pyenv-installation-and-usage.html" target="_blank" rel="external">http://v2in.com/pyenv-installation-and-usage.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>python版本管理神器： pyenv</p>
<h3 id="u5B89_u88C5"><a href="#u5B89_u88C5" class="headerlink" title="安装"></a>安装</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>pyenv</span><br></pre></td></tr></table></figure>
<h3 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h3><p>将一下shell加入.bash_profile或.zshrc<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">set</span> up <span class="comment">pyenv</span></span><br><span class="line">export <span class="comment">PYENV_ROOT=</span>/usr/<span class="comment">local</span>/var/<span class="comment">pyenv</span></span><br><span class="line">if <span class="comment">which pyenv &gt;</span> /dev/<span class="comment">null</span>; <span class="keyword">then</span> eval <span class="string">"$(pyenv init -)"</span>; fi</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="pyenv" scheme="http://paranoidq.github.io/tags/pyenv/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx与tomcat有什么区别]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/"/>
    <id>http://paranoidq.github.io/2016/05/27/nginx-vs-tomcat/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>
<a id="more"></a>
<p>Http Server的核心是Http协议层面的传输和访问控制，包括代理、负载均衡等。客户端通过Http协议访问Http Server上的文件资源(HTML文件、图片等)，然后Http Server如实将文件通过Http协议传输给客户端。当然，通过<code>CGI</code>技术也可以对Http Server传输的内容进行一些处理。<br>大多数时候，Nginx主要作为Tomcat前端的负载均衡器和代理，负责请求的转发和静态内容的直接返回。因为其高效的IO机制[2]，能够显著提高系统的吞吐率。</p>
<p>Web App Server，应用执行的容器。它首先需要支持开发语言的 Runtime（对于 Tomcat 来说，就是 Java），保证应用能够在应用服务器上正常运行。其次，需要支持应用相关的规范，例如类库、安全方面的特性。对于 Tomcat 来说，就是需要提供 JSP/Sevlet 运行需要的标准类库、Interface 等。为了方便，<br>应用服务器往往也会集成 HTTP Server 的功能，但是不如专业的 HTTP Server 那么强大，所以应用服务器往往是运行在 HTTP Server 的背后，执行应用，将动态的内容转化为静态的内容之后，通过 HTTP Server 分发到客户端。<br>Tomcat和Jetty，WebLogic同属一类。</p>
<p><hr></p>
<blockquote>
<p>“tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”</p>
</blockquote>
<p>—— 不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用，也就是说servlet容器必须由java或者基于jvm的语言实现。<br><strong>本质上，Servlet是J2EE规范的一部分，规定了容器和Web App必须遵循的接口规范。容器必须按照接口解析Java类，然后处理请求；同样Web App也只有按照规范来编写实现类，才能被容器所加载解析，从而完成特定的功能。</strong></p>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.zhihu.com/question/32212996" target="_blank" rel="external">https://www.zhihu.com/question/32212996</a></li>
<li><a href="http://90112526.blog.51cto.com/6013499/1059700" target="_blank" rel="external">http://90112526.blog.51cto.com/6013499/1059700</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u89E3_u6790"><a href="#u89E3_u6790" class="headerlink" title="解析"></a>解析</h3><p>Apache/Nginx应该叫做<code>HTTP Server</code>；而Tomcat则是一个<code>Web App Server</code>，更准确的说是JSP/Servlet的Web App Server，因为其他语言开发的web应用无法在Tomcat上运行。</p>]]>
    
    </summary>
    
      <category term="碎片" scheme="http://paranoidq.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
      <category term="server" scheme="http://paranoidq.github.io/tags/server/"/>
    
      <category term="nginx" scheme="http://paranoidq.github.io/tags/nginx/"/>
    
      <category term="tomcat" scheme="http://paranoidq.github.io/tags/tomcat/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python parameters]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Python-parameters-explained/"/>
    <id>http://paranoidq.github.io/2016/05/27/Python-parameters-explained/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>
<a id="more"></a>
<h3 id="u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29"><a href="#u4F4D_u7F6E_u53C2_u6570_positional_parameter_28_u56FA_u5B9A_u53C2_u6570_29" class="headerlink" title="位置参数 positional parameter(固定参数)"></a>位置参数 positional parameter(固定参数)</h3><ol>
<li><p>函数定义时：其中的x,n 都是固定<strong>形参</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用时：如果不指定名字，则传入的两个<strong>实参</strong>按照位置顺序依次赋给<strong>形参</strong>x和n</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于是位置参数，所以参数名在调用的时候是没有意义的，只有参数的顺序才有意义。因为形参会根据顺序依次匹配实参。</p>
<h3 id="u9ED8_u8BA4_u53C2_u6570_default_parameter"><a href="#u9ED8_u8BA4_u53C2_u6570_default_parameter" class="headerlink" title="默认参数 default parameter"></a>默认参数 default parameter</h3><p>如果不传递n的话，上面的调用会报错：缺少位置<strong>实参</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'n'</span></span><br></pre></td></tr></table></figure></p>
<p>这时候就可以靠默认参数来帮助我们省事，不用每次都给默认形参传递实参了</p>
<ol>
<li><p>函数定义时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, n=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>默认参数定义<strong>必须</strong>在所有的位置参数之后，并且默认参数的后面不能再有位置参数</li>
<li>默认参数的必须指向不变的对象，否则会掉坑<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=[])</span>:</span></span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，</span></span><br><span class="line"><span class="comment"># 它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</span></span><br><span class="line"><span class="comment"># 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的做法：通过None这个不变的默认参数来做</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span><span class="params">(L=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数调用时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以不提供默认参数的实参，也可以提供</span></span><br><span class="line">func(<span class="string">'abc'</span>)  </span><br><span class="line">func(<span class="string">'abc'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 对于多个默认参数的情况，如果按顺序提供，可以不指定默认形参的名字；</span></span><br><span class="line"><span class="comment"># 否则需指定名字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x, n=<span class="number">1</span>, m=<span class="number">2</span>)</span>:</span></span><br><span class="line">   <span class="keyword">pass</span></span><br><span class="line">func2(<span class="string">'abc'</span>, m=<span class="number">23</span>, n=<span class="number">24</span>)</span><br></pre></td></tr></table></figure>
<p>注意：不按顺序提供实参的情况仅仅适用于默认参数部分。也就是无论如何，必须先按顺序提供位置参数，之后提供的默认实参才有不按顺序一说。下面的调用是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(n=<span class="number">10</span>, <span class="string">'acb'</span>)</span><br><span class="line"><span class="comment"># output: SyntaxError: non-keyword arg after keyword arg</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53EF_u53D8_u53C2_u6570"><a href="#u53EF_u53D8_u53C2_u6570" class="headerlink" title="可变参数"></a>可变参数</h3><p>在定义函数的时候，传入的位置参数个数不确定的时候使用</p>
<p>不用可变参数怎么做？转化为list或tuple：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">calc((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure></p>
<p>利用可变参数就可以直接传入，不需要显示转化了<code>calc(1, 2, 3)</code></p>
<ol>
<li><p>函数定义<br>使用*表达式即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    <span class="comment"># the same with above</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：可以传入任意个数的实参，包括0个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于对已有的列表进行操作</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">calc(*nums)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：函数调用的时候，实参做了拷贝，原有的实参不变！</p>
<p>可变参数可以同时定义在位置参数后面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （2）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （3）</span></span><br><span class="line"><span class="comment"># output: 'abc', ('e', 'f', 'g')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x=<span class="string">'123'</span>, *args)</span>:</span></span><br><span class="line">    print(x)</span><br><span class="line">    print(args)</span><br><span class="line">func(<span class="string">'abc'</span>)</span><br><span class="line"><span class="comment"># output: 'abc' ()</span></span><br><span class="line">func(<span class="string">'abc'</span>, <span class="string">'efg'</span>) <span class="comment"># （4）</span></span><br><span class="line"><span class="comment"># output: 'abc' ('efg')</span></span><br><span class="line">func(<span class="string">'abc'</span>, *<span class="string">'efg'</span>) <span class="comment"># （5）</span></span><br><span class="line"><span class="comment"># output: 'c', ('f', 'g')</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>优先匹配位置参数, 无论有没有默认值。有默认值覆盖默认值，没有默认值赋值。剩下来的部分才给可变参数！</li>
<li>注意(2)和(3)调用方式的不同</li>
<li>注意(4)和(5)结果的不同</li>
</ul>
<h3 id="u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09"><a href="#u5173_u952E_u5B57_u53C2_u6570_uFF08keyword_parameter_uFF09" class="headerlink" title="关键字参数（keyword parameter）"></a>关键字参数（keyword parameter）</h3><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">   print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：<br>可以只传入位置参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Michael'</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<p>也可以传入任意个数任意名字的关键字实参</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br></pre></td></tr></table></figure>
<p>传入dict的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra = &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=extra[<span class="string">'city'</span>], job=extra[<span class="string">'job'</span>])</span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, **extra)</span><br></pre></td></tr></table></figure>
<p>注意：注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra</p>
</li>
</ol>
<h3 id="u547D_u540D_u5173_u952E_u5B57_u53C2_u6570"><a href="#u547D_u540D_u5173_u952E_u5B57_u53C2_u6570" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数</p>
<ol>
<li><p>函数定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>定义时可以有缺省值：由于指定名字，所以带缺省值的parameter不关心顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city=<span class="string">'beijing'</span>, job)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须传入参数名(除非使用定义了的缺省值，连值也不传)，否则会报TypeError</span></span><br><span class="line">person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u53C2_u6570_u7684_u7EC4_u5408"><a href="#u53C2_u6570_u7684_u7EC4_u5408" class="headerlink" title="参数的组合"></a>参数的组合</h3><p>必须是如下顺序：<br><strong>必选参数、默认参数、可变参数/命名关键字参数和关键字参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'args ='</span>, args, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a, b, c=<span class="number">0</span>, *, d, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'a ='</span>, a, <span class="string">'b ='</span>, b, <span class="string">'c ='</span>, c, <span class="string">'d ='</span>, d, <span class="string">'kw ='</span>, kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = () kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, x=<span class="number">99</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">3</span> args = (<span class="string">'a'</span>, <span class="string">'b'</span>) kw = &#123;<span class="string">'x'</span>: <span class="number">99</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="keyword">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">'ext'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于任意函数，都可以通过类似func(<em>args, *</em>kw)的形式调用它，无论它的参数是如何定义的</p>
<p>反之，接受任何参数的函数，可以定义为func(<em>args, *</em>kw)这种形式。这种定义并不好，实际上，没有通用的规则在一个接受任何参数的函数内部做处理。但是对于decorator等一些应用，接受任何参数的设定就非常有用，因为decorator不关心包装的函数参数是什么，它确实可能需要一个这样的机制来传参。</p>
<h3 id="u6CE8_u610F_u70B9_uFF1A"><a href="#u6CE8_u610F_u70B9_uFF1A" class="headerlink" title="注意点："></a>注意点：</h3><ol>
<li><p>关键字参数会覆盖位置参数的默认值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'a:%s, b:%s, c:%s'</span> % (a, b, c))</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)  <span class="comment"># 关键字参数会覆盖前面的默认值</span></span><br><span class="line"><span class="comment"># output: a:z, b:d, c:r</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数与默认参数不同</p>
<ul>
<li>在定义的适合，默认参数本质上还是给了默认值的位置参数，必须定义在关键字参数的前面；而关键字参数应该最后定义，并且需要<code>**</code>表达式</li>
<li>在调用时候，默认参数部分会优先匹配，匹配之后剩下来的才给关键字参数。所以在函数调用的时候谈论关键字参数实际上没有意义，它只是函数定义时的一个为了扩展用的占位符而已<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a=<span class="string">'a'</span>, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="comment"># output: a b c &#123;&#125;</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125; # 注意，全部先匹配了默认参数</span></span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>, <span class="string">'d'</span>:<span class="string">'z'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;'d': 'z'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用kwargs为没有提供默认值的位置参数提供值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="string">'b'</span>, c=<span class="string">'c'</span>, **kwargs)</span>:</span></span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(kwargs)</span><br><span class="line">func(**&#123;<span class="string">'a'</span>: <span class="string">'z'</span>, <span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: z d r &#123;&#125;</span></span><br><span class="line"><span class="comment"># 如果kwargs里面没有为a提供值，那么就会报TypeError了</span></span><br><span class="line">func(**&#123;<span class="string">'b'</span>: <span class="string">'d'</span>, <span class="string">'c'</span>: <span class="string">'r'</span>&#125;)</span><br><span class="line"><span class="comment"># output: TypeError: func() missing 1 required positional argument: 'a'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Best_Practices_3A"><a href="#Best_Practices_3A" class="headerlink" title="Best Practices:"></a>Best Practices:</h3><ol>
<li><p><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP-3102</a>: 定义了keyworkd-only 参数（本质就是命名关键字参数），避免模糊不清地被位置参数匹配。（”keyword-only” arguments: arguments that can only be supplied by keyword and which will never be automatically filled in by a positional argument）</p>
<p>有时候使用者希望函数可以接受可变参数，同时接受一些以keword形式传递的实参。如果不允许在可变参数后面定义named-keyword参数的话，唯一的解决办法是同时定义<code>*args</code>和<code>**kwargs</code>，然后手动抽取其中的一些entry。<br>Why? 看实参传递的顺序，non-keyword实参 &gt; keyword实参。所以如果定义在可变参数前，可能会被位置参数匹配掉(也就是不是真正意义上的keyword参数，而可能被解释器认为是带默认值的位置参数)。</p>
<p>PEP3102允许在可变参数后面定义regular parameter,作为keyword-only arguments。永远不会被位置参数匹配，必须指定名字。</p>
<p>定义方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时有可变参数存在， 可变参数会suck up所有的non-keyword实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords</span><span class="params">(*wordlist, case_sensitive=False)</span>:</span></span><br><span class="line"><span class="comment"># 没有可变参数存在, * means不允许任何可变参数存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortwords2</span><span class="params">(*, case_sensitive)</span>:</span></span><br></pre></td></tr></table></figure>
<p>显然，case_sensitive只能以keyword的方式赋值，不会被位置参数匹配。</p>
</li>
</ol>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431752945034eb82ac80a3e64b9bb4929b16eeed1eb9000" target="_blank" rel="external">廖雪峰的Python教程</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3102/" target="_blank" rel="external">PEP3102</a> </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u63D0_u7EB2"><a href="#u63D0_u7EB2" class="headerlink" title="提纲"></a>提纲</h3><p>本文主要从以下几个方面分析python的参数机制：</p>
<ol>
<li>固定参数(位置参数)</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ol>
<p>在每个部分中，我们区分<strong>函数的定义</strong>和<strong>函数的调用</strong>。<br>对于函数定义时的参数，我们称为parameter（形参）；对于函数调用时的参数，我们称之为argument(实参)。区分这两点对于解释清楚一些混淆的东西很重要</p>
<p>所以，以上的参数机制其实都是指的是函数定义时的形参，而不是调用时的实参！</p>]]>
    
    </summary>
    
      <category term="python" scheme="http://paranoidq.github.io/tags/python/"/>
    
      <category term="python" scheme="http://paranoidq.github.io/categories/python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大数据生态圈技术总结（持续补充）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/"/>
    <id>http://paranoidq.github.io/2016/05/27/Big-data-ecosystem/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><ol>
<li><p>磁盘</p>
<ul>
<li>HDFS</li>
<li>S3</li>
<li>Ceph</li>
<li>NFS</li>
<li>Gluster FS</li>
</ul>
</li>
<li><p>内存</p>
<ul>
<li>Tachyon</li>
<li>Spark</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u6570_u636E_u5E93"><a href="#u5206_u5E03_u5F0F_u6570_u636E_u5E93" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><ol>
<li><p>磁盘</p>
<ul>
<li>Cassandra</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
</li>
<li><p>内存 </p>
<ul>
<li>Redis</li>
<li>Memcached</li>
</ul>
</li>
</ol>
<h3 id="u5206_u5E03_u5F0F_u8BA1_u7B97"><a href="#u5206_u5E03_u5F0F_u8BA1_u7B97" class="headerlink" title="分布式计算"></a>分布式计算</h3><ol>
<li><p>批处理</p>
<ul>
<li>Hadoop MapReduce</li>
<li>Spark(支持迭代)</li>
<li>Flink(支持迭代)</li>
</ul>
</li>
<li><p>流式计算</p>
<ul>
<li>Storm</li>
<li>Samza</li>
<li>Spark Streaming</li>
<li>Flink</li>
</ul>
</li>
<li><p>即席查询(ad-hoc)</p>
<ul>
<li>Hive</li>
<li>SparkSQL</li>
<li>Presto(Facebook)</li>
<li>Impala</li>
<li>Drill(Google Dremel的开源实现)</li>
</ul>
</li>
</ol>
<h3 id="u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406"><a href="#u8D44_u6E90_u8C03_u5EA6_u4E0E_u7BA1_u7406" class="headerlink" title="资源调度与管理"></a>资源调度与管理</h3><ul>
<li>ZooKeeper</li>
<li>YARN</li>
<li>Mesos</li>
</ul>
<h3 id="u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6D88_u606F_u7CFB_u7EDF" class="headerlink" title="分布式消息系统"></a>分布式消息系统</h3><ul>
<li>StormMQ</li>
<li>RabbitMQ</li>
<li>ZeroMQ</li>
<li>Apache ActiveMQ</li>
<li>Jafka(LinkedIn)</li>
<li>Kafka(LinkedIn)</li>
</ul>
<h3 id="RPC_u6846_u67B6"><a href="#RPC_u6846_u67B6" class="headerlink" title="RPC框架"></a>RPC框架</h3><ul>
<li>Apache Avro</li>
<li>Thrift(Facebook)</li>
<li>Kyro</li>
</ul>
<h3 id="u96C6_u7FA4_u76D1_u63A7"><a href="#u96C6_u7FA4_u76D1_u63A7" class="headerlink" title="集群监控"></a>集群监控</h3><ul>
<li>Zabbix</li>
<li>Ganglia</li>
<li>Nagios</li>
<li>Ambari()</li>
</ul>
<h3 id="u6570_u636E_u6536_u96C6"><a href="#u6570_u636E_u6536_u96C6" class="headerlink" title="数据收集"></a>数据收集</h3><ul>
<li>Flume</li>
<li>Scribe(Facebook)</li>
<li>Logstash</li>
<li>Kafka</li>
</ul>
<h3 id="u56FE_u8BA1_u7B97_u6846_u67B6"><a href="#u56FE_u8BA1_u7B97_u6846_u67B6" class="headerlink" title="图计算框架"></a>图计算框架</h3><ul>
<li>Spark Graphx</li>
<li>PowerGraph</li>
<li>Giraph</li>
<li>Neo4j</li>
</ul>
<h3 id="u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60"><a href="#u5927_u89C4_u6A21_u673A_u5668_u5B66_u4E60" class="headerlink" title="大规模机器学习"></a>大规模机器学习</h3><ul>
<li>Spark MLlib</li>
<li>Mahout</li>
<li>PredictionIO</li>
</ul>
<h3 id="u641C_u7D22_u5F15_u64CE"><a href="#u641C_u7D22_u5F15_u64CE" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul>
<li>Lucene</li>
<li>Solr</li>
<li>ElasticSearch</li>
<li>Sphinx</li>
<li>SenseiDB</li>
</ul>
<h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><ul>
<li>OpenStack</li>
<li>Docker </li>
<li>Kubernetes(容器调度管理)</li>
</ul>
<h3 id="u57FA_u7840_u7ED3_u6784"><a href="#u57FA_u7840_u7ED3_u6784" class="headerlink" title="基础结构"></a>基础结构</h3><ul>
<li>LevelDB</li>
<li>SSTable(BigTable基础)</li>
<li>RecordIO(文件格式)</li>
<li>Flat Buffer(Google, 高效、跨平台的序列化库)</li>
<li>ProtocolBuffers(Google, 数据描述语言，类似于XML能够将结构化数据序列化，可用于数据存储、通信协议等方面)</li>
<li>Consistent Hashing</li>
<li>Netty(提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序)</li>
<li>BloomFilter</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.36dsj.com/archives/25042" target="_blank" rel="external">http://www.36dsj.com/archives/25042</a><br><a href="http://www.csdn.net/article/2015-09-11/2825674" target="_blank" rel="external">http://www.csdn.net/article/2015-09-11/2825674</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF"><a href="#u5206_u5E03_u5F0F_u6587_u4EF6_u7CFB_u7EDF" class="headerlink" title="分布式文件系统"><]]>
    </summary>
    
      <category term="大数据" scheme="http://paranoidq.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="攻略" scheme="http://paranoidq.github.io/tags/%E6%94%BB%E7%95%A5/"/>
    
      <category term="top" scheme="http://paranoidq.github.io/tags/top/"/>
    
      <category term="大数据" scheme="http://paranoidq.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近几年前端技术盘点以及2016年技术发展方向(好文，转)]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/front-end-trend/"/>
    <id>http://paranoidq.github.io/2016/05/27/front-end-trend/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.barretlee.com/blog/2015/12/10/after-framework-we-gonna-to-hug-data/" target="_blank" rel="external">http://www.barret]]>
    </summary>
    
      <category term="前端" scheme="http://paranoidq.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="前端" scheme="http://paranoidq.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[什么是中间件？]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/"/>
    <id>http://paranoidq.github.io/2016/05/27/middleware-expalined-simply/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料研究研究。</p>
<h3 id="u5B9A_u4E49"><a href="#u5B9A_u4E49" class="headerlink" title="定义"></a>定义</h3><p>维基百科定义：</p>
<blockquote>
<p>提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟，特别是应用软件对于系统软件的集中的逻辑，在现代信息技术应用框架如Web服务、面向服务的体系结构等中应用比较广泛。如数据库、Apache的Tomcat，IBM公司的WebSphere,BEA公司的WebLogic[[应用服务器]，东方通公司的Tong系列中间件，以及Kingdee公司的等都属于中间件。</p>
</blockquote>
<p>简单归纳：<br>业务应用 - 中间件 - 基础资源</p>
<ul>
<li>中间件处于两者中间的的位置，封装基础资源，向上层提供更完善的功能。</li>
<li>基础资源包括硬的资源：如CPU、存储(分布式)、网络；我个人认为也包括进程、线程、消息队列、数据库这种软性资源，中间件对这些资源做了封装处理。</li>
</ul>
<h3 id="u4F5C_u7528"><a href="#u4F5C_u7528" class="headerlink" title="作用"></a>作用</h3><ul>
<li>封装</li>
<li>整合</li>
<li>屏蔽</li>
<li>容错</li>
</ul>
<p>我个人归纳为这四个主要功能。封装和整合的是基础资源，使得难用的基础资源更便于使用，而不用考虑细节。（调用顺序、分布式、配置、初始化属性等等）。屏蔽的是底层细节，同时也屏蔽底层的差异（例如，JVM这种本质意义上其实也可算作中间件，通过JVM屏蔽不同系统的差异，从而能够无差异运行Java程序）。容错，则是中间件的另一个重要作用，保证上层无论如何调用，都会得到相应的处理，而不会将错误传递到底层去或直接消失。</p>
<h3 id="u5E38_u89C1_u79CD_u7C7B_uFF1A"><a href="#u5E38_u89C1_u79CD_u7C7B_uFF1A" class="headerlink" title="常见种类："></a>常见种类：</h3><ul>
<li>分布式调用RPC：</li>
<li>消息队列</li>
<li>事务处理</li>
<li>数据库组件</li>
<li>安全组件</li>
<li>并发组件</li>
<li>应用容器组件</li>
<li>日志组件：Apache Kafaka</li>
<li>监控组件：Zookkeeper, Mesos, </li>
</ul>
<h3 id="u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29"><a href="#u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u7684_u51E0_u4E2A_u6848_u4F8B_28_u672C_u8282_u6765_u81EA_u963F_u91CC_u5DF4_u5DF4_u4E2D_u95F4_u4EF6_u56E2_u961F_u535A_u5BA2_29" class="headerlink" title="阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)"></a>阿里巴巴中间件的几个案例(本节来自阿里巴巴中间件团队博客)</h3><p><img src="http://jm.taobao.org/wp-content/uploads/2013/07/jm.jpg" alt="阿里巴巴中间件支撑平台"></p>
<ul>
<li><strong>Diamond</strong>: 软负载配置中心，用于存储静态配置，并能够提供配置变更动态推送功能，结构简单，超高可用性。在全网被使用于存储不经常发生变化的配置信息。</li>
<li><strong>Notify</strong>, <strong>Meta</strong>: 消息中间件</li>
<li><strong>HSF</strong>: 阿里分布式服务框架，统一整个集团rpc的调用，包括服务方式的统一调用，软负载，服务治理等，提供一套简单方便，高性能的分布式服务框架。</li>
<li><strong>eagleeye</strong>: 淘宝分布式跟踪系统，该系统实现基于单链路的实时监控，系统依赖，性能调优，风险控制等</li>
<li><strong>Pandora</strong>: 淘宝隔离容器，该系统主要解决大规模富二方包升级，二方包隔离，二方包监控等问题。</li>
<li><strong>TDDL</strong>: 通用数据访问层，部署在客户端的jar包，用于将用户的SQL路由到指定的数据库中。目前有1000+应用在使用</li>
<li><strong>精卫</strong>: 通用数据总线，用于将数据从一个数据节点迁移到其他一个或多个数据节点中，目前支持mysql,oracle,hbase等。目前有100+应用在使用</li>
<li><strong>愚公</strong>: 数据自动迁移引擎，海量数据自动运维工具，可用于对用户无影响的自动扩容和缩容，数据平滑迁移，以及异构数据源迁移，目前已经完成了214次业务迁移或扩容。</li>
<li><strong>NewSQL</strong>: NewSQL系统，可以将SQL运行于传统MYSQL/Oracle关系数据库，也可以支持NoSQL数据库如bdb , hbase等。 可以实现其中的跨机合并和跨机交操作等复杂关系操作。</li>
<li><strong>CSP2.0</strong>: 持续稳定性平台帮助阿里系统保障高可用性，包含线上压测、容量规划、依赖治理、限流降级、监控报警、问题定位等模块。</li>
<li><strong>Hotspot</strong>: 性能分析平台通过对基础软件、服务端、前端加载、网络、CDN等方面的性能分析，来帮助阿里系统提升吞吐量、降低延迟时间、节约成本。</li>
<li><strong>TProfiler</strong>: TProfiler是可以在生产环境长期使用的性能分析工具，通过在Java层面记录代码执行热点、对象创建热点等数据，帮助系统定位性能瓶颈。</li>
</ul>
<h3 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6</a><br><a href="http://jm-blog.aliapp.com/?page_id=2449" target="_blank" rel="external">阿里巴巴中间件团队博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前找工作之后，主管打电话问将来希望做哪个方向的技术，中间件还是linux还是云计算之类的，没头绪。发现自己其实对于这些方向的具体内容倒不明确了。其他的还好说，之前也有了解到淘宝中间件团队这样的，觉得很NB，但是对于这个中间件到底是什么，似乎没有深究。元旦正好空闲，查阅资料]]>
    </summary>
    
      <category term="java" scheme="http://paranoidq.github.io/tags/java/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="中间件" scheme="http://paranoidq.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="架构" scheme="http://paranoidq.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git 分支管理与实践（hexo博客源文件管理）]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/Git-branch-management/"/>
    <id>http://paranoidq.github.io/2016/05/27/Git-branch-management/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br><code>git branch -a</code></p>
<p>查看本地分支和远程分支的push情况<br><code>git log &lt;local-branch&gt; ^origin/&lt;remote-branch&gt;</code>   # 可以查看本地有远程没有的提交。<br><code>git log &lt;remote-branch&gt; ^&lt;local-branch&gt;</code>       # 可以查看远程有本地没有的提交。</p>
<h3 id="u521B_u5EFA"><a href="#u521B_u5EFA" class="headerlink" title="创建"></a>创建</h3><p>创建本地分支<br><code>git checkout -b dev</code></p>
<h3 id="u5173_u8054"><a href="#u5173_u8054" class="headerlink" title="关联"></a>关联</h3><p>目的：避免每次都需要制定push的具体分支，可以关联后在本地分支下直接push即可</p>
<p>两种方案：</p>
<ol>
<li>在本地branch第一次push的时候就指定：<br> <code>git push -u origin &lt;remote-branch&gt;</code></li>
<li>以后指定：<br><code>git branch --set-upstream &lt;local-branch&gt; origin/&lt;remote-branch&gt;</code><br>或<br><code>git push --set-upstream origin &lt;remote-branch&gt;</code><br>你的repo下的git/config会多出类似这样的配置：<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[branch "src"]</span></span><br><span class="line"><span class="attr">remote</span> = origin</span><br><span class="line"><span class="attr">merge</span> = refs/heads/src</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="u63A8_u9001"><a href="#u63A8_u9001" class="headerlink" title="推送"></a>推送</h3><p><code>git push origin &lt;local-branch&gt;</code>  # 推送本地分支到对应的远程分支</p>
<p><code>git push</code> # 如果指定了远程关联，可以直接push</p>
<p>两种配置： (注意，这个配置是写在~/.gitconfig中的，对所有的repo生效)<br><code>git config --global push.default simple</code>(更好, 只push当前分支到你使用git pull拉取的远程代码)<br><code>git config --global push.default matching</code> （如果没有指定具体分支，会push所有名字对应的分支）</p>
<h3 id="u5220_u9664"><a href="#u5220_u9664" class="headerlink" title="删除"></a>删除</h3><p>删除本地分支<br><code>git branch -d dev (用-D强行删除)</code></p>
<p>删除远程分支<br><code>git push origin --delete dev</code></p>
<h3 id="u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F"><a href="#u5B9E_u4F8B_uFF1A__u7BA1_u7406hexo_u7684src_u5206_u652F" class="headerlink" title="实例： 管理hexo的src分支"></a>实例： 管理hexo的src分支</h3><p>说明：hexo的deployer本身在部署的时候只会生成static文件，并上传到github的master分支，而hexo的一些source和_config.yaml等配置文件则只在本地。因此需要将这些文件也管理到git中去，方便备份和多终端同步。</p>
<p>基本思路是在本地利用src分支，然后上传源文件到src分支，并push到远程的src分支，即可管理。</p>
<p>master分支由于是hexo的页面展示部分，所以其实是不能与origin/master保持同步的，也千万不能push，否则结果就是源文件覆盖了hexo-deployer push到master分支的静态文件，从而访问的时候404了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd &lt;repo&gt;</span><br><span class="line"><span class="variable">$ </span>git init (optional)</span><br><span class="line"><span class="variable">$ </span>git checkout -b src</span><br><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"first commit for src branch"</span></span><br><span class="line"><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>&lt;username&gt;<span class="symbol">:&lt;username&gt;</span>.github.io.git (optional)</span><br><span class="line"><span class="variable">$ </span>git push origin src</span><br></pre></td></tr></table></figure>
<ol>
<li>optional部分，可能由于之前开始建立repo的时候已经做过了，所以不一定要在分支的过程中做了</li>
<li>checkout的时候，需要保证master分支全部commit。（这里其实我做的不够完善，一开始应该是整个本地的网站不要init，让master分支全部被hexo-deployer接管。然后在创建分支的时候，才init。这样可以保证本地只有一个src的分支需要我手动管理。</li>
<li>如果你手贱之前已经建立了master分支，那么有两个办法：<ul>
<li>忽略与origin/master不同步的本地master分支</li>
<li>删除本地的master分支 <code>git branch -D master</code></li>
</ul>
</li>
</ol>
<p><strong>另外一台电脑上如何使用：</strong><br>安装node环境和hexo-cli环境<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew update </span><br><span class="line">$ brew install <span class="keyword">node</span></span><br><span class="line"><span class="title">$</span> npm install hexo-cli -g</span><br></pre></td></tr></table></figure></p>
<p>不要执行hexo init了，而是clone远程的src仓库<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone -<span class="selector-tag">b</span> src git@github<span class="selector-class">.com</span>:&lt;username&gt;:&lt;username&gt;<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span></span><br><span class="line">$ npm install <span class="comment">//根据package.json来下载依赖包</span></span><br></pre></td></tr></table></figure></p>
<p>然后就可以继续写博客了，整个过程，手动管理的只有src，master分支本地需要，由hexo-deployer负责push。</p>
<p>参考文献[1]中还提到了用git submodule解决第三方主题的同步问题，很不错。<br>参考文献[3]中修改hexo-deployer源码，添加了自动在deploy的时候提交src的功能，很nice。</p>
<p>具体方法：<br>修改<code>node_modules\hexo-deployer-git\lib\deployer.js</code>插件的代码，添加gitBaseDir函数。 注意gitBaseDir函数必须写在module块中，否则会出现错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: deployDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gitBaseDir</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">   <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">     args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spawn(<span class="string">'git'</span>, args, &#123;</span><br><span class="line">     cwd: baseDir,</span><br><span class="line">     verbose: verbose</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在push函数中添加提交到src的功能<br><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(repo)</span>&#123;</span></span><br><span class="line">   <span class="keyword">return</span> git(<span class="string">'add'</span>, <span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'commit'</span>, <span class="string">'-m'</span>, message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">       <span class="comment">// Do nothing. It's OK if nothing to commit.</span></span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> git(<span class="string">'push'</span>, <span class="string">'-u'</span>, repo.url, <span class="string">'master:'</span> + repo.branch, <span class="string">'--force'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">     <span class="keyword">return</span> gitBaseDir(<span class="string">'checkout'</span>,<span class="string">'source'</span>);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'add'</span>,<span class="string">'-A'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">            <span class="keyword">return</span> gitBaseDir(<span class="string">'commit'</span>,<span class="string">'-m'</span>,message).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> gitBaseDir(<span class="string">'push'</span>,<span class="string">'-u'</span>,repo.url,<span class="string">'source:source'</span>,<span class="string">'--force'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u53C2_u8003_uFF1A"><a href="#u53C2_u8003_uFF1A" class="headerlink" title="参考："></a>参考：</h3><ol>
<li><a href="http://devtian.me/2015/03/17/blog-sync-solution/" target="_blank" rel="external">如何管理hexo的源文件</a></li>
<li><a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4-Master-%E5%88%86%E6%94%AF?locale=zh-CN" target="_blank" rel="external">为何以及如何删除master分支</a></li>
<li><a href="http://boenyang.github.io/2015/09/09/hello-world/" target="_blank" rel="external">自动化hexo的源文件提交-修改hexo-deployer源码部分</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u67E5_u770B"><a href="#u67E5_u770B" class="headerlink" title="查看"></a>查看</h3><p>查看本地分支<br><code>git branch</code></p>
<p>查看包括远程分支<br]]>
    </summary>
    
      <category term="git" scheme="http://paranoidq.github.io/tags/git/"/>
    
      <category term="git" scheme="http://paranoidq.github.io/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim Commands]]></title>
    <link href="http://paranoidq.github.io/2016/05/27/vim-commands/"/>
    <id>http://paranoidq.github.io/2016/05/27/vim-commands/</id>
    <published>2016-05-27T15:45:36.000Z</published>
    <updated>2016-05-27T15:45:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><h4 id="u79FB_u52A8"><a href="#u79FB_u52A8" class="headerlink" title="移动"></a>移动</h4><ul>
<li>文首：<code>gg</code> / <code>:0</code></li>
<li>文末：<code>shift + g</code> / <code>:$</code></li>
<li>行首：<code>0</code></li>
<li>行末：<code>$</code></li>
<li>到第一个不是空字符的位置：<code>^</code></li>
<li>到最后一个不是空字符的位置：<code>g_</code></li>
</ul>
<a id="more"></a>
<p>按单词移动：</p>
<ul>
<li>到下一个单词的开头：<code>w</code></li>
<li>到下一个单词的结尾：<code>e</code></li>
</ul>
<p>按匹配的单词移动：</p>
<ul>
<li>匹配光标所在的单词，移动到下一个：<code>*</code></li>
<li>匹配光标所在的单词，移动到上一个: <code>#</code></li>
</ul>
<p>按页移动：</p>
<ul>
<li>向下一页：<code>ctrl + F</code></li>
<li>向上一页：<code>ctrl + B</code></li>
<li>向下半页：<code>ctrl + D</code></li>
<li>向上半页：<code>ctrl + U</code></li>
</ul>
<h4 id="u63D2_u5165"><a href="#u63D2_u5165" class="headerlink" title="插入"></a>插入</h4><p>切换到插入模式的几种方式:</p>
<ul>
<li>在光标之前插入：<code>i</code></li>
<li>在行开始前插入：<code>I</code></li>
<li>在光标后面插入：<code>a</code></li>
<li>在行结束后插入：<code>A</code></li>
</ul>
<p>插入行：</p>
<ul>
<li>在当前位置下面插入一行，并进入编辑状态：<code>o</code></li>
<li>在当前位置上面插入一行，并进入编辑状态：<code>O</code></li>
</ul>
<h3 id="u6587_u672C_u64CD_u4F5C"><a href="#u6587_u672C_u64CD_u4F5C" class="headerlink" title="文本操作"></a>文本操作</h3><h4 id="u57FA_u672C_u884C_u64CD_u4F5C"><a href="#u57FA_u672C_u884C_u64CD_u4F5C" class="headerlink" title="基本行操作"></a>基本行操作</h4><p>复制</p>
<ul>
<li>复制一行：<code>yy</code></li>
<li>复制光标到行尾的部分：<code>y$</code></li>
<li>复制多行(1)：<code>Nyy</code> + ‘p’ (粘贴)</li>
<li>复制多行(2)：<code>6, 9 co 12</code> (复制6行和9行中间的部分到12行后面)</li>
</ul>
<p>复制大量的行：</p>
<ol>
<li>光标移到起始行，输入ma</li>
<li>光标移到结束行，输入mb</li>
<li>光标移到粘贴行，输入mc</li>
<li>然后 :’a,’b co ‘c 把 co 改成 m 就成剪切了</li>
</ol>
<p>粘贴</p>
<ul>
<li>粘贴：<code>p</code></li>
</ul>
<p>删除</p>
<ul>
<li>删除光标后一个字符：<code>x</code></li>
<li>删除光标到行尾的部分：<code>d$</code></li>
<li>删除单行：<code>dd</code> / <code>1d</code></li>
<li>删除多行(1)：<code>1, Nd</code> / <code>Ndd</code>(删除包含光标所在行的下面N行)</li>
<li>删除多行(2)：<code>:1, 4 de</code></li>
</ul>
<p>替换</p>
<ul>
<li>替换从光标位置到后一个单词结尾的字符：<code>cw</code></li>
</ul>
<h4 id="u4EFB_u610F_u533A_u95F4_u7684_u6587_u672C_u64CD_u4F5C"><a href="#u4EFB_u610F_u533A_u95F4_u7684_u6587_u672C_u64CD_u4F5C" class="headerlink" title="任意区间的文本操作"></a>任意区间的文本操作</h4><p>首先进入visual模式，直接按v键进入visual模式，然后<code>v+ j/k/h/l</code>进行文本选择</p>
<ul>
<li>剪切：<code>d</code></li>
<li>复制：<code>y</code></li>
<li>粘贴：<code>p</code></li>
</ul>
<h4 id="u884C_u5757_u64CD_u4F5C"><a href="#u884C_u5757_u64CD_u4F5C" class="headerlink" title="行块操作"></a>行块操作</h4><h3 id="u64A4_u9500_u64CD_u4F5C"><a href="#u64A4_u9500_u64CD_u4F5C" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul>
<li>撤销上一个命令： <code>u</code></li>
<li>反撤销：<code>ctrl + r</code> </li>
</ul>
<h3 id="u641C_u7D22_u64CD_u4F5C"><a href="#u641C_u7D22_u64CD_u4F5C" class="headerlink" title="搜索操作"></a>搜索操作</h3><ul>
<li>搜索：<code>/pattern</code></li>
<li>下一个：<code>n</code></li>
<li>上一个：<code>N</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u5149_u6807_u64CD_u4F5C"><a href="#u5149_u6807_u64CD_u4F5C" class="headerlink" title="光标操作"></a>光标操作</h3><h4 id="u79FB_u52A8"><a href="#u79FB_u52A8" class="headerlink" title="移动"></a>移动</h4><ul>
<li>文首：<code>gg</code> / <code>:0</code></li>
<li>文末：<code>shift + g</code> / <code>:$</code></li>
<li>行首：<code>0</code></li>
<li>行末：<code>$</code></li>
<li>到第一个不是空字符的位置：<code>^</code></li>
<li>到最后一个不是空字符的位置：<code>g_</code></li>
</ul>]]>
    
    </summary>
    
      <category term="linux" scheme="http://paranoidq.github.io/tags/linux/"/>
    
      <category term="vim" scheme="http://paranoidq.github.io/tags/vim/"/>
    
      <category term="linux" scheme="http://paranoidq.github.io/categories/linux/"/>
    
  </entry>
  
</feed>
